---
title: 结构
sidebar:
    order: 5
---

import Mermaid from "@components/Mermaid.astro";

## 二叉树和红黑树的问题

二叉搜索树

<Mermaid
    code={`
flowchart TD
a((36)) --> b1((22))
a --> b2((48))
b1 --> c1((19))
b1 --> c2((33))
c1 --> d1((17))
c1 --> d2((20))
c2 --> d3((23))
c2 --> d4((34))
b2 --> c3((45))
b2 --> c4((53))
c3 --> d5((40))
c3 --> d6((46))
c4 --> d7((50))
c4 --> d8((70))
`}
/>

如果按顺序插入，就会出现以下情况

<Mermaid
    code={`
flowchart LR
a((36)) --> b((34))
b --> c((33))
c --> d((23))
d --> e((22))
e --> f((20))
f --> g((19))
g --> h((17))
`}
/>

此时二叉树就会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢

使用 `红黑树` 则可以避免树形成链表的情况，但是在大数据量的情况下，层级还是较深

## B Tree（多路平衡查找树）

以一颗最大 `度数`（max-degree）为 5 阶的 b tree 为例（每个节点最多储存 4 个key，5 个指针）

:::note
`度数` - 指每个节点最大的子节点数量

b tree 的数据和 key 存放在一起
:::

<Mermaid
    code={`
flowchart TD
a(20, 30, 62, 89) --> b1(10, 15, 18)
a --> b2(23, 25, 28)
a --> b3(34, 56, 58)
a --> b4(64, 78, 88)
a --> b5(92, 96, 98)
b1 --> c1(3, 4)
b1 --> c2(14)
b1 --> c3(16, 17)
b1 --> c4(19)
`}
/>

### B Tree 构建过程

> [数据结构在线构建动画](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

以在度数为 5 的 B Tree 内插入 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 数据为例

1. 首先插入 100 65 169 368，构成一个(65, 100, 169, 268)的节点

    此时再插入 900，由于度数为 5，此时树会发生裂变，中间元素向上裂变。(65, 100, 169, 268, 900)内中间元素是 169，裂变后如下：

<Mermaid
    code={`
flowchart TD
a(169) --> b1(65, 100)
a --> b2(368, 900)
`}
/>

2. 依次插入 556 780 35

<Mermaid
    code={`
flowchart TD
a(169) --> b1(35, 65, 100)
a --> b2(368, 556, 780, 900)
`}
/>

3. 此时插入 215 后再次裂变

<Mermaid
    code={`
flowchart TD
a(169, 556) --> b1(35, 65, 100)
a --> b2(215, 368)
a --> b3(780, 900)
`}
/>

4. 依次插入 1200 234 888 158

<Mermaid
    code={`
flowchart TD
a(169, 556) --> b1(35, 65, 100, 158)
a --> b2(215, 234, 368)
a --> b3(780, 888, 900, 1200)
`}
/>

5. 插入 90 后再次裂变

<Mermaid
    code={`
flowchart TD
a(90, 169, 556) --> b1(35, 65)
a --> b4(100, 158)
a --> b2(215, 234, 368)
a --> b3(780, 888, 900, 1200)
`}
/>

6. 插入 1000 后再次裂变

<Mermaid
    code={`
flowchart TD
a(90, 169, 556, 900) --> b1(35, 65)
a --> b4(100, 158)
a --> b2(215, 234, 368)
a --> b3(780, 888)
a --> b5(1000, 1200)
`}
/>

7. 依次插入 88 120 268

<Mermaid
    code={`
flowchart TD
a(90, 169, 556, 900) --> b1(35, 65, 88)
a --> b4(100, 120, 158)
a --> b2(215, 234, 268, 368)
a --> b3(780, 888)
a --> b5(1000, 1200)
`}
/>

8. 插入 250 后裂变后由于根节点的子节点也满了，所以进行了两次裂变，最终结构如下

<Mermaid
    code={`
flowchart TD
a(250) --> b1(90, 169)
a --> b2(556, 900)
b1 --> c1(35, 65, 88)
b1 --> c2(100, 120, 158)
b1 --> c3(215, 234)
b2 --> c4(268, 368)
b2 --> c5(780, 888)
b2 --> c6(1000, 1200)
`}
/>

## B+Tree

B+Tree 结构

:::note
B+Tree 所有的数据都保存在叶子节点
所有的叶子节点会形成一个单项链表
:::

![B+Tree结构](@assets/mysql/mysql-b-p-tree.drawio.png)

### B+Tree 构建过程

> [数据结构在线构建动画](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

构建过程和 `B Tree` 类似，只不过裂变的时候中间的数据会在子节点内保存一份

TODO

## MySQL 内的 B+Tree

MySQL 索引数据结构对经典的 B+Tree 进行了优化

在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高了区间访问的性能

## Hash

哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中

过程类似 Java 内的 HashMap

- 将添加索引的这一列的每个数据进行 hash 算法，再将 hash 值和对应这一列的数据地址存入对应的槽位中
- 如果出现两个 hash 值一样的数据（hash冲突），则将新的数据以链表的方式连接到上一个值后面

hash索引的特点

- hash索引只能用于对等比较（=，in），不支持范围查询（between，&lt;，>）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引

存储引擎支持

在 MySQL 中，支持 hash 索引的是 Memory 引擎，而 InnoDB 中具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的

## InnoDB 选择 B+Tree 作为默认索引的原因

相对于二叉树，层级更少，搜索效率高

对于 B Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样白村大数据量，只能增加树的高度，导致性能降低

相对于 Hash 索引，B+Tree 支持方位匹配及排序操作
