<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>文档</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="linux/index.html"><strong aria-hidden="true">1.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/desktop_env/index.html"><strong aria-hidden="true">1.1.</strong> Linux桌面环境</a></li><li class="chapter-item expanded "><a href="linux/vsftp/index.html"><strong aria-hidden="true">1.2.</strong> vsftp</a></li><li class="chapter-item expanded "><a href="linux/systemd/index.html"><strong aria-hidden="true">1.3.</strong> systemd</a></li></ol></li><li class="chapter-item expanded "><a href="windows/index.html"><strong aria-hidden="true">2.</strong> Windows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="windows/command_prompt/index.html"><strong aria-hidden="true">2.1.</strong> Command Prompt</a></li><li class="chapter-item expanded "><a href="windows/wsl2/index.html"><strong aria-hidden="true">2.2.</strong> wsl2</a></li></ol></li><li class="chapter-item expanded "><a href="docker/index.html"><strong aria-hidden="true">3.</strong> Docker</a></li><li class="chapter-item expanded "><a href="git/index.html"><strong aria-hidden="true">4.</strong> Git</a></li><li class="chapter-item expanded "><a href="java/index.html"><strong aria-hidden="true">5.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/java_basics/index.html"><strong aria-hidden="true">5.1.</strong> Java基础</a></li><li class="chapter-item expanded "><a href="java/multithreading/index.html"><strong aria-hidden="true">5.2.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="java/maven/index.html"><strong aria-hidden="true">5.3.</strong> Maven</a></li><li class="chapter-item expanded "><a href="java/gradle/index.html"><strong aria-hidden="true">5.4.</strong> Gradle</a></li><li class="chapter-item expanded "><a href="java/design_pattern/index.html"><strong aria-hidden="true">5.5.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="java/java_web/index.html"><strong aria-hidden="true">5.6.</strong> Java Web</a></li><li class="chapter-item expanded "><a href="java/SSM/index.html"><strong aria-hidden="true">5.7.</strong> SSM</a></li><li class="chapter-item expanded "><a href="java/project/index.html"><strong aria-hidden="true">5.8.</strong> 项目</a></li><li class="chapter-item expanded "><a href="java/shiro/index.html"><strong aria-hidden="true">5.9.</strong> Shiro</a></li><li class="chapter-item expanded "><a href="java/netty/index.html"><strong aria-hidden="true">5.10.</strong> Netty</a></li><li class="chapter-item expanded "><a href="java/spring/index.html"><strong aria-hidden="true">5.11.</strong> Spring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/spring/spring_security/index.html"><strong aria-hidden="true">5.11.1.</strong> Spring Security</a></li><li class="chapter-item expanded "><a href="java/spring/spring_cloud/index.html"><strong aria-hidden="true">5.11.2.</strong> Spring Cloud</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="mysql/index.html"><strong aria-hidden="true">6.</strong> Mysql</a></li><li class="chapter-item expanded "><a href="nginx/index.html"><strong aria-hidden="true">7.</strong> Nginx</a></li><li class="chapter-item expanded "><a href="redis/index.html"><strong aria-hidden="true">8.</strong> Redis</a></li><li class="chapter-item expanded "><a href="vim/index.html"><strong aria-hidden="true">9.</strong> Vim/Neovim</a></li><li class="chapter-item expanded "><a href="vue/index.html"><strong aria-hidden="true">10.</strong> Vue</a></li><li class="chapter-item expanded "><a href="web/index.html"><strong aria-hidden="true">11.</strong> Web</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<h2 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h2>
<h3 id="关机重启"><a class="header" href="#关机重启"><strong>关机重启</strong></a></h3>
<ul>
<li><code>shutdown -h now</code> 立该进行关机</li>
<li><code>shudown -h 1</code> 1分钟后会关机了</li>
<li><code>shutdown -r now</code> 现在重新启动计算机</li>
<li><code>halt</code>  关机</li>
<li><code>reboot</code> 重启</li>
<li><code>sync</code>  把内存的数据同步到磁盘.</li>
</ul>
<h3 id="用户登录或注销"><a class="header" href="#用户登录或注销"><strong>用户登录或注销</strong></a></h3>
<ul>
<li>登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用<code>su-用户名</code>命令来切换成系统管理员身份</li>
<li>root用户切换到其他用户不需要任何操作</li>
<li>普通用户切换到其他用户需要使用密码登录</li>
<li>使用<code>exit</code>命令退出登录</li>
<li>在提示符下输入logout即可注销用户</li>
<li>logout 注销指令在图形运行级别无效，在运行级别3下有效</li>
</ul>
<h3 id="用户管理"><a class="header" href="#用户管理"><strong>用户管理</strong></a></h3>
<ul>
<li><code>useradd 用户名</code> 添加用户</li>
<li><code>userdel 用户名</code> 删除用户</li>
<li><code>userdel -r 用户名</code> 删除用户，并删除该用户的家目录</li>
<li><code>useradd -d 目录路径 用户名</code> 添加用户并指定该用户的家目录地址</li>
<li><code>passwd 用户名</code> 修改该用户的密码</li>
<li><code>id 用户名</code> 查看该用户的信息</li>
<li><code>su 用户名</code> 切换用户</li>
<li><code>whoami</code> 查看当前是那个用户登录</li>
<li><code>who am i</code>  查看当前是那个用户登录，并显示登录时间</li>
<li><strong>用户组</strong>
<ul>
<li><code>groupadd 组名</code>  新增一个组</li>
<li><code>groupdel 组名</code> 删除一个组 </li>
<li><code>useradd -g 组名 用户名</code>添加用户并添加该用户到那个组内</li>
<li><code>usermod -g 组名</code> 修改该用户的组信息</li>
</ul>
</li>
<li>用户和组相关文件
<ul>
<li>/etc/passwd文件
<ul>
<li>用户( user)的配置文件，记录用户的各种信息</li>
<li>每行的含义∶用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</li>
</ul>
</li>
<li>/etc/shadow 文件
<ul>
<li>口令的配置文件</li>
<li>每行的含义:登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li>
</ul>
</li>
<li>/etc/group文件
<ul>
<li>组(group)的配置文件，记录Linux包含的组的信息每行含义∶组名:口令:组标识号:组内用户列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="运行级别"><a class="header" href="#运行级别"><strong>运行级别</strong></a></h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>0：关机</li>
<li>1：单用户【找回丢失密码】</li>
<li>2：多用户状态没有网络服务</li>
<li>3：多用户状态有网络服务</li>
<li>4：系统未使用保留给用户5:图形界面</li>
<li>6：系统重启</li>
<li>常用运行级别是3和5,也可以指定默认运行级别，后面演示</li>
<li>命令:<code>init[0123456]</code>应用案例:通过<code>init</code>来切换不同的运行级别，比如动5-3，然后关机。</li>
</ul>
</li>
<li>
<p>指定运行级别</p>
<ul>
<li>CentOS7后运行级别说明</li>
<li>在centos7以前,/etc/inittab文件中</li>
<li>进行了简化，如下:
<ul>
<li>multi-user.target: analogous to runlevel 3</li>
<li>graphical.target: analogous to runlevel 5</li>
<li><code>systemctl get-default</code> 查看当前气筒处于那个运行级别</li>
<li><code>systemctl set-default xxx.target</code> 设置系统为那个运行级别</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>v找回root密码</strong></p>
</blockquote>
<ul>
<li>
<p>启动系统，进入开机界面是按<code>e</code>进入编辑界面</p>
</li>
<li>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301102233.png" alt="" /></p>
</li>
<li>
<p>在以下位置添加<code>init=/bin/sh</code></p>
</li>
<li>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210301102519.png" alt="" /></p>
</li>
<li>
<p>输入<code>ctrl+x</code>进入单用户模式</p>
</li>
<li>
<p>进入后执行一下操作</p>
</li>
<li>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210301103058.png" alt="" /></p>
</li>
<li>
<p>等待重启后密码修改成功</p>
</li>
</ul>
<h3 id="帮助指令"><a class="header" href="#帮助指令"><strong>帮助指令</strong></a></h3>
<ul>
<li>man获得帮助信息
<ul>
<li>基本语法:man命令或配置文件(功能描述:获得帮助信息)案例:查看ls命令的帮助信息</li>
</ul>
</li>
<li>help指令
<ul>
<li>基本语法:help命令(功能描述∶获得shell内置命令的帮助信息)</li>
</ul>
</li>
</ul>
<h3 id="文件目录"><a class="header" href="#文件目录"><strong>文件目录</strong></a></h3>
<ul>
<li>
<p><code>pwd</code> 查看当前处于那个目录下</p>
</li>
<li>
<p><code>ls</code> 列出当前目录下的文件</p>
<ul>
<li><code>ls -a</code> 显示当前目录所有的文件和目录,包括隐藏的。</li>
<li><code>ls -l</code> 以列表的方式显示信息</li>
</ul>
</li>
<li>
<p><code>cd</code> 切换目录</p>
<ul>
<li><code>cd 目录路径</code> 切换到指定目录</li>
<li><code>cd ..</code> 退回到上一级目录</li>
<li><code>cd ~</code> 切换到该用户的家目录（直接使用<code>cd</code>不带参数也一样）</li>
</ul>
</li>
<li>
<p><code>mkdir 目录名</code> 创建目录</p>
<ul>
<li><code>mkdir -p</code> 创建1多级目录</li>
</ul>
</li>
<li>
<p><code>rmdir 目录名</code> 删除空目录</p>
<ul>
<li>如果要删除非空目录，必须使用<code>rm -rf 目录名</code>递归删除</li>
</ul>
</li>
<li>
<p><code>touch 文件名</code></p>
<ul>
<li>创建一个空文件</li>
</ul>
</li>
<li>
<p><code>cp</code> 拷贝</p>
<ul>
<li><code>cp -r 目录名</code> 递归复制整个目录</li>
</ul>
</li>
<li>
<p><code>rm 文件或目录名</code> 删除</p>
<ul>
<li><code>rm -r</code> 递归删除文件夹</li>
<li><code>rm -f</code>  强制删除，不提示</li>
</ul>
</li>
<li>
<p><code>mv 文件或目录名</code> 移动</p>
<ul>
<li>移动文件夹或目录，如果要移动的位置就是当前目录，则就是重命名</li>
</ul>
</li>
<li>
<p><code>cat 文件名</code> 显示文件内容</p>
<ul>
<li><code>cat -n</code> 显示行号</li>
</ul>
</li>
<li>
<p><code>more、less</code>查看文件内容</p>
<ul>
<li>这两个命令都是查看文件内容，只不过就是快捷键不同，和看不同文件的方便性</li>
</ul>
</li>
<li>
<p><code>echo 内容</code>输出内容到控制台</p>
</li>
<li>
<p><code>head 文件名</code>查看文件前头10行</p>
<ul>
<li><code>head -n 行数</code> 指定查看文件前多少行（默认前10行）</li>
</ul>
</li>
<li>
<p><code>tail 文件名</code> 查看文件后10行</p>
<ul>
<li><code>tail -n 行数</code> 和head一样</li>
<li><code>tail -f</code> 实时查看文件后几行（ctrl+z 退出）</li>
</ul>
</li>
<li>
<p><code>&gt;</code>、<code>&gt;&gt;</code> 将某个命令的结果重定向到那个位置，一个 <code>&gt;</code>表示覆盖，两个 <code>&gt;&gt;</code> 表示追加</p>
<ul>
<li>例如<code>ls -l &gt;&gt; info.txt</code>
<ul>
<li><code>ls -l</code>意思是显示当前目录下的文件信息，而结果是输出到控制台的，而上面的指令表示把结果输入的info.txt文件内</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ln</code> 软连接（快捷方式）</p>
<ul>
<li><code>ln -s 目录 软连接名（快捷方式名）</code>（这两处地址必须写绝对路径）</li>
</ul>
</li>
<li>
<p><code>history</code> 查看历史使用过的命令</p>
<ul>
<li><code>history 数字</code> 查看最近多少次使用过的命令</li>
<li><code>! 数字</code>  这里数字表示历史命令的id，这条命令表示执行对应id的历史命令</li>
</ul>
</li>
</ul>
<h3 id="日期时间"><a class="header" href="#日期时间"><strong>日期时间</strong></a></h3>
<ul>
<li><code>date</code> 显示当前时间
<ul>
<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 以对应格式显示当前时间</li>
<li><code>date -s 时间</code> 设置当前时间</li>
</ul>
</li>
<li><code>cal</code> 显示当月日历
<ul>
<li><code>cal 年份</code> 显示当年的日历</li>
</ul>
</li>
</ul>
<h3 id="搜索查找"><a class="header" href="#搜索查找"><strong>搜索查找</strong></a></h3>
<ul>
<li><code>find</code> 查找
<ul>
<li><code>find -name</code> 使用文件名查找</li>
<li><code>find -user</code> 使用用户名查找</li>
<li><code>find -size</code> 使用文件大小查找</li>
<li><code>find -size +10m</code> 表示要查找的文件大小大于10兆使用 <code>-</code>表示要查找的文件大小必须小于10m</li>
</ul>
</li>
<li><code>locate</code> 定位</li>
<li>使用前必须使用<code>updatedb</code>对当前文件系统创建一个文件索引</li>
<li>查找速度快</li>
<li><code>which 指令</code> 查找那个指令在那个目录</li>
<li><code>grep</code> 过滤和 <code>|</code>（管道命令）结合使用，参数可以使用正则表达式
<ul>
<li><code>grep -n</code>  过滤的结果显示行号</li>
<li><code>grep -i</code> 过滤的关键词忽略大小写</li>
</ul>
</li>
</ul>
<h3 id="压缩和解压"><a class="header" href="#压缩和解压"><strong>压缩和解压</strong></a></h3>
<ul>
<li>
<p><code>gzip 文件名 文件名.gz</code> 压缩</p>
<ul>
<li>压缩后格式是<code>文件名.gz</code></li>
<li><code>gzip</code> 只能压缩或解压文件，不能对目录进行压缩</li>
</ul>
</li>
<li>
<p><code>gunzip 文件名.gz 文件名</code> 解压</p>
</li>
<li>
<p><code>zip/unzip</code>压缩和解压</p>
<ul>
<li>压缩后格式为<code>文件名.zip</code></li>
<li><code>zip -r</code>递归对目录进行压缩</li>
<li><code>unzip -d</code>对目录进行解压</li>
</ul>
</li>
<li>
<p><code>tar</code>压缩和解压</p>
<ul>
<li>压缩后格式为<code>文件名.tar.gz</code></li>
<li>选项
<ul>
<li><code>-c</code>产生<code>.tar</code>打包文件</li>
<li><code>-v</code>显示详细信息</li>
<li><code>-f</code>指定压缩后的文件名</li>
<li><code>-z</code>打包同时压缩</li>
<li><code>-x</code>解包<code>.tar</code>文件</li>
</ul>
</li>
<li>常用方式
<ul>
<li><code>tar -zcvf 目标文件目录/文件名.tar.gz 要压缩的文件或目录……</code>压缩</li>
<li><code>tar -zxvf 压缩后的文件 -C 需要解压的目标目录</code> 解压</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="组管理和权限管理"><a class="header" href="#组管理和权限管理">组管理和权限管理</a></h2>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。
<ol>
<li>所有者</li>
<li>所在组</li>
<li>其他组</li>
<li>改变用户所在组</li>
</ol>
</li>
</ul>
</li>
<li>
<p>文件目录所有者</p>
<ul>
<li>一般为文件的创建者，创建了该文件</li>
<li>查看文件所有者
<ul>
<li><code>ls -ahl</code>或 <code>ll -ah</code></li>
</ul>
</li>
<li>修改文件所有者
<ul>
<li><code>chown 用户名 文件名</code></li>
<li><code>chown 用户名:组名 文件名</code>这条指令可以连组名一起修改</li>
</ul>
</li>
<li>修改所在组
<ul>
<li><code>chgrp 组名 文件名</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>权限</p>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301150854.png" alt="" /></p>
<ul>
<li>
<p>0-9位说明</p>
<ol>
<li>
<p>第0位确定文件类型(d, -,l,c,b)</p>
<ul>
<li>
<p>I是链接,相当于windows的快捷方式</p>
</li>
<li>
<p>d是目录，相当于windows的文件夹</p>
</li>
<li>
<p>c是字符设备文件，鼠标，键盘</p>
</li>
<li>
<p>b是块设备，比如硬盘</p>
</li>
</ul>
</li>
<li>
<p>第1-3位确定所有者（该文件的所有者）拥有该文件的权限。---User</p>
</li>
<li>
<p>第4-6位确定所属组(同用户组的）拥有该文件的权限，---Group</p>
</li>
<li>
<p>第7-9位确定其他用户拥有该文件的权限---Other</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>rwx权限</strong></p>
<ul>
<li>rwx作用到文件
<ul>
<li>[r]代表可读(read):可以读取,查看</li>
<li>[ w ]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</li>
<li>[x]代表可执行(execute):可以被执行</li>
</ul>
</li>
<li>rwx作用到目录
<ul>
<li>[r]代表可读(read):可以读取，ls查看目录内容</li>
<li>[w]代表可写(write):可以修改，对目录内创建+删除+重命名目录</li>
<li>[×]代表可执行(execute):可以进入该目录</li>
</ul>
</li>
</ul>
</li>
<li>
<p>改变文件rwx权限</p>
<ul>
<li><code>chmod</code>
<ul>
<li>u、g、o，分别代表所有者，组，和其他</li>
<li>a代表所有</li>
<li>使用+、-对该文件的权限进行添加或删除</li>
<li>具体使用方式
<ul>
<li><code>chmod u+x,g+w,o-r 文件名</code></li>
<li><code>chmod a-r 文件名</code>表示该文件，所有者、组内成员和其他人都没有了读的权限</li>
</ul>
</li>
</ul>
</li>
<li>也可以使用数字方式对文件的权限进行修改
<ul>
<li>r=4，w=2，x=1，使用这三数组进行相加</li>
<li>具体使用方式
<ul>
<li><code>chmod 664 文件名</code></li>
<li>这里6或4都是上面三个数字相加得到的</li>
<li>第一位该表所有者，第二位代表组，第三位代表其他</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定时任务"><a class="header" href="#定时任务">定时任务</a></h2>
<ul>
<li>
<p><strong>crond任务调度</strong></p>
<ul>
<li>
<p>任务调度:是指系统在某个时间执行的特定的命令或程序。</p>
</li>
<li>
<p>任务调度分类:1.系统工作:有些重要的工作必须周而复始地执行。如病毒扫描等个别用户工作:个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p>
</li>
<li>
<p><code>crontab</code></p>
<ul>
<li><code>crontab -e</code> 编辑定时任务</li>
<li><code>crontab -l</code> 查看已有的任务</li>
<li><code>crontab -r</code> 删除已有的任务</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301154226.png" alt="" /></p>
</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301154250.png" alt="" /></p>
<ul>
<li>使用
<ul>
<li>使用<code>crontab -e</code>打开编辑器后</li>
<li>输入<code>*/1 * * * * 任务操作</code>
<ul>
<li>表示每分钟执行</li>
<li>任务操作那位置可以填写一个 <code>.sh</code>脚本路径</li>
</ul>
</li>
<li>编辑后退出就可以了</li>
</ul>
</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301154608.png" alt="" /></p>
</li>
<li>
<p><strong>at定时任务</strong></p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>
<li>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当肓时间匹配，则运行此作业。</li>
<li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li>
<li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看
<ul>
<li>使用<code>ps -ef | grep atd</code>查看atd是否运行</li>
</ul>
</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301155156.png" alt="" /></p>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301155230.png" alt="" /></p>
</li>
<li>
<p>使用</p>
<ul>
<li><code>at now+1minutes</code>回车</li>
<li>输入要执行的命令或脚本文件路径</li>
<li>按两次<code>ctrl+d</code>保存</li>
<li>表示一分钟后执行某个操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="磁盘分区挂载"><a class="header" href="#磁盘分区挂载">磁盘分区、挂载</a></h2>
<ul>
<li>
<p><strong>Linux分区</strong></p>
<ul>
<li>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</li>
<li>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得、</li>
</ul>
</li>
<li>
<p>硬盘说明</p>
<ul>
<li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li>
<li>对于IDE硬盘，驱动器标识符为“hdx~”，其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号(a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘)，”~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</li>
<li>对于SCSI硬盘则标识为“sdx~&quot;，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</li>
</ul>
</li>
<li>
<p>挂载一块新硬盘</p>
<ul>
<li>查看分区详细信息：<code>lsblk -f</code></li>
</ul>
<ol>
<li>
<p>添加一块新硬盘</p>
</li>
<li>
<p>创建分区</p>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210226095153.png" alt="" /></p>
</li>
<li>
<p>格式化分区并指定该分区的文件类型：<code>mkfs -t ext4 /dev/sdb2</code></p>
</li>
<li>
<p>将该分区挂载到对应目录下：<code>mount /dev/sdb1 目录名</code></p>
<ol>
<li>卸载命令：<code>umount /dev/sdb1</code></li>
<li>用命令行挂载的方式重启后后会失效</li>
</ol>
</li>
<li>
<p>开机自动挂载方式</p>
<ol>
<li>
<p>编辑挂载对应关系表：<code>vim /etc/fstab</code></p>
</li>
<li>
<p>添加需要的挂载关系</p>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210226103607.png" alt="" /></p>
</li>
<li>
<p>保存退出重启后分区会自动挂载到对应的文件下</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>查看分区使用情况：<code>df -h</code></p>
</li>
<li>
<p>查看某个具体文件占用内存的情况</p>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210226104742.png" alt="" /></p>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210226104913.png" alt="" /></p>
</li>
<li>
<p>统计个数命令：<code>wc -l</code></p>
</li>
<li>
<p>磁盘情况查询</p>
<ul>
<li><code>df -h</code></li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301160728.png" alt="" /></p>
</li>
<li>
<p>使用<code>tree</code>命令查看文件目录状态</p>
<ul>
<li>下载tree，<code>yum install tree</code></li>
<li><code>tree 目录</code> 查看</li>
</ul>
</li>
</ul>
<h2 id="网络配置"><a class="header" href="#网络配置">网络配置</a></h2>
<ul>
<li>
<p><strong>linux网络环境配置</strong></p>
</li>
<li>
<p>第一种方法(自动获取):</p>
<ul>
<li>登陆后，通过界面的来设置自动获取ip，特点 :linux启动后会自动获取IP缺点是每次自动获取的ip地址可能不一样。</li>
</ul>
</li>
<li>
<p>第二种方式(指定ip)</p>
<ul>
<li>直接修改配置文件来指定IP,并可以连接到外网,编辑<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></li>
<li>进行如下编辑</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301162459.png" alt="" /></p>
<ul>
<li>保存退出后重启网络服务<code>service network restart</code>或重启<code>reboot</code>即可</li>
<li>如果使用虚拟机则还需要更改虚拟机的地址</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301162955.png" alt="" /></p>
</li>
<li>
<p>设置主机名和host映射</p>
<ul>
<li>设置主机名
<ul>
<li><code>hostname</code> 查看主机名</li>
<li>在/etc/hostname文件内修改主机名</li>
<li>修改后重启才生效</li>
</ul>
</li>
<li>hosts映射
<ul>
<li>编辑/etc/hosts文件</li>
<li><code>vim /etc/host</code></li>
<li>添加对应的关系<code>ip 对应的名字</code></li>
<li>window下在C:\Windows\System32\drivers\etc目录下编辑hosts文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>主机名解析过程分析(Hosts、DNS)</p>
<ul>
<li>Hosts是什么
<ul>
<li>一个文本文件,用来记录IP和Hostname(主机名)的映射关系</li>
</ul>
</li>
<li>DNS
<ol>
<li>DNS，就是Domain Name System的缩写，翻译过来就是域名系统</li>
<li>是互联网上作为域名和IP地址相互映射的一个分布式数据库</li>
</ol>
</li>
</ul>
</li>
<li>
<p>主机名解析机制分析(Hosts、DNS)</p>
<ul>
<li>应用实例:用户在浏览器输入了www.baidu.com
<ol>
<li>浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析;如果没有检查操作系统DNS解析器缓存，如果有直接返回IP完成解析。这两个缓存，可以理解为本地解析器缓存</li>
<li>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址（DNS解析记录)
<ul>
<li>如在cmd窗口中输入
<ul>
<li><code>ipconfig /displaydns</code>  DNS域名解析缓存</li>
<li><code>ipconfig /flushdns</code>  手动清理dns缓存</li>
</ul>
</li>
</ul>
</li>
<li>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回.</li>
<li>如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS进行解析域</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h2>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>在LINUX中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号(pid,进程号)。</li>
<li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li>
<li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</li>
</ul>
</li>
<li>
<p>显示系统执行的进程</p>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210301172751-1614591095276.png" alt="" /></p>
</li>
<li>
<p>ps详解</p>
<ul>
<li>指令:ps -auxlgrep xxx ，比如我看看有没有sshd服务</li>
<li>指令说明
<ul>
<li>System V展示风格</li>
<li>USER:用户名称</li>
<li>PID:进程号</li>
<li><strong>%CPU:进程占用CPU的百分比</strong></li>
<li><strong>%MEM:进程占用物理内存的百分比</strong></li>
<li><strong>VSZ:进程占用的虚拟内存大小(单位:KB)</strong></li>
<li><strong>RSS:进程占用的物理内存大小(单位:KB )</strong></li>
<li>TTY:终端名称,缩写．</li>
<li>STAT:进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li>
<li>STARTED:进程的启动时间</li>
<li>TIME : CPU时间，即进程使用CPU的总时间</li>
<li>COMMAND:启动进程所用的命令和参数，如果过长会被截断显示</li>
</ul>
</li>
<li>以全格式显示当前进程</li>
</ul>
</li>
<li>
<p><img src="linux/../assets/linux/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210302091332.png" alt="" /></p>
</li>
<li>
<p>终止进程</p>
<ul>
<li><code>kill</code>
<ul>
<li><code>kill 进程id</code> 杀死对应id的进程 </li>
<li><code>kill -9 进程id</code> 强制杀死一个进程</li>
</ul>
</li>
<li><code>killall</code>
<ul>
<li><code>kill 进程名</code> 杀死对应进程名的进程</li>
</ul>
</li>
</ul>
</li>
<li>
<p>以树状形式显示进程信息</p>
<ul>
<li><code>pstree</code>
<ul>
<li><code>pstree -p</code> 以树状形式显示进程信息并显示进程id</li>
<li><code>pstree -u</code> 以树状形式显示进程信息并显示进程登录的用户</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>服务管理</strong></p>
</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210302095630.png" alt="" /></p>
<ul>
<li>使用<code>setup</code>指令查看全部服务，管理开机自启的服务</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210302100003.png" alt="" /></p>
<ul>
<li>
<p><code>chkconfig</code>指令</p>
<ul>
<li><code>chkconfig 服务名 --list</code> 查看服务</li>
<li><code>chkconfig --level 系统级别 服务名 on/off </code>设置某个服务在那个系统级别自启动</li>
</ul>
</li>
<li>
<p><code>systemctl</code>指令</p>
<ul>
<li><code>systemctl [start|stop|restart|status] 服务名</code></li>
<li><code>systemctl list-unit-files</code> 查看开机启动的状态</li>
<li><code>systemctl ebable 服务名</code> 设置服务开机启动</li>
<li><code>systemctl disable 服务名</code> 关闭服务开机启动</li>
<li><code>systemctl is-enabled</code> 查看某个服务是否开机自启 </li>
</ul>
</li>
<li>
<p><code>firewall</code>指令</p>
<ul>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code> 打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code> 关闭端口</li>
<li><code>firewall-cmd --reload</code> 重载端口，打开和关闭端口后必须重载才能生效</li>
<li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口号是否打开</li>
</ul>
</li>
<li>
<p><code>top</code>命令</p>
<ul>
<li><code>top -d 秒数</code> 每隔多少秒更新一次</li>
<li><code>top -i</code> 不显示闲置和僵死进程</li>
<li><code>top -p 进程id</code> 通过id监控某个指定的进程</li>
</ul>
</li>
<li>
<p><strong>动态监控进程</strong></p>
</li>
<li>
<p>输入<code>top</code>指令后可以输入以下命令进行交互</p>
<ul>
<li><code>P</code> 以CPU使用率排序（默认）</li>
<li><code>M</code> 以内存使用率排序</li>
<li><code>N</code> 以进程id排序</li>
<li><code>q</code> 退出</li>
</ul>
</li>
<li>
<p>查看网络情况</p>
<ul>
<li><code>netstat -an</code> 按顺序排序输出</li>
<li><code>netstat -p</code> 显示那个进程在调用</li>
<li>常用使用直接输入<code>netstat -anp</code> </li>
</ul>
</li>
</ul>
<h2 id="rpm和yum"><a class="header" href="#rpm和yum">RPM和YUM</a></h2>
<ul>
<li><strong>rpm包管理</strong>
<ul>
<li>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager (RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</li>
<li>Linux的分发版本都有采用(suse,redhat, centos等等），可以算是公认的行业标准了。</li>
</ul>
</li>
<li><code>rpm</code>相关指令
<ul>
<li><code>rpm -qa</code> 查询安装的所有软件包</li>
<li><code>rpm - q 软件名</code> 查询该软件是否安装
<ul>
<li><code>rpm -qi 软件名</code> 查询该软件的详细信息</li>
</ul>
</li>
<li><code>rpm -ql 软件名</code> 查询该软件包包含哪些文件</li>
<li><code>rpm -qf 文件全路径</code> 查询该文件输入那个软件</li>
<li><code>rpm -e 软件包名</code> 卸载相指令</li>
<li><code>rpm -ivh 软件包全明</code> 安装软件包
<ul>
<li><code>-i</code> 安装</li>
<li><code>-v</code> 提示</li>
<li><code>-h</code> 进度条</li>
</ul>
</li>
</ul>
</li>
<li><code>yum</code>包管理
<ul>
<li>Yum是一Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</li>
<li>配置源
<ol>
<li><code>cd /etc/yum.repos.d/</code> 切到/etc/yum.	.d目录</li>
<li><code>mv CentOS-Base.repo CentOS-Base.repo.backup</code> 备份CentOS-Base.repo文件</li>
<li><code>wget http://mirrors.aliyun.com/repo/Centos-7.repo</code> 使用<code>wget</code>下载阿里的源文件
<ol>
<li>使用<code>wget</code>如果报无法解析主机名则需要手动配置DNS</li>
<li><code>vim /etc/resolv.conf</code> 编辑/etc/resolv.conf文件
<ol>
<li><code>service resatrt network</code>重启网络服务后<code>wget</code>就可以使用了</li>
<li>如果重启网络后/etc/resolv.conf内的数据恢复原样，就看文件头是否有Generated by NetworkManager注释字样</li>
<li>有则需要关闭NetworkManager服务，因为DNS被NetworkManager服务自动生成了</li>
<li><code>systemctl stop NetworkManager</code> 关闭NetworkManager服务</li>
<li><code>systemctl disable NetworkManager</code> 关闭NetworkManager服务的开机自启</li>
</ol>
</li>
</ol>
</li>
<li><code>mv Centos-7.repo CentOS-Base.repo</code>将下载好的Centos-7.repo文件重命名为CentOS-Base.repo`</li>
<li><code>yum clean all</code> 清理缓存</li>
<li><code>yum makecache</code> 生成缓存</li>
<li>等待</li>
</ol>
</li>
<li><code>yum listlgrep 软件列表</code> 查询yum服务器是否有需要安装的软件</li>
<li><code>yum install 软件包名</code> 安装指定软件</li>
</ul>
</li>
</ul>
<h2 id="安装jdk"><a class="header" href="#安装jdk">安装jdk</a></h2>
<ol>
<li>
<p>在/opt目录下创建jdk目录存放jdk压缩文件<code>mkdir /opt/jdk</code></p>
</li>
<li>
<p>在/usr/local目录下创建java目录存放解压后的文件<code>mkdir /usr/local/java</code></p>
</li>
<li>
<p>将/opt/jdk目录下的压缩文件解压到/usr/local/java目录下<code>tar -zxvf 压缩包名 -C /usr/local/java</code></p>
</li>
<li>
<p>配置环境变量<code>vim /etc/profile</code></p>
</li>
<li>
<p>添加如下代码</p>
<pre><code class="language-bash">export JAVA_HOME=/usr/local/java/jdk1.8.0_281
export PATH=$JAVA_HOME/bin:$PATH
</code></pre>
</li>
</ol>
<h2 id="shell编程"><a class="header" href="#shell编程">Shell编程</a></h2>
<ul>
<li>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
<ul>
<li>创建一个以.sh结尾的文件，编写相应的bash脚本并保存
<ul>
<li>修改所有者拥有执行权限使用<code>./文件名</code>执行文件</li>
<li>或者不用修改权限直接使用<code>sh 文件名</code> 执行文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="shell变量"><a class="header" href="#shell变量">Shell变量</a></h3>
<p><code>$HOME</code>、<code>$PATH</code>、<code>$PWD</code>等为系统变量</p>
<h4 id="位置参数变量"><a class="header" href="#位置参数变量">位置参数变量</a></h4>
<ul>
<li>获取执行shell脚本时后面带的参数</li>
<li>例如<code>var.sh 100</code>后面的100就是参数
<ul>
<li>文件内使用<code>$1~$9</code>获取文件后的1~9位参数而<code>$0</code>为文件名本身</li>
<li>第十个参数往后使用大括号包裹数组<code>${11}</code>来获取</li>
<li>使用<code>$*</code>是将参数看作一个整体获取，相当于获取到一个所有参数组成的字符串</li>
<li>使用<code>$@</code>获取到所有参数组成的集合</li>
<li>使用<code>$#</code>获取所有参数的个数</li>
</ul>
</li>
</ul>
<h4 id="预定义变量"><a class="header" href="#预定义变量">预定义变量</a></h4>
<ul>
<li>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用
<ul>
<li><code>$$</code> 当前进程的进程号(PID ) </li>
<li><code>$!</code> 后台运行的最后一个进程的进程号（PID ) </li>
<li><code>$?</code>（最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值为非0(具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了</li>
</ul>
</li>
</ul>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<ul>
<li>使用<code>$((运算式))</code>或者<code>$[运算式]</code></li>
<li>或者<code>expr 运算式</code>这里的运算式必须有空格</li>
</ul>
<h4 id="条件判断"><a class="header" href="#条件判断">条件判断</a></h4>
<blockquote>
<p><strong>if</strong></p>
</blockquote>
<ul>
<li>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">if [ 条件 ]
then
	分支一
elif [ 条件 ]
then
	分支二
else
	分支三
fi
</code></pre>
<ul>
<li>数值比较
<ul>
<li><code>-lt</code> 小于、<code>-le</code> 小于等于、<code>-eq</code> 等于、<code>-gt</code> 大于、<code>-ge</code> 大于等于、<code>-ne</code> 不等于</li>
</ul>
</li>
<li>文件权限判断
<ul>
<li><code>-r</code> 是否有读的权限</li>
<li><code>-w</code> 是否有写的权限</li>
<li><code>-x</code> 是否有执行的权限</li>
</ul>
</li>
<li>文件类型判断
<ul>
<li><code>-f</code> 文件是否存在并且是一个常规的文件</li>
<li><code>-e</code> 文件是否存在</li>
<li><code>-d</code> 文件是否存在并且是一个目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>case</strong></p>
</blockquote>
<ul>
<li>
<p>语法</p>
<pre><code class="language-bash">case 值 in
&quot;匹配值1&quot;)
echo one
;;
&quot;匹配值2&quot;)
echo two
;;
*)
echo other
;;
esac
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>for循环</strong></p>
</blockquote>
<ul>
<li>
<p>语法</p>
<pre><code class="language-bash">for 变量 in 值
do
	循环体        
done
</code></pre>
<pre><code class="language-bash">for(( i=1; i&lt;=100; i++ ))
do
        循环体
done

</code></pre>
</li>
</ul>
<blockquote>
<p><strong>while循环</strong></p>
</blockquote>
<ul>
<li>
<p>语法</p>
<pre><code class="language-bash">while [ 条件 ]
do
	循环体
done
</code></pre>
</li>
</ul>
<h4 id="read读取控制台输入"><a class="header" href="#read读取控制台输入">read读取控制台输入</a></h4>
<ul>
<li>
<p><code>read 选项 参数</code></p>
</li>
<li>
<p><code>-p</code> 指定读取值时的提示符;</p>
</li>
<li>
<p><code>-t</code> 指定读取值时等待的时间(秒），如果没有在指定的时间内输入，就不再等待了。.参数</p>
</li>
</ul>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<ul>
<li>
<p>系统函数</p>
<ul>
<li><code>basename 路径</code> 获取路径里的文件名</li>
<li><code>basename 路径 后缀</code> 获取路径里的文件名并去掉文件名的后缀</li>
<li><code>basedir 路径</code> 获取过文件的路径</li>
</ul>
</li>
<li>
<p>自定义函数</p>
<pre><code class="language-bash"># 定义函数
function 函数名(){
	函数体
}

# 调用函数

函数名 参数……
</code></pre>
</li>
</ul>
<h2 id="日志管理"><a class="header" href="#日志管理">日志管理</a></h2>
<ul>
<li>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。</li>
<li>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因或者受到攻击时攻击者留下的痕迹。</li>
<li>系统常用的日志</li>
</ul>
<p><img src="linux/../assets/linux/img/QQ%E6%88%AA%E5%9B%BE20210315151313.png" alt="" /></p>
<ul>
<li><code>rsyslogd</code>服务管理这常用的系统日志</li>
<li><code>/etc/rsyslog.conf</code>文件为<code>rsyslog</code>日志进程的配置文件</li>
<li><strong>查看内存日志</strong>
<ul>
<li><code>journalctl</code> 可以查看内存日志,这里我们看看常用的指令journalctl##查看全部</li>
<li><code>journalctl -n3</code> ##查看最新3条</li>
<li><code>journalctl --since 19:00 --until 19:10:10</code> #查看起始时间到结束时间的日志可加日期journalctl -p err ##报错日志</li>
<li><code>journalctl -o verbose</code> ##日志详细内容</li>
<li><code>journalctl_PiD=1245_COMM=sshd</code> ##查看包含这些参数的日志（在详细日志查看)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux桌面环境"><a class="header" href="#linux桌面环境">Linux桌面环境</a></h1>
<blockquote>
<p>以debian为例</p>
</blockquote>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<ul>
<li>
<p>制作一个微pe的u盘</p>
</li>
<li>
<p>设置电脑硬盘启动顺序为u盘启动</p>
<ul>
<li>以我的电脑为例dell笔记本，开机出现图标不停按F12，后续操作百度</li>
</ul>
</li>
<li>
<p>进入后格式化所有电脑硬盘</p>
</li>
<li>
<p>使用debian制作启动盘</p>
</li>
<li>
<p>由于安装时可能会提示缺少固件，需要下载nofree的固件先放在u盘内的firmware文件夹内，没有就新建一个，固件官网：https://packages.debian.org/search?keywords=stable</p>
</li>
<li>
<p>安装过程参考https://www.cnblogs.com/Cylon/archive/2022/08/02/16544912.html</p>
</li>
<li>
<p>固件官网：<code>https://packages.debian.org/stable</code></p>
</li>
<li>
<p>固件git网站：<code>https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git</code></p>
</li>
<li>
<p>卸载桌面环境apt autoremove  --purge kde*</p>
</li>
</ul>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<h2 id="连接wifi"><a class="header" href="#连接wifi">连接wifi</a></h2>
<ul>
<li>查看网卡信息：<code>ifconfig -a</code></li>
<li>启动网卡： <code>ifconfig wlan0 up</code></li>
<li>生成wifi信息文件： <code>wpa_passphrase {SSID} {PASSWORD} &gt; /etc/wpa_supplicant/{SSID}.conf</code></li>
<li>连接wifi： <code>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/{SSID}.conf -B</code></li>
<li>启动动态分配ip服务：<code>dhclient wlan0</code></li>
</ul>
<h2 id="磁盘"><a class="header" href="#磁盘">磁盘</a></h2>
<ul>
<li>
<p>查看磁盘大小 <code>df -h</code> ，<code>fdisk -l</code></p>
</li>
<li>
<h6 id="查看sata速度和具体设备dmesg-grep-sata"><a class="header" href="#查看sata速度和具体设备dmesg-grep-sata">查看SATA速度和具体设备<code>dmesg |grep SATA</code></a></h6>
</li>
</ul>
<h2 id="字体"><a class="header" href="#字体">字体</a></h2>
<ul>
<li>设置字体大小 <code>dpkg-reconfigure console-setup</code></li>
<li>设置字体<code>dpkg-reconfigure locales</code></li>
<li>没有<code>ifconfig</code>命令时用<code>ip addr show</code>查看ip</li>
</ul>
<h2 id="内核"><a class="header" href="#内核">内核</a></h2>
<ul>
<li>
<p>切换linux内核</p>
<ul>
<li>查看当前使用的内核和需要切换的内核<code>grep menuentry /boot/grub/grub.cfg</code></li>
<li>复制menuentry后面需要切换的内核的字符串信息</li>
<li>开始引导配置 <code>nvim /etc/default/grub</code></li>
<li>修改<code>GRUB_DEFAULT=0</code>为GRUB_DEFAULT=&quot;Advanced options for Debian GNU/Linux&gt;上一步复制的字符串&quot;后保存退出</li>
<li>执行更新引导配置命令<code>update-grub</code></li>
<li>重启后使用<code>uname -a</code>查看是否修改成功</li>
</ul>
</li>
<li>
<p>删除多余的内核文件</p>
<ul>
<li>查看当前系统内安装的内核文件<code>ls /lib/modules</code></li>
<li><code>apt autoremove --purge linux-image-内核名字</code>删除内核</li>
</ul>
</li>
<li>
<p>删除旧的内核</p>
<ul>
<li>使用<code>uname -a</code>查看正在使用的内核、</li>
<li>使用<code> dpkg --get-selections |grep linux</code>查看内核列表</li>
<li>找到多余的内核后使用<code>dpkg --purge --force-remove-essential linux-image-版本号</code>删除</li>
</ul>
</li>
</ul>
<h2 id="用户"><a class="header" href="#用户">用户</a></h2>
<ul>
<li><code>useradd 用户名</code> 创建用户</li>
<li><code>passwd 用户名</code> 设置用户名的密码</li>
<li><code>chmod -d 用户家目录 用户名</code> 设置用户的家目录</li>
<li><code>cp /etc/skel/.b* 用户家目录</code>、 <code>cp /etc/skel/.p* 用户家目录</code> 复制所需的命令行配置文件到用户的家目录下</li>
<li><code>chown -R 用户名:用户名 用户家目录</code> 设置用户家目录所以文件的拥有者</li>
<li><code>chmod 770 用户家目录</code> 设置用户家目录的权限</li>
<li><code>usermod -s /bin/bash 用户名</code> 配置相关操作 </li>
</ul>
<h2 id="sudo"><a class="header" href="#sudo">sudo</a></h2>
<ul>
<li><code>apt install sudo</code> 安装</li>
<li>让普通用户可以使用sudo 命令
<ul>
<li>在<code>/etc/sudoers.d</code>目录下新建<code>用户名</code>文件</li>
<li>编写<code>用户名 ALL=(ALL) ALL</code>保存退出，这个表示用户可以执行所有命令</li>
</ul>
</li>
</ul>
<h2 id="ssh"><a class="header" href="#ssh">ssh</a></h2>
<h3 id="ssh密钥登录"><a class="header" href="#ssh密钥登录">ssh密钥登录</a></h3>
<blockquote>
<p>假如<code>a</code>需要连接到<code>b</code></p>
</blockquote>
<pre><code class="language-bash"># 在`a`的终端下输入命令生成密钥，保存在当前用户目录下的.ssh文件夹内
ssh-keygen # 正常环境下有提示回车即可（生产环境下需要看一下提示）

# 将`a`机器下的~/.ssh/id_rsa.pub文件推送到服务器`b`上
scp ~/.ssh/id_rsa.pub 用户名@`b`的ip:需要登录的用户目录/.ssh/authorized_keys

# 使用ssh连接
ssh `b`
</code></pre>
<ul>
<li>清理密钥 <code>ssh-keygen -R ip</code></li>
</ul>
<h2 id="apt"><a class="header" href="#apt">apt</a></h2>
<ul>
<li>debian11源</li>
</ul>
<pre><code class="language-bash">## tencentyun
deb http://mirrors.tencentyun.com/debian bullseye main contrib non-free
deb http://mirrors.tencentyun.com/debian bullseye-updates main contrib non-free
deb http://mirrors.tencentyun.com/debian bullseye-backports main contrib non-free
deb http://mirrors.tencentyun.com/debian bullseye-proposed-updates main contrib non-free

## 163
deb http://mirrors.163.com/debian/ bullseye main non-free contrib
deb https://mirrors.163.com/debian-security/ bullseye-security main
deb http://mirrors.163.com/debian/ bullseye-updates main non-free contrib
deb http://mirrors.163.com/debian/ bullseye-backports main non-free contrib

## huawei
deb https://mirrors.huaweicloud.com/debian/ bullseye main non-free contrib
deb https://mirrors.huaweicloud.com/debian-security/ bullseye-security main
deb https://mirrors.huaweicloud.com/debian/ bullseye-updates main non-free contrib
deb https://mirrors.huaweicloud.com/debian/ bullseye-backports main non-free contrib

## tsinghua.edu
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free

## ustc.edu
deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free
deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free
deb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free
deb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free
</code></pre>
<ul>
<li>ppa源
<ul>
<li>软件安装<code>apt install software-properties-common</code></li>
<li>添加ppa源<code>add-apt-repository &quot;url&quot;</code></li>
<li>删除ppa源<code>add-apt-repository -r &quot;url&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<h3 id="windows远程dwm桌面环境"><a class="header" href="#windows远程dwm桌面环境">windows远程dwm桌面环境</a></h3>
<p>在用户目录下新建.xsession文件，里面添加以下命令</p>
<pre><code class="language-shell">exec dwm
</code></pre>
<p>安装xrdp：<code>apt install xrdp</code></p>
<p>启动：<code>sudo /etc/init.d/xrdp start</code></p>
<h3 id="笔记本电源管理相关"><a class="header" href="#笔记本电源管理相关">笔记本电源管理相关</a></h3>
<ul>
<li>笔记本合盖休眠配置文件：/etc/systemd/logind.conf</li>
<li>linux 引导页面配置文件：/etc/default/grub</li>
<li>将GRUB_TIMEOUT设置为0则可以跳过引导页面</li>
</ul>
<h3 id="输入法"><a class="header" href="#输入法">输入法</a></h3>
<ul>
<li>fcitx5：<code>sudo apt install fcitx5 fcitx5-frontend-qt5 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 fcitx5-chinese-addons</code></li>
</ul>
<h3 id="linux设置键盘速率"><a class="header" href="#linux设置键盘速率">linux设置键盘速率</a></h3>
<p><code>xset r rate 250 60</code></p>
<p>250毫秒后开始重复，每60毫秒重复一次</p>
<h2 id="dwm"><a class="header" href="#dwm">DWM</a></h2>
<ul>
<li>基础桌面环境：<code>apt install libx11-dev libxft-dev libxinerama-dev xorg</code></li>
<li>系统托盘：<code>apt install trayer</code></li>
<li>壁纸软件：<code>apt install feh</code></li>
<li>复制配置文件<code>cp /etc/X11/xinit/xinitrc ~/.xinitrc</code></li>
<li>基础命令：
<ul>
<li>killall：<code>psmisc</code></li>
</ul>
</li>
<li>使用git clone dwm源码官网https://tools.suckless.org/</li>
<li>进入dwm目录<code>make clean instal</code>编译安装dwm
<ul>
<li>安装编译依赖<code>sudo apt install make gcc</code></li>
<li>编译xinitrc文件 <code>nvim ~/.xinitrc</code></li>
<li>文件最后加上<code>exec dwm</code></li>
</ul>
</li>
<li>文件上面有些目录可能需要注释才能启动</li>
<li>安装输入法<code>apt install fcitx fcitx-pinyin</code></li>
<li>用dmenu打开<code>fcitx-config-gtk3</code>应用，配置双拼</li>
<li>安装nerd fonts图标字体
<ul>
<li>nerd fonts 字体下载页面：https://www.nerdfonts.com/font-downloads</li>
<li>选择一个字体下载，我这里选择一个只有图标的字体</li>
<li>解压字体压缩包到系统字体目录下：<code>sudo unzip 压缩包名称 -d /usr/share/fonts/压缩包名称</code></li>
<li>进入到解压的字体目录下：<code>cd /usr/share/fonts/压缩包名称</code>
<ul>
<li>生成核心字体信息：<code>sudo mkfontscale</code></li>
<li>生成字体文件夹：<code>sudo mkfontdir</code></li>
<li>刷新系统字体缓存：<code>sudo fc-cache -fv</code></li>
</ul>
</li>
<li>打开dwm配置文件
<ul>
<li>查找字体名称：<code>fc-list | grep 安装的字体名称</code></li>
<li>复制出对应的字体名称，在grep出结果里面，一般在 <code>:style=xxx</code>前面，<code>xxx.ttf：</code>后面</li>
<li>找到<code>*fonts[]</code>常量，将上一步复制的字体名称粘贴在这里，后面加上<code>pixelsize=图标大小:type=上一步style后面的值:antialise=true:autohint=true</code>后面两个是抗锯齿之类的属性</li>
<li>保存退出后<code>sudo make clean install</code> 重新编译安装dwm</li>
<li>重启后就可以设置nerd fonts的字体了，字体网址：https://www.nerdfonts.com/cheat-sheet</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<h2 id="apt相关"><a class="header" href="#apt相关">apt相关</a></h2>
<p>apt install 或upgrade 时 installed initramfs-tools package post-installation script subprocess returned error exit status 1错误</p>
<ul>
<li><code>rm /var/lib/dpkg/info/报错的包名</code></li>
<li><code>dpkg --configure -D 777 报错的包名</code></li>
<li><code>apt -f install</code></li>
</ul>
<h3 id="ppa错误"><a class="header" href="#ppa错误">PPA错误</a></h3>
<h4 id="e-the-repository-httpppalaunchpadnetjonathonfvimubuntu-focal-release-no-longer-has-a-release-file"><a class="header" href="#e-the-repository-httpppalaunchpadnetjonathonfvimubuntu-focal-release-no-longer-has-a-release-file">E: The repository ‘http://ppa.launchpad.net/jonathonf/<a href="https://so.csdn.net/so/search?q=vim&amp;spm=1001.2101.3001.7020">vim</a>/ubuntu focal Release’ no longer has a Release file.</a></h4>
<ul>
<li>
<p>删除仓库，-r 后面的参数表示要删除的仓库，取值如下图所示，记得换成自己报错的仓库</p>
</li>
<li>
<p>sudo apt-add-repository -r ppa:jonathonf/vim	# 这里换成自己报错的仓库</p>
</li>
<li>
<p>更新仓库包列表</p>
</li>
<li>
<p>sudo apt update</p>
</li>
</ul>
<h3 id="更新错误"><a class="header" href="#更新错误">更新错误</a></h3>
<ul>
<li>
<p>错误：</p>
<p>dpkg: 处理软件包 initramfs-tools (--configure)时出错：
installed initramfs-tools package post-installation script subprocess returned error exit status 1
在处理时有错误发生：
initramfs-tools
E: Sub-process /usr/bin/dpkg returned an error code (1)</p>
</li>
<li>
<p>解决方法：</p>
<ul>
<li>现将info文件夹更名：<code>sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_old</code></li>
<li>再新建一个新的info文件夹：<code>sudo mkdir /var/lib/dpkg/info</code></li>
<li><code>sudo apt-get update</code></li>
<li><code>apt-get -f install</code> </li>
<li>执行完上一步操作后会在新的info文件夹下生成一些文件，现将这些文件全部移到info_old文件夹下：<code>sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old</code> </li>
<li>把自己新建的info文件夹删掉：<code>sudo rm -rf /var/lib/dpkg/info</code></li>
<li>把以前的info文件夹重新改回名字：<code>sudo mv /var/lib/dpkg/info_old /var/lib/dpkg/info</code></li>
</ul>
</li>
</ul>
<h2 id="nvidia显卡驱动相关"><a class="header" href="#nvidia显卡驱动相关">nvidia显卡驱动相关</a></h2>
<ul>
<li><code>sudo apt install build-essential libglvnd-dev</code></li>
<li>如果出现以下错误</li>
</ul>
<pre><code>Unable to find the kernel source tree for the currently running kernel.  Please make sure you have installed the kernel source files for
your kernel and that they are properly configured; on Red Hat Linux systems, for example, be sure you have the 'kernel-source' or
'kernel-devel' RPM installed.  If you know the correct kernel source files are installed, you may specify the kernel source path with
the '--kernel-source-path' command line option
</code></pre>
<pre><code>* 安装内核源码包：`sudo apt install linux-source`
* 安装内核头文件包：`sudo apt install linux-headers-$(uname -r)`
* 这些操作以debian为例
</code></pre>
<h2 id="网络工具相关"><a class="header" href="#网络工具相关">网络工具相关</a></h2>
<ul>
<li><code>sudo apt install net-tools</code></li>
</ul>
<h2 id="安装typora"><a class="header" href="#安装typora">安装typora</a></h2>
<ul>
<li><a href="https://typoraio.cn/#linux">linux官方安装教程</a></li>
<li>适合debian系linux</li>
<li><code>wget -qO - https://typoraio.cn/linux/public-key.asc | sudo tee /etc/apt/trusted.gpg.d/typora.asc</code></li>
<li><code>sudo add-apt-repository 'deb https://typoraio.cn/linux ./'</code></li>
<li><code>sudo apt-get update</code></li>
<li><code>sudo apt-get install typora</code></li>
</ul>
<h2 id="缺少ifconfig命令"><a class="header" href="#缺少ifconfig命令">缺少ifconfig命令</a></h2>
<ul>
<li><code>sudo apt install net-tools</code></li>
</ul>
<h2 id="禁用watchdog程序导致系统关机或重启时卡死"><a class="header" href="#禁用watchdog程序导致系统关机或重启时卡死">禁用watchdog程序，导致系统关机或重启时卡死</a></h2>
<ul>
<li>打开grub文件 <code>sudo nvim /etc/default/grub</code></li>
<li>添加或修改<code>GRUB_CMDLINE_LINUX=&quot;nmi_watchdog=0&quot;</code></li>
<li>更新grub配置 <code>sudo update-grub</code></li>
</ul>
<h2 id="ubuntu相关操作"><a class="header" href="#ubuntu相关操作">Ubuntu相关操作</a></h2>
<h3 id="linux-安装显卡驱动"><a class="header" href="#linux-安装显卡驱动">linux 安装显卡驱动</a></h3>
<ul>
<li>
<p>修改 blacklist.conf文件：<code>sudo vim /etc/modprobe.d/blacklist.conf</code>，在最后一行添加，添加后需要重启</p>
<pre><code class="language-shell">blacklist nouveau
</code></pre>
</li>
<li>
<p>执行命令安装必要的库：</p>
<ul>
<li><code>sudo apt update &amp;&amp; sudo apt install build-essential</code></li>
<li><code>sudo apt-get install libglvnd-dev</code></li>
</ul>
</li>
<li>
<p>从Nvidia官网下载驱动文件</p>
<ul>
<li>使用命令行进入下载的文件的目录</li>
</ul>
</li>
<li>
<p>安装命令：<code>sudo bash 文件名</code></p>
<ul>
<li>如果提示X server相关则加上 <code>-no-x-check</code>参数</li>
<li>卸载，加上<code>--uninstall</code> 参数</li>
</ul>
</li>
</ul>
<h3 id="ubuntu-合并状态栏和dock栏"><a class="header" href="#ubuntu-合并状态栏和dock栏">ubuntu 合并状态栏和dock栏</a></h3>
<ul>
<li>​	浏览器安装<code>gnome shell integration</code>插件</li>
<li>进入<a href="https://extensions.gnome.org/">gnome扩展网址</a>
<ul>
<li>搜索<code>dash to panel</code>插件 打开即可</li>
</ul>
</li>
</ul>
<h2 id="linux-音频相关"><a class="header" href="#linux-音频相关">linux 音频相关</a></h2>
<h3 id="alsa"><a class="header" href="#alsa">alsa</a></h3>
<ul>
<li>音频底层</li>
</ul>
<h3 id="pulseaudio"><a class="header" href="#pulseaudio">pulseaudio</a></h3>
<ul>
<li>音频服务</li>
</ul>
<h3 id="pipewire"><a class="header" href="#pipewire">pipewire</a></h3>
<ul>
<li>音频服务，可以替代pulseaudio</li>
</ul>
<h3 id="wireplumber"><a class="header" href="#wireplumber">wireplumber</a></h3>
<ul>
<li>pipewire 客户端</li>
</ul>
<h3 id="qpwgraph"><a class="header" href="#qpwgraph">qpwgraph</a></h3>
<ul>
<li>pipewire的图形界面客户端</li>
</ul>
<h3 id="bluez"><a class="header" href="#bluez">bluez</a></h3>
<ul>
<li>蓝牙协议底层</li>
</ul>
<h3 id="bluetooth"><a class="header" href="#bluetooth">bluetooth</a></h3>
<ul>
<li>蓝牙服务，自带bluetoothctl交互命令</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux安装ftp服务器"><a class="header" href="#linux安装ftp服务器">linux安装ftp服务器</a></h1>
<ul>
<li>
<p>已Debian11为例</p>
</li>
<li>
<p>使用root登录</p>
</li>
<li>
<p>添加ftp用户和对应的目录和组</p>
</li>
<li>
<p>添加组</p>
<ul>
<li><code>groupadd 组名</code></li>
</ul>
</li>
<li>
<p>创建用户目录，建议创建在/home目录下</p>
<ul>
<li><code>mkdir /home/目录名称</code></li>
</ul>
</li>
<li>
<p>创建用户</p>
<ul>
<li><code>useradd -dftp目录 -g组名 用户名</code></li>
</ul>
</li>
<li>
<p>设置用户密码</p>
<ul>
<li><code>passwd 用户名</code></li>
</ul>
</li>
<li>
<p>设置目录的所属用户</p>
<ul>
<li><code>chown 用户名:组名 ftp目录</code></li>
</ul>
</li>
<li>
<p>设置ftp目录的权限</p>
<ul>
<li><code>chmod 775 ftp目录</code></li>
</ul>
</li>
<li>
<p>apt 安装，（也可以使用其他工具）</p>
<ul>
<li><code>apt install vsftpd -y</code></li>
</ul>
</li>
<li>
<p>使用<a href="linux/vsftp/../../assets/linux/vsftpd.conf">vsftp.conf</a>文件作为ftp为配置文件</p>
</li>
<li>
<p>具体配置见配置文件</p>
</li>
<li>
<p>重启服务即可</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemd"><a class="header" href="#systemd">systemd</a></h1>
<blockquote>
<p>管理linux进程</p>
</blockquote>
<h2 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h2>
<h3 id="服务相关"><a class="header" href="#服务相关">服务相关</a></h3>
<ul>
<li>
<p><code>systemctl status 服务名</code> 查看服务运行状态</p>
<ul>
<li><code>start/stop/restart/reload</code> 服务启停相关</li>
</ul>
</li>
<li>
<p><code>systemctl show 服务名</code> 显示服务的参数</p>
</li>
<li>
<p><code>systemctl daemon-reload</code> 重新加载服务配置文件(在修改服务配置文件后执行)</p>
</li>
<li>
<p><code>systemctl list-unit-files</code> 查看所有服务</p>
</li>
<li>
<p><code>systemctl list-dependencies 服务名</code> 查看服务的依赖关系</p>
</li>
<li>
<p><code>systemctl cat 服务名</code> 查看服务名的配置文件</p>
</li>
<li>
<p><code>systemctl edit 服务名</code> 编辑服务名的配置文件</p>
</li>
</ul>
<h3 id="性能分析相关"><a class="header" href="#性能分析相关">性能分析相关</a></h3>
<blockquote>
<p>systemd-analyze</p>
</blockquote>
<ul>
<li>
<p><code>systemd-analyze</code> 查看启动耗时</p>
</li>
<li>
<p><code>systemd-analyze blame</code> 查看每个服务的启动耗时</p>
</li>
<li>
<p><code>systemd-analyze critical-chain 服务名</code> 查看服务的启动流程</p>
</li>
</ul>
<h3 id="系统管理相关"><a class="header" href="#系统管理相关">系统管理相关</a></h3>
<ul>
<li>
<p><code>systemctl reboot</code> 重启</p>
</li>
<li>
<p><code>systemctl poweroff</code> 关机</p>
</li>
<li>
<p><code>systemctl suspend</code> 休眠(数据保存到内存)</p>
</li>
<li>
<p><code>systemctl hibernate</code> 冬眠(数据保存到硬盘)</p>
</li>
</ul>
<h3 id="日志相关"><a class="header" href="#日志相关">日志相关</a></h3>
<blockquote>
<p>journalctl </p>
</blockquote>
<ul>
<li><code>journalctl -u 服务名称</code> 查看某个服务的日志</li>
</ul>
<h3 id="主机信息相关"><a class="header" href="#主机信息相关">主机信息相关</a></h3>
<blockquote>
<p>hostnamectl</p>
</blockquote>
<h3 id="本地化相关"><a class="header" href="#本地化相关">本地化相关</a></h3>
<blockquote>
<p>localectl</p>
</blockquote>
<h3 id="时区相关"><a class="header" href="#时区相关">时区相关</a></h3>
<blockquote>
<p>timedatectl</p>
</blockquote>
<h3 id="登录相关"><a class="header" href="#登录相关">登录相关</a></h3>
<blockquote>
<p>loginctl</p>
</blockquote>
<h4 id="登录管理器配置文件"><a class="header" href="#登录管理器配置文件">登录管理器配置文件</a></h4>
<ul>
<li>默认路径</li>
</ul>
<pre><code class="language-bash">/etc/systemd/logind.conf
/etc/systemd/logind.conf.d/*.conf
/run/systemd/logind.conf.d/*.conf
/usr/lib/systemd/logind.conf.d/*.conf
</code></pre>
<h2 id="常用配置项说明"><a class="header" href="#常用配置项说明">常用配置项说明</a></h2>
<blockquote>
<p>参考<a href="https://man.archlinux.org/man/logind.conf.5.en">archwiki</a></p>
</blockquote>
<ul>
<li>
<p><code>HandlePowerKey</code> 按下电源键操作</p>
</li>
<li>
<p><code>IdleAction</code> 电脑空闲时的操作</p>
</li>
<li>
<p><code>IdleActionSec</code> 电脑空闲多少时间后执行空闲操作</p>
</li>
<li>
<p><code>HandleLidSwitch</code> 笔记本合盖操作</p>
</li>
</ul>
<h3 id="unit配置保存路径"><a class="header" href="#unit配置保存路径">Unit配置保存路径</a></h3>
<ul>
<li>优先级从高到低</li>
</ul>
<ol>
<li><code>/etc/systemd/system</code> 系统级别配置文件</li>
<li><code>/run/systemd/system</code></li>
<li><code>/lib/systemd/system</code> 包管理工具下载的服务配置文件</li>
</ol>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="切换-systemctl-edit-命令的默认编辑器"><a class="header" href="#切换-systemctl-edit-命令的默认编辑器">切换 <code>systemctl edit</code> 命令的默认编辑器</a></h3>
<pre><code class="language-bash"># 添加编辑器
sudo update-alternatives --install &quot;$(which editor)&quot; editor &quot;$(which 编辑器名称)&quot; 15

# 配置
sudo update-alternatives --config editor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="批处理脚本常用命令"><a class="header" href="#批处理脚本常用命令">批处理脚本\常用命令</a></h1>
<ul>
<li>
<p>软连接</p>
<ul>
<li>参考<a href="https://www.icoa.cn/a/910.html">Win10 mklink 命令怎么用，mklink 命令使用教程</a></li>
<li>以管理员方式启动cmd</li>
<li><code>mklink 目标文件 原始文件</code></li>
</ul>
</li>
<li>
<p>多行命令换行输入加^</p>
<pre><code class="language-bash">echo 123^
456^
789^
# 输出
123456789
</code></pre>
</li>
<li>
<p>睡眠：<code>timeout 秒数	</code></p>
</li>
<li>
<p>修改当前编码为UTF-8：<code>chcp 65001</code></p>
</li>
</ul>
<h1 id="常用操作"><a class="header" href="#常用操作">常用操作</a></h1>
<h2 id="windwos安装gcc"><a class="header" href="#windwos安装gcc">windwos安装gcc</a></h2>
<ul>
<li>
<p>下载MinGW压缩包：<a href="https://github.com/niXman/mingw-builds-binaries/releases">github下载地址</a></p>
</li>
<li>
<p>根据不同电脑选择不同版本，我这里选择64位,</p>
<p><img src="windows/../assets/windows/QQ%E6%88%AA%E5%9B%BE20230504111223.png" alt="" /></p>
</li>
<li>
<p>下载后解压到需要安装的目录</p>
</li>
<li>
<p>配置环境变量，将解压后的目录下的bin目录配置环境变量</p>
</li>
<li>
<p>配置后重启终端，输入<code>gcc -v</code> 查看版本</p>
</li>
<li>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_42880082/article/details/120097989">MinGW-w64 C/C++编译器各版本说明</a></li>
<li><a href="https://blog.csdn.net/m0_52733659/article/details/121527947">MinGW离线安装包安装教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/565370467">windows下安装gcc12（mingw-w64）</a></li>
</ul>
</li>
</ul>
<h2 id="windows开启启动文件夹"><a class="header" href="#windows开启启动文件夹">windows开启启动文件夹</a></h2>
<p><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</code></p>
<h2 id="windows-命令行工具操作linux"><a class="header" href="#windows-命令行工具操作linux">windows 命令行工具操作linux</a></h2>
<ul>
<li>
<p>ssh，远程连接 和linux下的ssh使用方式一样</p>
</li>
<li>
<p>scp，远程传输文件，和linux下的scp一样</p>
</li>
<li>
<p>使用scoop作为windwos 的包管理</p>
<ul>
<li>安装</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
</code></pre>
<h1 id="bat-脚本"><a class="header" href="#bat-脚本">bat 脚本</a></h1>
<ul>
<li>字符串操作
<ul>
<li><a href="https://blog.csdn.net/tjcwt2011/article/details/120508290">字符串包含操作</a></li>
<li><a href="https://blog.csdn.net/peng_cao/article/details/74170979">字符串操作</a></li>
</ul>
</li>
<li>函数定义
<ul>
<li><a href="windows/">函数定义</a></li>
</ul>
</li>
<li>for命令
<ul>
<li><a href="https://blog.csdn.net/weixin_43165135/article/details/127702841">for命令</a></li>
</ul>
</li>
</ul>
<h1 id="注册表相关操作"><a class="header" href="#注册表相关操作">注册表相关操作</a></h1>
<h2 id="caps-lock键禁用"><a class="header" href="#caps-lock键禁用">caps lock键禁用</a></h2>
<ol>
<li>打开注册表编辑器</li>
<li>进入<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout</code></li>
<li><strong>右键点击</strong> 在空白处，单击 <strong>New</strong> 然后点击 <strong>Binary Value</strong>(二进制值). 将新的二进制值命名为 <strong>ScanCode Map</strong>.</li>
<li>设置值为<code>00 00 00 00 00 00 00 00 02 00 00 00 00 00 3A 00 00 00 00 00</code></li>
<li>保存后重启电脑</li>
</ol>
<h2 id="自定义右键菜单"><a class="header" href="#自定义右键菜单">自定义右键菜单</a></h2>
<ol>
<li>添加选中文件夹时的右键菜单
<ol>
<li>打开注册表</li>
<li>进入<code>\HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell</code>路径</li>
<li>新建项，</li>
<li>设置默认名称的值为右键显示的字符串</li>
<li>新建icon字符串，值设置为使用软件的路径</li>
<li>新建项command</li>
<li>设置默认值为 <code>软件的路径 &quot;%1&quot;</code>,其中%1为选中文件夹的路径</li>
</ol>
</li>
<li>添加点击文件夹空白处的右键菜单
<ol>
<li>进入<code>\HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell</code>路径</li>
<li>其它步骤和添加选中文件夹时的右键菜单一样，第7步时将<code>%1</code>改为<code>%v.</code>，同样表示当前文件夹的路径</li>
</ol>
</li>
<li>添加选择文件时的右键菜单
<ol>
<li>进入<code>\HKEY_LOCAL_MACHINE\SOFTWARE\Classes</code>路径</li>
<li>路径下第一个项<code>*</code>代表所有类型的文件，其它已<code>.</code>开头的项是某个具体类型的文件，根据具体情况在这个项下面的shell项内添加就可以了</li>
<li>其它步骤和添加选中文件夹时的右键菜单一样</li>
</ol>
</li>
</ol>
<h2 id="windows11"><a class="header" href="#windows11">windows11</a></h2>
<ul>
<li>还原右键菜单
<ul>
<li>命令行输入以下命令</li>
<li><code>reg.exe add 'HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32' /f /ve</code></li>
<li>打开任务管理器，选择windows资源管理器，点击重启任务按钮</li>
</ul>
</li>
<li>禁用蓝牙绝对音量</li>
<li>打开注册表</li>
<li>找到以下路径
<ul>
<li><code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Bluetooth\Audio\AVRCP\CT</code></li>
</ul>
</li>
<li>找到<code>DisableAbsoluteVolume</code>变量，将里面的值修改为1</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-prompt"><a class="header" href="#command-prompt">Command Prompt</a></h1>
<blockquote>
<p>windows默认shell(cmd.exe)</p>
</blockquote>
<h2 id="常用命令-2"><a class="header" href="#常用命令-2">常用命令</a></h2>
<blockquote>
<p>cmd内置命令默认后面接<code>/?</code> 查看命令的帮助</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#dir">dir</a></strong></td><td>列出当前目录下的子目录</td></tr>
<tr><td><strong>cls</strong></td><td>清屏</td></tr>
<tr><td><strong>echo</strong></td><td>回显消息</td></tr>
<tr><td><strong>cd</strong></td><td>切换目录</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#copy">copy</a></strong></td><td>复制文件</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#del">del</a></strong></td><td>删除文件</td></tr>
<tr><td><strong>md/mkdir</strong></td><td>创建文件夹</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#rd">rd</a></strong></td><td>删除目录</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#date">date</a></strong></td><td>查看当前日期</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#mklink">mklink</a></strong></td><td>创建软链接(类似linux的<code>ln</code>命令 )</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#timeout">timeout</a></strong></td><td>睡眠</td></tr>
<tr><td><strong><a href="windows/command_prompt%5Cindex.html#start">start</a></strong></td><td>启动一个程序</td></tr>
<tr><td><strong>exit</strong></td><td>退出终端</td></tr>
</tbody></table>
</div>
<h3 id="命令说明"><a class="header" href="#命令说明">命令说明</a></h3>
<blockquote>
<p>参数忽略大小写</p>
</blockquote>
<h4 id="dir"><a class="header" href="#dir">dir</a></h4>
<ul>
<li><code>/A</code> 指定具体属性的文件显示
<pre><code class="language-cmd">REM 显示隐藏文件
dir /A:H
REM 显示隐藏的文件夹
dir /A:HD
</code></pre>
</li>
<li><code>/O</code> 排序
<pre><code class="language-cmd">REM 按名称排序
dir /O:N
REM 按大小排序
dir /O:S
REM 按日期排序
dir /O:D
</code></pre>
</li>
</ul>
<h4 id="copy"><a class="header" href="#copy">copy</a></h4>
<ul>
<li>&quot;/Y&quot; 如果文件存在则覆盖</li>
<li>TODO</li>
</ul>
<h4 id="del"><a class="header" href="#del">del</a></h4>
<ul>
<li>TODO 详细说明</li>
<li><code>/P</code> 删除前确认</li>
<li><code>/F</code> 强制删除</li>
<li><code>/S</code> 递归删除</li>
<li><code>/Q</code> 静默删除</li>
<li><code>/A</code> 按文件属性删除</li>
</ul>
<h3 id="rd"><a class="header" href="#rd">rd</a></h3>
<ul>
<li><code>/S</code> 递归删除</li>
<li><code>/Q</code> 静默删除</li>
</ul>
<h4 id="date"><a class="header" href="#date">date</a></h4>
<ul>
<li><code>/T</code> 显示当前日期不提示输入新的日期 (默认<code>date</code>不带参数会提示输入新的日期)</li>
</ul>
<h4 id="mklink"><a class="header" href="#mklink">mklink</a></h4>
<blockquote>
<p>参数默认都使用绝对路径</p>
</blockquote>
<ul>
<li>不带参数默认创建文件链接
<pre><code class="language-cmd">REM 第一个参数是创建的链接，第二个参数是目标文件
mklink /a/b/d /a/b/c
</code></pre>
</li>
<li>TODO 详细说明</li>
<li><code>/D</code> 创建目录链接</li>
<li><code>/H</code> 创建硬链接</li>
<li><code>/J</code> 创建目录联接</li>
</ul>
<h3 id="timeout"><a class="header" href="#timeout">timeout</a></h3>
<h3 id="start"><a class="header" href="#start">start</a></h3>
<ul>
<li>TODO</li>
</ul>
<h2 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h2>
<ul>
<li>TODO</li>
</ul>
<h2 id="批处理脚本"><a class="header" href="#批处理脚本">批处理脚本</a></h2>
<blockquote>
<p>.bat/.cmd文件</p>
</blockquote>
<h3 id="变量"><a class="header" href="#变量">变量</a></h3>
<pre><code class="language-cmd">REM 定义变量
set a=1
REM 使用变量
echo %a%
</code></pre>
<h3 id="条件"><a class="header" href="#条件">条件</a></h3>
<h4 id="数字"><a class="header" href="#数字">数字</a></h4>
<pre><code class="language-cmd">REM == 相等
if 1 == 1 (echo 1)
REM neq 不相等
if 1 neq 2 (echo 1)
REM lss 小于
if 1 lss 2 (echo 1)
REM leq 小于等于
if 1 lss 1 (echo 1)
REM gtr 大于
if 2 gtr 1 (echo 1)
REM geq 大于等于
if 1 geq 1 (echo 1)
</code></pre>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
<blockquote>
<p>匹配方式和数字的一样</p>
</blockquote>
<pre><code class="language-cmd">REM 忽略大小写匹配
if /i &quot;a&quot; == &quot;A&quot; (echo 1)
</code></pre>
<h4 id="文件"><a class="header" href="#文件">文件</a></h4>
<pre><code class="language-cmd">REM 判断文件是否存在
if exist filename (echo 1)
REM 判断文件不存在
if not exist filename (echo 1)
</code></pre>
<h4 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h4>
<ul>
<li>TODO</li>
</ul>
<h3 id="结构控制"><a class="header" href="#结构控制">结构控制</a></h3>
<h4 id="if"><a class="header" href="#if">if</a></h4>
<pre><code class="language-cmd">if 1==1 (
    echo 1 
) else (
    echo 2
)
</code></pre>
<h4 id="goto"><a class="header" href="#goto">goto</a></h4>
<h5 id="实现函数定义"><a class="header" href="#实现函数定义">实现函数定义</a></h5>
<blockquote>
<p>函数必须定义在脚本的最后，由于是用goto实现，函数就是一部分脚本，定义在前面会先执行一遍<br />
:EOF 表示跳转到文件末尾</p>
</blockquote>
<pre><code class="language-cmd">REM 实现根据不同参数输出不同字符功能
set param=1
if %param%==1 (goto :print_a)
if %param%==2 (goto :print_b)
goto :EOF

:print_a
echo a
goto :EOF

:print_b
echo b
goto :EOF
</code></pre>
<h3 id="循环"><a class="header" href="#循环">循环</a></h3>
<ul>
<li>TODO</li>
</ul>
<h4 id="for"><a class="header" href="#for">for</a></h4>
<h5 id="实现获取路径中的文件名"><a class="header" href="#实现获取路径中的文件名">实现获取路径中的文件名</a></h5>
<pre><code class="language-cmd">set path=&quot;C:\a\b\a\d.txt&quot;

REM ~n 表示文件名
for %%i in (%path%) do echo %%~ni
REM 输出 d

REM ~x 表示文件扩展名
for %%i in (%path%) do echo %%~xi
REM 输出 .txt

REM ~nx 表示文件名和文件扩展名
for %%i in (%path%) do echo %%~nxi
REM 输出 d.txt

</code></pre>
<ul>
<li>TODO</li>
</ul>
<h4 id="while-使用goto实现"><a class="header" href="#while-使用goto实现">while (使用goto实现)</a></h4>
<ul>
<li>TODO</li>
</ul>
<h2 id="参考网站"><a class="header" href="#参考网站">参考网站</a></h2>
<ul>
<li>ss64 <a href="https://ss64.com/nt/">https://ss64.com/nt/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsl2"><a class="header" href="#wsl2">WSL2</a></h1>
<ul>
<li>windows 10版本</li>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl">官方文档</a></li>
</ul>
<h2 id="安装debian"><a class="header" href="#安装debian">安装debian</a></h2>
<ul>
<li>
<p>查看wsl的版本和安装信息 <code>wsl -l -v</code></p>
</li>
<li>
<p>指定默认以WSL2为结构体系,以后再安装任何 版本都是在WSL2中运行的 <code>wsl --set-default-version 2</code></p>
</li>
<li>
<p>自带商店搜索linux版本安装就可以</p>
</li>
<li>
<p>启动时报错<code>WslRegisterDistribution failed with error: 0x800701bc</code></p>
<ul>
<li>根系wsl2内核，使用软件<code>wsl_update_x64.msi</code>从<code>https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</code>下载</li>
</ul>
</li>
<li>
<p>启动后报错<code>参考的对象类型不支持尝试的操作</code></p>
<ul>
<li><del>运行<a href="windows/wsl2/../../assets/windows/fix_wsl2_error.reg">fix_wsl2_error.reg</a>文件修改注册表</del></li>
<li><del>也可以按文件内容手动修改注册表</del></li>
<li>将<a href="windows/wsl2/../../assets/windows/netsh_winsock_reset.cmd">netsh_winsock_reset.cmd</a> 脚本开机自启
<ul>
<li>win+r 输入 <code>shell:startup</code></li>
<li>脚本放入这个文件夹就可以了</li>
</ul>
</li>
</ul>
</li>
<li>
<p>安装<code>ifconfig</code>相关命令<code>sudo apt install net-tools</code></p>
</li>
<li>
<p>安装<code>firewall-cmd</code>相关工具</p>
</li>
<li>
<h3 id="systemd-支持"><a class="header" href="#systemd-支持">systemd 支持</a></h3>
</li>
<li>
<p>若要启用 systemd，请使用 在文本编辑器中打开<code>wsl.conf</code>文件，以获取管理员权限，并将以下行添加到 <code>/etc/wsl.conf</code></p>
<pre><code class="language-shell">[boot]
systemd=true
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">docker</a></h1>
<h2 id="docker安装"><a class="header" href="#docker安装">docker安装</a></h2>
<ul>
<li>
<p><a href="https://docs.docker.com/engine/install/debian/#installation-methods">安装文档</a></p>
</li>
<li>
<p>在文档内选择安装方式安装，我使用的apt安装方式</p>
</li>
</ul>
<h3 id="添加镜像"><a class="header" href="#添加镜像">添加镜像</a></h3>
<ul>
<li>新建文件<code>/etc/docker/daemon.json</code></li>
</ul>
<pre><code class="language-json">{
    &quot;registry-mirrors&quot;: [
        &quot;https://registry.docker-cn.com&quot;,
        &quot;http://hub-mirror.c.163.com&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://cr.console.aliyun.com&quot;,
        &quot;https://mirror.ccs.tencentyun.com&quot;
    ]
}
</code></pre>
<h2 id="容器镜像"><a class="header" href="#容器镜像">容器&amp;镜像</a></h2>
<blockquote>
<p>在<a href="https://hub.docker.com/">docker hub</a>上搜索镜像</p>
</blockquote>
<h3 id="镜像"><a class="header" href="#镜像">镜像</a></h3>
<ul>
<li><code>docker search image_name</code> 搜索镜像</li>
<li><code>docker pull [image_repo]image_name[:image_tag]</code> 下载镜像</li>
<li><code>docker images</code> 查看已有的镜像</li>
<li><code>docker rmi</code> 删除镜像</li>
</ul>
<h3 id="容器"><a class="header" href="#容器">容器</a></h3>
<ul>
<li>
<p><code>docker ps -a</code> 查看所有容器</p>
</li>
<li>
<p><code>docker rm</code> 删除容器</p>
<ul>
<li>删除某个镜像对应的所有容器</li>
</ul>
<pre><code class="language-powershell">docker rm $(docker ps -af ancestor=image_name -q)
</code></pre>
</li>
<li>
<p><code>docker run image_name</code> 运行容器</p>
<ul>
<li><code>-d</code> 后台运行</li>
<li><code>-it</code> 交互式运行容器命令最后接需要执行的交互式命令，通常是bash</li>
</ul>
</li>
<li>
<p><code>docker exec</code> 在容器内执行命令</p>
<ul>
<li><code>-it</code> 交互式</li>
</ul>
</li>
<li>
<p><code>docker logs container_id</code> 查看容器的命令</p>
<ul>
<li><code>-f</code> 监听日志</li>
</ul>
</li>
<li>
<p><code>docker cp container_id:path path</code> 复制容器内的文件到本地，反过来一样</p>
</li>
<li>
<p><code>docker stop container_id</code> 停止容器</p>
</li>
<li>
<p><code>docker start container_id</code> 启动容器</p>
</li>
</ul>
<h2 id="数据卷"><a class="header" href="#数据卷">数据卷</a></h2>
<ul>
<li><code>docker volume</code></li>
</ul>
<h2 id="网络"><a class="header" href="#网络">网络</a></h2>
<ul>
<li><code>docker network</code></li>
</ul>
<p><code>docker build -t 镜像名称:镜像标签 Dockerfile目录</code> 制作镜像</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id=""><a class="header" href="#"></a></h3>
<h3 id="docker-gitlab备份"><a class="header" href="#docker-gitlab备份">docker gitlab备份</a></h3>
<ul>
<li>
<p><code>docker ps</code>获取 container id</p>
</li>
<li>
<p><code>docker exec -i -t （这里填container id） /bin/bash</code></p>
</li>
<li>
<p><code>gitlab-rake gitlab:backup:create</code></p>
</li>
<li>
<p>输出<code>Creating backup archive xxx_xxx.tar</code>备份成功</p>
</li>
<li>
<p>文件在创建容器的命令映射的gitlab数据路径下<code>data/backups</code>下</p>
</li>
</ul>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li>参考https://blog.csdn.net/weixin_43961117/article/details/126125976教程</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">git</a></h1>
<ul>
<li><a href="https://git-scm.com/">官网</a></li>
<li><a href="https://git-scm.com/downloads">下载地址</a></li>
</ul>
<h2 id="远程"><a class="header" href="#远程">远程</a></h2>
<ul>
<li>
<p>查看远程信息： <code>git remote -v</code></p>
</li>
<li>
<p>删除远程：<code>git remote rm 远程名</code></p>
</li>
<li>
<p>重命名远程：<code>git remote rename 远程名 新远程名</code></p>
</li>
<li>
<p>使用token push 到github</p>
</li>
</ul>
<pre><code class="language-bash">git remote add origin https://oauth2:[token]@github.com/follow1123/ide_configs.git
</code></pre>
<h3 id="拉取"><a class="header" href="#拉取">拉取</a></h3>
<ul>
<li>直接从远程拉取文件：<code>git pull</code></li>
<li>从远程拉取某个分支并新建这个分支：<code>git checkout -b 本地分支名 m/远程分支名</code></li>
<li>指定分支或tag拉取 <code>git clone -b 分支名、tag名 url</code> </li>
</ul>
<h3 id="提交"><a class="header" href="#提交">提交</a></h3>
<ul>
<li>添加到暂存区 </li>
</ul>
<pre><code class="language-bash">git add .
</code></pre>
<ul>
<li>提交</li>
</ul>
<pre><code class="language-bash">git commit -m &quot;备注&quot;
</code></pre>
<ul>
<li>git停止跟踪一个文件</li>
</ul>
<pre><code class="language-bash">git rm --cached 文件名
</code></pre>
<ul>
<li>设置提交的用户信息</li>
</ul>
<pre><code class="language-bash">git config --global user.name &quot;&quot;
git config --global user.email &quot;&quot;
</code></pre>
<ul>
<li>提交日志</li>
</ul>
<pre><code class="language-bash">git log
# 显示提交流程线
git log --graph 
# 简化日志
git log --oneline
</code></pre>
<p>删除</p>
<ul>
<li>从本地库中删除文件</li>
</ul>
<pre><code class="language-bash">git rm 文件名
</code></pre>
<h2 id="还原"><a class="header" href="#还原">还原</a></h2>
<ul>
<li>恢复删除的文件</li>
</ul>
<pre><code class="language-bash">git checkout -- 文件名
</code></pre>
<ul>
<li>还原文件版本</li>
</ul>
<pre><code class="language-bash"># 版本号 使用 git log名称可以获取，如果还原从本地库删除的文件还需要使用 git checkout -- 名称还原文件
git reset 版本号 文件名
</code></pre>
<h2 id="分支"><a class="header" href="#分支">分支</a></h2>
<ul>
<li>查看分支</li>
</ul>
<pre><code class="language-bash">git branch
</code></pre>
<ul>
<li>修改分支名称</li>
</ul>
<pre><code class="language-bash">git branch -M 新名称
</code></pre>
<ul>
<li>查看版本差异</li>
</ul>
<pre><code class="language-bash">git diff 版本号1 版本号2 文件名
</code></pre>
<ul>
<li>删除分支</li>
</ul>
<pre><code class="language-bash">git branch -d 分支名
</code></pre>
<ul>
<li>切换分支，没有则新建一个</li>
</ul>
<pre><code class="language-bash">git checkout -b 分支名
</code></pre>
<h3 id="合并分支"><a class="header" href="#合并分支">合并分支</a></h3>
<ul>
<li>合并分支</li>
<li>先切换到一个需要被合并的分支</li>
<li>输入 <code>git merge 合并的分支</code></li>
</ul>
<h3 id="还原合并的分支"><a class="header" href="#还原合并的分支">还原合并的分支</a></h3>
<ul>
<li>输入 <code>git reflog</code> 显示提交信息</li>
<li>输入 <code>git reset --hard [reflog里面的id]</code> 还原</li>
</ul>
<h2 id="日志"><a class="header" href="#日志">日志</a></h2>
<ul>
<li>
<p>查看日志 <code>git log</code>、<code>git reflog</code></p>
</li>
<li>
<p>设置 git 的日志输出的编码格式</p>
</li>
</ul>
<pre><code class="language-bash">git config --global core.quotepath false          # 显示 status 编码 
git config --global gui.encoding utf-8            # 图形界面编码 
git config --global i18n.commit.encoding utf-8    # 处理提交信息编码 
git config --global i18n.logoutputencoding utf-8  # 输出 log 编码 
# export LESSCHARSET=utf-8  
</code></pre>
<ul>
<li>查看配置信息</li>
</ul>
<pre><code class="language-bash"># 系统
git config --system --list
# 全局
git config --global --list
# 本地
git config --local --list
</code></pre>
<ul>
<li>解除SSL验证</li>
</ul>
<pre><code class="language-bash">git config --global http.sslVerify false
</code></pre>
<ul>
<li>设置单独项目push buffer的大小</li>
</ul>
<pre><code class="language-bash">git config http.postBuffer 1024000000
</code></pre>
<ul>
<li>设置全局项目push buffer的大小</li>
</ul>
<pre><code class="language-bash">git config –global http.postBuffer 1024000000
</code></pre>
<h2 id="子模块"><a class="header" href="#子模块">子模块</a></h2>
<ul>
<li>
<p><del>在git根目录下新建.gitmodules文件（和.gitignore同一个目录）</del></p>
<pre><code>[submodule &quot;子模块名称&quot;]
	path = &quot;子模块名称&quot;
	url = &quot;子模块git url&quot;
	active = true
	ignore = all
</code></pre>
</li>
<li>
<p><del>初始化子模块：<code>git submodule init</code></del></p>
</li>
<li>
<p><del>更新子模块：<code>git submodule update</code></del></p>
</li>
<li>
<p><del>初始化并更新子模块：<code>git submodule update --init</code></del></p>
</li>
<li>
<p>以上方法添加子模块可能有问题</p>
</li>
<li>
<p>使用命令直接添加</p>
<pre><code class="language-bash">git submodule init --初始化子模块
git submodule add https://github.com/example/scripts.git scripts --直接添加子模块
</code></pre>
<ul>
<li>删除所有子模块 <code>git submodule deinit -f --all</code></li>
</ul>
</li>
</ul>
<h1 id="git相关操作"><a class="header" href="#git相关操作">git相关操作</a></h1>
<h2 id="将历史某一次提交删除"><a class="header" href="#将历史某一次提交删除">将历史某一次提交删除</a></h2>
<ul>
<li>假如对分支A进行操作，需要删除提交m</li>
<li>先将基于当前分支创建一个新分支B</li>
<li>将分支A重置到m提交前一次提交<code>git reset --hard</code></li>
<li>再将分支B内m提交后所有提交摘取到分支A上
<ul>
<li><code>git cherry-pick 提交id</code>摘取一个提交</li>
<li><code>git cherry-pick 提交idA..提交idB</code>摘取从A到B所有提交，不包括提交A</li>
<li><code>git cherry-pick 提交idA^..提交idB</code>摘取从A到B所有提交，包括提交A</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<h2 id="新特性"><a class="header" href="#新特性">新特性</a></h2>
<h3 id="java9"><a class="header" href="#java9">java9</a></h3>
<h4 id="模块机制"><a class="header" href="#模块机制">模块机制</a></h4>
<ul>
<li>在项目目录下新建module-info.java文件</li>
</ul>
<pre><code class="language-java">module com.demo{
  requires java.se;
}
</code></pre>
<ul>
<li>
<p><code>requires</code> 依赖模块</p>
<ul>
<li><code>requires transitive 模块名</code> 将依赖模块依赖的模块传递到当前模块，不用重复依赖</li>
</ul>
</li>
<li>
<p><code>exports</code> 导出模块</p>
<ul>
<li><code>exports 包名 to 模块名</code> 到处模块到指定的模块</li>
</ul>
</li>
<li>
<p>开放反射权限，标记<code>open</code>关键字</p>
</li>
</ul>
<pre><code class="language-java">// 开放整个模块
open module com.demo{
  requires java.se;
}

// 开放部分包
open module com.demo{
    opens 包名;
}

</code></pre>
<ul>
<li>定义接口给其他模块实现</li>
</ul>
<pre><code class="language-java">// 模块a内有一个Test接口
module module.a{
    uses com.Test
}

// 模块b内实现了Test接口

module module.a{
    requires module.a;
    provides com.Test whit com.TestImpl;
}

</code></pre>
<h4 id="接口内可以定义private方法"><a class="header" href="#接口内可以定义private方法">接口内可以定义private方法</a></h4>
<blockquote>
<p>定义接口的的公共方法</p>
</blockquote>
<h4 id="集合类的工厂方法"><a class="header" href="#集合类的工厂方法">集合类的工厂方法</a></h4>
<blockquote>
<p>快速创建集合，这种方法创建的集合都是只读的</p>
</blockquote>
<pre><code class="language-java">// Map
Map.of(&quot;key1&quot;, &quot;value1&quot;, &quot;key2&quot;, &quot;value2&quot;)

// List
List.of(&quot;value1&quot;, &quot;value2&quot;);

// Set
Set.of(&quot;value1&quot;, &quot;value2&quot;);
</code></pre>
<h4 id="stream增强"><a class="header" href="#stream增强">Stream增强</a></h4>
<pre><code class="language-java">// 创建Stream空指针判断方法
Stream.ofNullable(null);

// iterate创建Stream时添加limit条件，添加截断操作
Stream.iterate(0, i -&gt; i &lt; 10, i -&gt; i = i + 1)
  .takeWhile(i -&gt; i &lt; 6) // i &lt; 6 时截断
  .forEach(System.out::println);

// 丢弃

Stream.iterate(0, i -&gt; i &lt; 10, i -&gt; i = i + 1)
  .dropWhile(i -&gt; i &lt; 6) // i &lt; 6 时丢弃
  .forEach(System.out::println);
</code></pre>
<h4 id="其他-1"><a class="header" href="#其他-1">其他</a></h4>
<ul>
<li>try-with-resource语法优化</li>
</ul>
<pre><code class="language-java">// try-with-resource语法不需要在括号内申明完整的语句
FileInputStream fileInputStream = new FileInputStream(new File(&quot;/path/to/aaa&quot;));
try(fileInputStream){
    fileInputStream.read();
}
</code></pre>
<ul>
<li>Optional添加部分方法</li>
</ul>
<pre><code class="language-java">// 如果数据为空则提供另一个Optional
Optional.ofNullable(null)
  .or(() -&gt; Optional.of(1));

// ifPresent添加为空分支
Optional.ofNullable(null)
  .ifPresentOrElse(v -&gt; {
    System.out.println(&quot;value is: &quot; + v);
  }, () -&gt; {
    System.out.println(&quot;value is null&quot;);
  });
</code></pre>
<h3 id="java10"><a class="header" href="#java10">java10</a></h3>
<ul>
<li>添加<code>var</code>关键字用于类型推断，只适用与局部变量</li>
</ul>
<h3 id="java11"><a class="header" href="#java11">java11</a></h3>
<ul>
<li>var 关键字可以用于lambda参数内</li>
</ul>
<pre><code class="language-java">// var 关键字可以用于lambda参数内
Consumer&lt;String&gt; consumer = (var s) -&gt; {
    System.out.println(s);
};
consumer.accept(&quot;123&quot;);
</code></pre>
<ul>
<li>String增强</li>
</ul>
<pre><code class="language-java">// 非空判断
String s = &quot;&quot;;
String s1 = &quot; &quot;;

System.out.println(s.isEmpty()); // true
System.out.println(s.isBlank()); // true

System.out.println(s1.isEmpty()); // false
System.out.println(s1.isBlank()); // true

// 字符串重复

String s2 = &quot;a&quot;;
System.out.println(s2.repeat(3)); // aaa


// 获取字符串内的每行组成一个Stream
String s3 = &quot;a\nb\nc&quot;;
s3.lines().forEach(System.out::println);

// 去除字符串首位空格

String s4 = &quot; a b c d &quot;;
System.out.println(s4.strip().length()); // 7
System.out.println(s4.stripLeading().length()); // 8
System.out.println(s4.stripTrailing().length()); // 8
</code></pre>
<ul>
<li>HttpClient 全新Http客户端</li>
</ul>
<h3 id="java12-16"><a class="header" href="#java12-16">java12-16</a></h3>
<ul>
<li>switch表达式</li>
</ul>
<pre><code class="language-java">int i = 0;
String a = switch (i){
  case 1, 2 -&gt; &quot;case 1&quot;;
  case 3, 4 -&gt; &quot;case 2&quot;;
  default -&gt; {
    System.out.println(&quot;123&quot;);
    yield &quot;case default&quot;;
  }
};
</code></pre>
<ul>
<li>文本快</li>
</ul>
<pre><code class="language-java">String s = &quot;&quot;&quot;
12321
123123ad
qweqwe
&quot;&quot;&quot;;
System.out.println(s);
</code></pre>
<ul>
<li>instanceof增强</li>
</ul>
<pre><code class="language-java">Object s = &quot;123&quot;;

if (s instanceof String str){
System.out.println(str);
}
</code></pre>
<ul>
<li>
<p>空指针报错优化</p>
</li>
<li>
<p>Record类，替换Lombok</p>
</li>
</ul>
<h3 id="java17"><a class="header" href="#java17">java17</a></h3>
<ul>
<li>密封类型</li>
</ul>
<h3 id="后端解决跨域的三种方式"><a class="header" href="#后端解决跨域的三种方式">后端解决跨域的三种方式</a></h3>
<ul>
<li>
<ol>
<li>方法上添加<code>@CrossOrigin</code>注解</li>
</ol>
</li>
</ul>
<pre><code class="language-java">@PostMapping(&quot;/testCors&quot;)
@CrossOrigin
public Map&lt;String, String&gt; testCors(){
    return Map.of(&quot;name&quot;, &quot;123&quot;, &quot;age&quot;, &quot;123&quot;);
}
</code></pre>
<ul>
<li>
<ol start="2">
<li>配置<code>CorFilter</code>滤器</li>
</ol>
</li>
</ul>
<pre><code class="language-java">@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter(){
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin(&quot;*&quot;);
        corsConfiguration.addAllowedHeader(&quot;*&quot;);
        corsConfiguration.addAllowedMethod(&quot;*&quot;);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);
        return new CorsFilter(source);
    }
}
</code></pre>
<ul>
<li>
<ol start="3">
<li>实现<code>WebMvcConfigurer</code>接口的<code>addCorsMappings</code>方法进行配置</li>
</ol>
</li>
</ul>
<pre><code class="language-java">@Configuration
public class CorsConfigure implements WebMvcConfigurer {


    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOriginPatterns(&quot;*&quot;)
                .allowedHeaders(&quot;*&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)
                .allowCredentials(false)
                .maxAge(3600);
    }
}
</code></pre>
<ul>
<li>配合安全框架的情况下推荐使用<code>CorFilter</code>的方式，过滤器会最先执行</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javasource"><a class="header" href="#javasource">javaSource</a></h1>
<h2 id="javautil"><a class="header" href="#javautil">java.util</a></h2>
<h3 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h3>
<ul>
<li>
<p>初始化</p>
<ul>
<li>初始化为一个空的Object数组</li>
</ul>
</li>
<li>
<p>添加元素</p>
<ul>
<li>
<p>添加第一个元素时将elementData初始化为长度为10的object数组才加入元素</p>
</li>
<li>
<p>在添加元素是会先判断数组的容量够不够，不够这会进行扩容</p>
</li>
<li>
<p>方式</p>
<ul>
<li>当添加到数组最后一个位置前进行扩容</li>
<li>新长度为旧长度+（旧长度右移一位）</li>
<li>使用System.arrayCopy()进行操作</li>
</ul>
<pre><code class="language-java">//旧数组
int[] is = {1, 2, 3, 4, 5, 6, 7, 8, 9, 123, 321, 4324, 432, 34, 43, 3};
//新数组
int[] newIs = new int[is.length + (is.length &gt;&gt; 1)];
</code></pre>
</li>
</ul>
<p>//扩容操作
System.arraycopy(is, 0, newIs, 0, is.length);</p>
<pre><code>


</code></pre>
</li>
<li>
<p>删除元素</p>
<ul>
<li>使用数组拷贝方式</li>
<li>使用System.arrayCopy()进行操作</li>
</ul>
<pre><code class="language-java">int[] is = {1, 2, 3, 4, 5, 6, 7, 8, 9, 123, 321, 4324, 432, 34, 43, 3};
//拷贝操作
System.arraycopy(is, 3 + 1, is, 3, is.length - 4);
//数组最后一位置空
is[is.length - 1] = 0;
</code></pre>
</li>
</ul>
<h3 id="linkedlist"><a class="header" href="#linkedlist">LinkedList</a></h3>
<ul>
<li>
<p>插入元素</p>
<ul>
<li>默认使用尾插法</li>
</ul>
<pre><code class="language-java">void linkLast(E e) {
    //获取last对象的指针
    final Node&lt;E&gt; l = last;
    //创建一个新的节点对象
    //传入previous节点，赋值
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    //last指针指向新的对象
    last = newNode;
    //判断l指针指向的对象是否为空
    if (l == null)
        //为空说明链表为空，将first指针指向这个新的对象
        first = newNode;
    else
        //否则将原last对象的last指针指向这个新的对象
        l.next = newNode;
    //链表的大小加一
    size++;
    modCount++;
}
</code></pre>
</li>
<li>
<p>获取元素</p>
<pre><code class="language-java">//根据下标查找
public E get(int index) {
    //	判断下标是否合法
    checkElementIndex(index);
    		//根据index查值
    return node(index).item;
}
//根据index查值
Node&lt;E&gt; node(int index) {
	//如果下标小于链表的大小除2则从前往后找
    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
        //否则从后往前找
    } else {
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}

</code></pre>
</li>
<li>
<p>删除元素</p>
<pre><code class="language-java">public E remove(int index) {
    //	判断下标是否合法
    checkElementIndex(index);
    //找到下表为index的节点并移除
    return unlink(node(index));
}
//移除
E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;
	//该节点的prev节点为空说明该节点就是first节点
    if (prev == null) {
        //将first指针指向next节点
        first = next;
    } else {
        //否则将prev节点的next指针指向next对象
        prev.next = next;
        //该节点的prev对象置空
        x.prev = null;
    }
	//该节点的prev节点为空说明该节点就是last节点
    if (next == null) {
        //将last指针指向prev节点
        last = prev;
    } else {
        //否则将next节点的prev指针指向prev对象
        next.prev = prev;
        该节点的next对象置空
        x.next = null;
    }
	//该节点的数据置空
    x.item = null;
    //该链表的大小减一
    size--;
    modCount++;
    return element;
}
</code></pre>
</li>
</ul>
<h3 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h3>
<ul>
<li>
<p>HashMap是由数组链表和红黑树（8加入）组成</p>
</li>
<li>
<p>初始化</p>
<ul>
<li>将默认负载因子初始化为0.75</li>
</ul>
</li>
<li>
<p>添加元素</p>
<ul>
<li>方式一：
<ul>
<li>获取key的hashcode将其%数组的长度旧可以得到对应的下标</li>
<li>将元素存入数组对应下标的链表内，（7 使用的是头插法， 8 使用的是尾插法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="jvm"><a class="header" href="#jvm">JVM</a></h1>
<h2 id="类加载过程"><a class="header" href="#类加载过程">类加载过程</a></h2>
<ul>
<li>
<p>加载</p>
<ul>
<li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据访问入口。（这个过程需要类加载器参与）</li>
</ul>
</li>
<li>
<p>链接：将java类的二进制代码合并到JVM的运行状态中的过程</p>
<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static变量）分配内存并设置类变量的初始值阶段，这些内存都在方法区中进行分配</li>
<li>解析：虚拟机常量池的符号引用替换为直接引用的过程</li>
</ul>
</li>
<li>
<p>初始化</p>
<ul>
<li>初始化阶段是执行类构造器<clinit>()方法的过程，；类构造器<clinit>()方法是由编译器自动收集所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先初始化其父类</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中正确加锁和同步</li>
<li>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化 </li>
</ul>
</li>
<li>
<p>类的主动引用（一定会发生类的初始化）</p>
<ul>
<li>new一个类的对象</li>
<li>调用类的金泰成员（除final常量）和静态方法</li>
<li>对该类进行发射调用时</li>
<li>当虚拟机启动，java Hello，则一定会初始化Hello类，就是先启动main方法所在的类</li>
<li>当初始化一个类，如果其父类没有被初始化，则会初始化其父类</li>
</ul>
</li>
<li>
<p>类的被动引用（不会发生类的初始化）</p>
<ul>
<li>当访问一个静态域时，只有真正声明这个与的类才会被初始化
<ul>
<li>通过子类引用父类的静态域，不会导致子类会被初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会初始化该类</li>
<li>引用常量不会初始化该类（）常量在编译阶段旧存入调用类的常量池中了</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a class="header" href="#类加载器">类加载器</a></h2>
<ul>
<li>作用：
<ul>
<li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据访问入口</li>
</ul>
</li>
<li>类缓存
<ul>
<li>标准的javaSE类加载器可以按要求查找类，但一旦某一个类被加载到在加载器中，它将维持加载（缓存）一段时间，不过，JVM垃圾收集器可以回收这些Class对象</li>
</ul>
</li>
</ul>
<h2 id="类加载器的层次结构树状结构"><a class="header" href="#类加载器的层次结构树状结构">类加载器的层次结构（树状结构）</a></h2>
<ul>
<li>引导类加载器（bootstrap class loader）
<ul>
<li>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar,或sun.boot.class.path路径下的内容），是用原生代码实现的，并不是继承java.lang.ClassLoader</li>
<li>加载扩展类和应用程序类加载器，并指定他们的父类加载器</li>
</ul>
</li>
<li>扩展类加载器（extensions class loader）
<ul>
<li>用来加载java的扩展库（JAVA_HOME/jre/ext/*.jar,或java.ext.dirs路径下的内容），Java虚拟机的实现会提供一个 扩展库目录。该类加载器在此目录里面查找并加载Java类</li>
<li>一由sun.misc.Launcher$ExtClassLoader实现</li>
</ul>
</li>
<li>应用程序加载器( application class loader )
<ul>
<li>一它根据Java应用的类路径( classpath，java.class.path路径的类，一般来说 , Java应用的类都是由它来完成加载的。</li>
<li>一由sun.misc.Launcher$AppClassLoader实现</li>
</ul>
</li>
<li>自定义类加载器
<ul>
<li>一开发人员可以通过继承java.lang.ClassLoader类的方式，实现自己的类加载器,以满足一-些特殊的需求。</li>
</ul>
</li>
</ul>
<h2 id="javaclassclassloader类介绍"><a class="header" href="#javaclassclassloader类介绍">java.class.ClassLoader类介绍</a></h2>
<ul>
<li>作用：
<ul>
<li>java.lang.ClassLoader类的基本职责就是根据-个指定的类的名称，找到或者生成其对应的字节代码,然后从这些字节代码中定义出一个Java类,即java.lang.Class类的一个实例。</li>
<li>除此之外, ClassLoader还负责加载Java应用所需的资源,如图像文件和配置文件等。</li>
</ul>
</li>
<li>相关方法
<ul>
<li>getParent()	返回该类加载器的父类加载器。</li>
<li>loadClass(String name) 加载名称为name的类,返回的结果是java.lang.Class类的实例。</li>
<li>findClass(String name) 查找名称为name的类,返回的结果是java.lang.Class类的实例。</li>
<li>findLoadedClass(String name) 查找名称为name的已经被加载过的类,返回的结果是java.lang.Class类的实例。</li>
<li>defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成Java类,返回的结果是java.lang.Class类的实例。这个方法被声明为final的。</li>
<li>resolveClass(Class&lt;?&gt; c)链接指定的 Java类。</li>
<li>对于以上给出的方法,表示类名称的name参数的值是类的二进制名称。需要注意的是内部类的表示,如com.example.Sample$1和com.example.Sample$Inner等表示方式。</li>
</ul>
</li>
</ul>
<h2 id="类加载器的代理模式"><a class="header" href="#类加载器的代理模式">类加载器的代理模式</a></h2>
<ul>
<li>代理模式
<ul>
<li>一交给其他加载器来加载指定的类</li>
</ul>
</li>
<li>双亲委托机制
<ul>
<li>就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器,依次追溯，直到最高的爷爷辈的,如果父类加载器可以完成类加载任务,就成功返回;只有父类加载器无法完成此加载任务时,才洎己去加载。</li>
<li>双亲委托机制是为了保证Java核心库的类型安全
<ul>
<li>这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。</li>
</ul>
</li>
<li>类加载器除了用于加载类,也是安全的最基本的屏障</li>
</ul>
</li>
<li>双亲委托机制是代理模式的一种
<ul>
<li>并不是所有的类加载器都采用双亲委托机制</li>
<li>-tomcat服务器类加载器也使用代理模式,所不同的是它是首先尝试去加载某个类,如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的</li>
</ul>
</li>
</ul>
<h2 id="自定义类加载器"><a class="header" href="#自定义类加载器">自定义类加载器</a></h2>
<ul>
<li>
<p>自定义类加载器的流程:</p>
<ul>
<li>首先检查请求的类型是否E经被这个类装载器装载到命名空间中了，如果E经装载,直接返回;</li>
<li>委派类加载请求给父类加载器,如果父类加载器能够完成,则返回父加载器加载的Class实例;</li>
<li>调用本数载器的findClass ()方法,试图获取对应的字节码,如果获取的到,则调用defineClass 导入类型到方法区;如果获取不到对应的字节码或者其他原因失败,返回异常给loadClass转抛异常,终止加载过程</li>
<li>注意:
<ul>
<li>被两个类加载器加载的同-个类, JVM不认为是相同的类。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//自定义加载类
public class FileClassLoader extends ClassLoader {
    private String root;
    public FileClassLoader(String root) {
        this.root = root;
    }
    //重写findClass方法
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        //查找该类是否已经被加载
        Class&lt;?&gt; aClass = findLoadedClass(name);
        if (aClass == null){
            try {
                //没被加载先给父类加载进加载
                aClass = getParent().loadClass(name);
            }catch (Exception e){
                aClass = null;
            }
            //判断父类加载器是否加载成功
            if (aClass == null){
                //否者自己加载
                byte[] classData = getClassFromDir(name);
                aClass = defineClass(name, classData, 0, classData.length);
                if (aClass == null){
                    throw new ClassNotFoundException();
                }
            }
        }
        return aClass;
    }
    //根据root目录获取class文件的byte数据
    private byte[] getClassFromDir(String className){
        String path = root + &quot;/&quot; + className.replace(&quot;.&quot;, &quot;/&quot;)+&quot;.class&quot;;
        FileInputStream fis = null;
        ByteArrayOutputStream baos = null;
        try{
            baos = new ByteArrayOutputStream();
            fis = new FileInputStream(path);
            byte[] buffer = new byte[1024];
            int len = 0;
            while ((len = fis.read(buffer)) &gt; 0){
                baos.write(buffer, 0, len);
            }
            baos.flush();
            return baos.toByteArray();
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }finally {
            if (fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (baos != null){
                try {
                    baos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
</li>
<li>
<p>可以自定义当前线程的类加载器</p>
<pre><code class="language-java">Thread.currentThread().setContextClassLoader(自定义的类加载器);
</code></pre>
</li>
</ul>
<h2 id="tomcat服务器的类加载机制"><a class="header" href="#tomcat服务器的类加载机制">TOMCAT服务器的类加载机制</a></h2>
<ul>
<li>TOMCAT不能使用系统默认的类加载器。
<ul>
<li>如果TOMCAT跑你的WEB项目使用系统的类加载器那是相当危险的,你可以直接是无忌惮是操作系统的各个目录了。</li>
<li>对于运行在Java EE”容器中的Web应用来说,类如载器的实现方式与一般的Java应用有所不同。</li>
<li>每个Web应用都有一个对应的类加载器实例。该类加载器也使用代理模式(不同于前面说的双亲委托机制) ,所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的但也是为了保证安全，这样核心库就不在查询范围之内。</li>
</ul>
</li>
<li>为了安全TOMCAT需要实现自己的类加载器。
<ul>
<li>我可以限制你只能把类写在指定的地方,否则我不给你加载!</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发"><a class="header" href="#并发">并发</a></h1>
<h2 id="共享模型"><a class="header" href="#共享模型">共享模型</a></h2>
<h3 id="共享问题"><a class="header" href="#共享问题">共享问题</a></h3>
<ul>
<li><strong>临界区</strong>
一段代码块内会对一个资源进行读写操作，会有多个线程执行这段代码块，这段代码块就叫临界区</li>
<li><strong>竞态条件</strong>
多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</li>
</ul>
<h3 id="synchronized"><a class="header" href="#synchronized">synchronized</a></h3>
<ul>
<li>锁升级原理</li>
</ul>
<p><img src="java/multithreading/../../assets/java/img/image-20210608161529253.png" alt="" /></p>
<p><img src="java/multithreading/../../assets/java/img/image-20210608163209781.png" alt="" /></p>
<ul>
<li>无锁到偏向锁
<ul>
<li>对象的markword倒数第三位为1的话则可以使用偏向锁，否则竞争时直接升级为轻量级锁。</li>
<li>无锁到偏向锁的过程：
<ul>
<li>一个线程需要加锁时会将线程的id写入锁对象的markword头上面，</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程安全分析"><a class="header" href="#线程安全分析">线程安全分析</a></h3>
<h3 id="monitor"><a class="header" href="#monitor">Monitor</a></h3>
<p>使用synchronized(obj) 锁定一个对象时将这个对象和操作系统提供的monitor对象关联，</p>
<pre><code class="language-mermaid">graph TD

subgraph Monitor
	a(WaitSet)
	b(EntitySet)
	c(Owner)
end
</code></pre>
<p>一个monitor对象包含这几个属性，</p>
<ul>
<li>entitySet
<ul>
<li>当一个线程获取对象锁时如果owner已经指向一个线程则进入这个队列等待</li>
</ul>
</li>
<li>Owner
<ul>
<li>当一个对象获取该对象锁时，如果owner没有指向任何线程，则owner指向这个线程，代表这个对象锁被该线程拥有</li>
</ul>
</li>
</ul>
<p>当对象锁和monitor关联后，这个对象的markword位置则会存放指向monitor的指针，而markword里面的相关属性会被存放到monitor对象内</p>
<h3 id="waitnotify"><a class="header" href="#waitnotify">wait/notify</a></h3>
<h3 id="现车状态转换"><a class="header" href="#现车状态转换">现车状态转换</a></h3>
<h3 id="活跃性"><a class="header" href="#活跃性">活跃性</a></h3>
<h3 id="lock"><a class="header" href="#lock">Lock</a></h3>
<h1 id="其他-2"><a class="header" href="#其他-2">其他</a></h1>
<h2 id="synchronized-1"><a class="header" href="#synchronized-1">synchronized</a></h2>
<h6 id="保证被包裹的代码块的原子性"><a class="header" href="#保证被包裹的代码块的原子性">保证被包裹的代码块的原子性</a></h6>
<ul>
<li>底层实现（大致）：
<ul>
<li>JDK早期直接就是重量级锁（向操作系统申请锁）</li>
<li>后来改进为锁升级的过程
<ul>
<li>偏向锁：当一段加锁了的代码第一次被一个线程访问时，会在这个锁上标记这个线程的id号，下次如果还是这个线程访问就直接通行，没有进行其他操作，提高了效率。</li>
<li>自旋锁：接着上面的过程，如果有多个线程访问时，当一个线程持有这个锁未释放时，其他线程就会在外面执行自选操作，类似while循环。</li>
<li>重量级锁：当自旋次数达到10此后就会向操作系统申请重量级锁。</li>
</ul>
</li>
<li>理解：偏向锁和自旋锁都是用户态的操作效率会提高，重量级锁是用户态内核态频繁切换，降低了效率，但是自旋锁也有缺点，就是如果当自旋的线程多了起来也会降低效率，因为自旋操作时这个线程没有被挂起，当自旋的线程多了之后就会有一大堆线程在执行自旋操作，而操作算是一种无意义的操作，所以当一段加锁的代码执行时间很长而且会有很多个线程访问时不建议使用自旋锁</li>
</ul>
</li>
<li>在synchronized代码块内出异常默认锁会被释放</li>
<li>synchronized不能锁字符串常量和基础的数值包装类型
<ul>
<li>字符串常量在字符串常量池内始终是一个对象</li>
<li>数组包装类型由于内部结构跟改一下就会变成不同的对象</li>
</ul>
</li>
</ul>
<h2 id="volatile"><a class="header" href="#volatile">volatile</a></h2>
<h6 id="保证被修饰的对象不被指令重排"><a class="header" href="#保证被修饰的对象不被指令重排">保证被修饰的对象不被指令重排</a></h6>
<ul>
<li>保证线程的可见性
<ul>
<li>jvm虚拟机分为heap、stack等空间，heap空间是共享的而开启线程就是创建一个stack，这两个线程在不同的stack里面访问heap里面的同一个数据时都需要copy一份数据到自己stack空间里面的数据存储区域内，再在自己的区域内对这个数据进行修改，修改完才写回到heap空间，而另一个线程也需要获取这个数据，而不知道这个数据被没被修改，所以需要保证线程的可见性这里需要使用到cpu的缓存一直循协议。</li>
</ul>
</li>
<li>禁止指令重排
<ul>
<li>编译器会将程序编译完的指令进行重写排序以提高效率。</li>
<li>我自己的理解：在一段代码内上半部分的代码执行耗时上，下半部分的代码执行耗时端，而这两部分代码执行时也没有太多关联，编译器就会将下半部分的代码编译完的指令安排到上半部分代码前面执行。</li>
<li>在单例模式的双重检测锁实现方式下也需要使用volatile关键字修饰实例对象
<ul>
<li>因为jvm在创建对象时会分为三步：申请空间、初始化成员变量、赋值到实例，在这几个部分内：
<ul>
<li>如果第一个线程在锁内初始化这个对象，初始化时发生了指令重排，把第二和第三个步骤换了一下，那么第二个线程就会拿到一个默认值全部为空的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="两阶段终止模式"><a class="header" href="#两阶段终止模式">两阶段终止模式</a></h2>
<pre><code class="language-mermaid">graph TD
w(&quot;while(true)&quot;) --&gt; a
a(&quot;是否被打断？&quot;) --&gt; b(&quot;料理后事&quot;)
b --&gt; c((结束循环))
a --&gt; 否 --&gt; d(睡眠2s)
d --&gt; 无异常 --&gt; e(执行监控记录)
d --&gt; 有异常 --&gt; i(设置打断标记)
i --&gt; w
e --&gt; w
</code></pre>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven"><a class="header" href="#maven">Maven</a></h1>
<ul>
<li>
<p><a href="https://maven.apache.org/">官网</a></p>
</li>
<li>
<p><a href="https://archive.apache.org/dist/maven/">历史版本下载地址</a></p>
</li>
</ul>
<h1 id="settingsxml"><a class="header" href="#settingsxml"><a href="java/maven/../../assets/java/settings.xml">settings.xml</a></a></h1>
<h2 id="maven坐标"><a class="header" href="#maven坐标">Maven坐标</a></h2>
<blockquote>
<p>定位jar包，简称<code>gav</code></p>
</blockquote>
<ul>
<li><code>groupId</code> 公司/项目</li>
<li><code>artifactId</code> 模块</li>
<li><code>version</code> 版本</li>
</ul>
<h2 id="常用命令-3"><a class="header" href="#常用命令-3">常用命令</a></h2>
<blockquote>
<p>构建相关命令要在pom.xml路径下执行</p>
</blockquote>
<ul>
<li>
<p><code>mvn -v</code> 插件maven的版本信息</p>
</li>
<li>
<p><code>mvn clean</code> 清理target目录</p>
</li>
<li>
<p><code>mvn compile</code> 编译项目</p>
<ul>
<li>编译后的文件在target目录下</li>
</ul>
</li>
<li>
<p><code>mvn test-compile</code> 编译测试目录</p>
<ul>
<li>编译后的文件在target目录下</li>
</ul>
</li>
<li>
<p><code>mvn test</code> 执行测试代码</p>
</li>
<li>
<p><code>mvn package</code> 项目打包，jar或war包</p>
<ul>
<li>打包后的文件在target目录下</li>
</ul>
</li>
<li>
<p><code>mvn install</code> 安装当前项目到本地仓库</p>
<ul>
<li><code>mvn install -Dmaven.test.skip=true</code> 跳过测试</li>
</ul>
</li>
</ul>
<blockquote>
<p>根据gav(Maven坐标可)以找到本地对应的位置</p>
</blockquote>
<ul>
<li>
<p><code>mvn dependency:list</code> 列出当前项目的jar包依赖</p>
</li>
<li>
<p><code>mvn dependency:tree</code> 以树型方式列出当前项目的jar包依赖</p>
</li>
</ul>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<h3 id="依赖范围-scope标签"><a class="header" href="#依赖范围-scope标签">依赖范围, scope标签</a></h3>
<blockquote>
<p>在dependencies/dependency/scope标签内</p>
</blockquote>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>scope标签可选值：compile,test,provided,system,runtime,import</p>
</blockquote>
<ul>
<li>
<p><code>compile</code> 默认值，在所有情况下都有用</p>
</li>
<li>
<p><code>test</code> 只在test目录下可以使用</p>
</li>
<li>
<p><code>provided</code> 除了不会被打包，其他情况都可以使用</p>
</li>
</ul>
<h3 id="依赖传递"><a class="header" href="#依赖传递">依赖传递</a></h3>
<p>依赖的scope为compile才能传递</p>
<h3 id="依赖排除"><a class="header" href="#依赖排除">依赖排除</a></h3>
<ul>
<li>在需要排除依赖的标签内添加以下标签</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;!-- 排除junit包--&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<blockquote>
<p>当前工程的打包方式为pom的工程才能是工程</p>
</blockquote>
<h2 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h2>
<ul>
<li>在父工程内添加dependencyManagement标签添加依赖管理</li>
</ul>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
  &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<ul>
<li>
<p>然后在子工程内添加对应的依赖信息就可以使用，可以不添加version标签</p>
</li>
<li>
<p>在properties标签内可以添加某个jar包内具体的版本号信息，在dependency标签内可以使用表达式使用</p>
</li>
</ul>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;!-- 在这里定义 --&gt; 
    &lt;javax.servlet-api.version&gt;3.1.0&lt;/javax.servlet-api.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;!-- 在这里使用 --&gt; 
        &lt;version&gt;${javax.servlet-api.version}&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gradle"><a class="header" href="#gradle">Gradle</a></h1>
<h2 id="添加镜像-1"><a class="header" href="#添加镜像-1">添加镜像</a></h2>
<ul>
<li>在项目的build.gradle内添加以下代码</li>
</ul>
<pre><code class="language-groovy">repositories {
	maven{ url 'https://maven.aliyun.com/repository/central' }
	maven{ url 'https://maven.aliyun.com/repository/public' }
	maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}
}
</code></pre>
<h2 id="gradle依赖配置"><a class="header" href="#gradle依赖配置">Gradle依赖配置</a></h2>
<div class="table-wrapper"><table><thead><tr><th>配置</th><th>参与编译</th><th>参与打包</th><th>依赖可传递</th></tr></thead><tbody>
<tr><td>implementation</td><td>√</td><td>√</td><td>×</td></tr>
<tr><td>api</td><td>√</td><td>√</td><td>√</td></tr>
<tr><td>compileOnly</td><td>√</td><td>×</td><td>×</td></tr>
<tr><td>runtimeOnly</td><td>×</td><td>√</td><td>-</td></tr>
</tbody></table>
</div>
<ul>
<li><code>annotationProcessor</code> 注解处理器依赖</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<h2 id="oop七大原则"><a class="header" href="#oop七大原则">OOP七大原则</a></h2>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<ol>
<li><strong>开闭原则</strong>：对扩展开放，对修改关闭</li>
<li><strong>里氏提盒原则</strong>：继承必须确保父类所拥有的性质在子类中仍然成立</li>
<li><strong>依赖倒置原则</strong>：要面向接口编程，不要面向实现编程</li>
<li><strong>单一职责原则</strong>：控制类的粒度大小，将对象解耦，提高其内聚性</li>
<li><strong>接口隔离原则</strong>：要为各个类建立它们需要的专用接口</li>
<li><strong>迪米特法则</strong>：直接与你的朋友交谈，不跟“陌生人”说话</li>
<li><strong>合成服用原则</strong>：尽量先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现</li>
</ol>
<h2 id="创建型模式"><a class="header" href="#创建型模式">创建型模式</a></h2>
<h3 id="单例模式"><a class="header" href="#单例模式">单例模式</a></h3>
<ul>
<li>饿汉式
<ul>
<li>缺点：可以被反射破解</li>
<li>类加载时就创建的该对象的实例，因为类的静态初始化是线程安全的，该方式适用于多线程环境下，因为该对象是在类的初始化时创建的，如果该类创建的过程中需要需要耗费大量资源，则会造成性能的下降</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class HungryMan {
    private static HungryMan hungryMan = new HungryMan();
    //构造器私有化
    private HungryMan(){
        // 判断当前实例是否为空
        // 避免使用反射破解
        if (hungryMan != null){
            throw new RuntimeException(&quot;could not creat this class in constructor&quot;);
        }
    }
	//获取当前实例的方法
    public static HungryMan getInstance(){
        return hungryMan;
    }class
}
</code></pre>
<ul>
<li>懒汉式
<ul>
<li>缺点：可以被反射破解、线程不安全</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class LazyMan {
    private static LazyMan lazyMan;
	//构造器私有化
    private LazyMan(){
        
    }
	//获取该对象实例的方法
    public static LazyMan getInstance(){
        if (lazyMan == null){
            lazyMan = new LazyMan();
        }
        return lazyMan;
    }
}
</code></pre>
<ul>
<li>双重检测锁（DCL懒汉式）
<ul>
<li>缺点：可以被反射破解、可能会发生指令重排，需要在实例属性前加volatile修饰</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class LazyMan {
    		/*加volatile避免系统发生指令重排*/
    private static volatile LazyMan lazyMan;

    private LazyMan(){
    }

    public static LazyMan getInstance(){
        if (lazyMan == null) {
            synchronized(LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                }
            }
        }
        return lazyMan;
    }
}
</code></pre>
<ul>
<li>静态内部类
<ul>
<li>缺点：可以被反射破解</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class InnerSingle {

    private InnerSingle(){

    }

    private static InnerSingle getInstance(){
        return Inner.innerSingle;
    }
    private static class Inner{
        private static InnerSingle innerSingle = new InnerSingle();
    }
}
</code></pre>
<ul>
<li>枚举
<ul>
<li>缺点：没有类的功能，不能继承</li>
<li>不能被反射破解，枚举其实是一个类，里面没有无参构造，有一个有参构造，参数为一个String，一个int</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public enum EnumSingle {
    INSTANCE;
}
</code></pre>
<h3 id="工厂模式"><a class="header" href="#工厂模式">工厂模式</a></h3>
<ul>
<li>
<p><strong>实现了创建者和调用者的分离</strong></p>
</li>
<li>
<p><strong>本质</strong></p>
<ul>
<li>实例化对象不适用new，用工厂方法代替</li>
<li>将选择实现类，创建对象同意管理和控制，从而将调用者跟我们的实现类解耦</li>
</ul>
</li>
<li>
<p><strong>三种模式</strong></p>
<ul>
<li>
<p><strong>简单工厂模式</strong></p>
<ul>
<li>用来生产同意等级结构中的任意产品（对于新加的产品需要修改已有的代码）</li>
<li>方式一：使用同一个方法根据需要产品的名字返回该产品</li>
</ul>
<pre><code class="language-java">//产品接口
public interface Car {
}

public class CarA implements Car {
    @Override
    public String toString() {
        return &quot;this is car a&quot;;
    }
}
public class CarB implements Car {
    @Override
    public String toString() {
        return &quot;this is car b&quot;;
    }
}
public class CarFactory {
    public static Car getCar(String carName){
        switch (carName){
            case &quot;a&quot;:
                return new CarA();
            case &quot;b&quot;:
                return new CarB();
            default:
                return null;
        }
    }
}
</code></pre>
<ul>
<li>方式二：使用不同的方法，需要那个产品就调用那个方法</li>
</ul>
<pre><code class="language-java">public class CarFactory {
    public static Car getCarA(){
        return new CarA();
    }
    public static Car getCarB(){
        return new CarB();
    }
}
</code></pre>
<ul>
<li>缺点：没有完全实现OCP原则，对程序进行扩展时需要修改已有的代码。</li>
</ul>
<p><img src="java/design_pattern/../../assets/java/img/simplefactory.png" alt="simplefactory" /></p>
<hr />
</li>
<li>
<p><strong>工厂方法模式</strong></p>
<ul>
<li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li>
</ul>
<pre><code class="language-java">//工厂接口
public interface Factory {
    Car getCar();
}
//产品接口
public interface Car {
}

public class CarA implements Car {
    @Override
    public String toString() {
        return &quot;this is car a&quot;;
    }
}
public class CarB implements Car {
    @Override
    public String toString() {
        return &quot;this is car b&quot;;
    }
}
public class AFactory implements Factory {
    @Override
    public Car getCar() {
        return new CarA();
    }
}
public class BFactory implements Factory {
    @Override
    public Car getCar() {
        return new CarB();
    }
}

</code></pre>
<ul>
<li>缺点：有着很高的结构复杂度、代码复杂度、编程复杂度、管理上的复杂度</li>
</ul>
</li>
<li>
<p>根据设计原则：工厂方法模式</p>
</li>
<li>
<p>根据实际业务：简单工厂模式</p>
</li>
</ul>
<p><img src="java/design_pattern/../../assets/java/img/methodFactory.png" alt="methodFactory" /></p>
</li>
</ul>
<h3 id="抽象工厂模式"><a class="header" href="#抽象工厂模式">抽象工厂模式</a></h3>
<ul>
<li>围绕一个超级工厂创建其他工厂，该超级工厂有称为其他工厂的工厂</li>
<li>定义：抽象工厂提供了一个创建一系列相关或者相互依赖的对象和接口，无需指定他们的具体的类</li>
<li>适用场景：
<ul>
<li>客户端（应用层）不依赖于产品类实例如何呗创建、实现等细节</li>
<li>强调一系列相关产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</li>
<li>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖与具体的实现</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//抽象工厂
public interface Factory {
    Phone phone();
    Wristband wristband();
}
//Phone产品族
public interface Phone {
    void start();
    void shutdown();
}
//Wristband产品族
public interface Wristband {
    void displayTime();
}
//Phone产品族的具体产品
public class XMPhone implements Phone {
    @Override
    public void start() {
        System.out.println(&quot;小米手机开机！&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;小米手机关机！&quot;);
    }
}
//Phone产品族的具体产品
public class HWPhone implements Phone {
    @Override
    public void start() {
        System.out.println(&quot;华为手机开机！&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;华为手机关机！&quot;);
    }
}
//Wristband产品族的具体产品
public class XMWristband implements Wristband {
    @Override
    public void displayTime() {
        System.out.println(&quot;小爱同学：&quot;+ System.currentTimeMillis());
    }
}
//Wristband产品族的具体产品
public class HWWristband implements Wristband {
    @Override
    public void displayTime() {
        System.out.println(&quot;小艺：&quot;+ System.currentTimeMillis());
    }
}
//XM具体工厂
public class XMFactory implements Factory {
    @Override
    public Phone phone() {
        return new XMPhone();
    }
    @Override
    public Wristband wristband() {
        return new XMWristband();
    }
}
//HW具体工厂
public class HWFactory implements Factory {
    @Override
    public Phone phone() {
        return new HWPhone();
    }
    @Override
    public Wristband wristband() {
        return new HWWristband();
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/abstructFactory.png" alt="abstructFactory" /></p>
<ul>
<li>优点：
<ul>
<li>具体产品在应用层的代码隔离，无需关心创建细节</li>
<li>将一个系列的产品统一到一起创建</li>
</ul>
</li>
<li>缺点：
<ul>
<li>规定了所有可能被创建的产品集合，产品族中扩展新产品困难</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
</li>
</ul>
<h3 id="建造者模式"><a class="header" href="#建造者模式">建造者模式</a></h3>
<ul>
<li>建造者模式属于创建型模式，它提供了一种创建对象的最佳方式</li>
<li>定义：将一个对象的结构与它的表示分离，使得同样的构建过程可以创建不同的表示</li>
<li>主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象</li>
<li>用户只需要给出指定复杂对象的类型和内容，创造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）</li>
<li>例子：
<ul>
<li>工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）</li>
<li>汽车购买者（用户）：你需要说出你需要的型号（对象的类型和内容），然后直接购买就可以使用了（不需要知道汽车是怎么组装的（车轮、车门、发动机、方向盘……））</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//产品
public class Car {
    private String engine;
    private String tires;
    private String glass;
    public String getEngine() {
        return engine;
    }
    public void setEngine(String engine) {
        this.engine = engine;
    }
    public String getTires() {
        return tires;
    }
    public void setTires(String tires) {
        this.tires = tires;
    }
    public String getGlass() {
        return glass;
    }
    public void setGlass(String glass) {
        this.glass = glass;
    }
    @Override
    public String toString() {
        return &quot;Car{&quot; +
            &quot;engine='&quot; + engine + '\'' +
            &quot;, tires='&quot; + tires + '\'' +
            &quot;, glass='&quot; + glass + '\'' +
            '}';
    }
}
//抽象建造者
public interface Builder&lt;T&gt; {
    Builder buildEngine();
    Builder buildTires();
    Builder buildGlass();
    T get();
}
//抽象组装者
public interface Director&lt;T&gt; {
    T build();
}
//具体建造者
public class CarBuilder implements Builder&lt;Car&gt; {
    private Car car;
    public CarBuilder() {
        this.car = new Car();
    }
    @Override
    public Builder buildEngine() {
        car.setEngine(&quot;A牌引擎&quot;);
        return this;
    }
    @Override
    public Builder buildTires() {
        car.setTires(&quot;B牌轮胎&quot;);
        return this;
    }
    @Override
    public Builder buildGlass() {
        car.setGlass(&quot;C牌玻璃&quot;);
        return this;
    }
    public Car get(){
        return this.car;
    }
}
//具体组装者
public class CarDirector implements Director&lt;Car&gt; {
    private Builder&lt;Car&gt; builder;
    public CarDirector(Builder&lt;Car&gt; builder) {
        this.builder = builder;
    }
    @Override
    public Car build() {
        builder.buildEngine().buildGlass().buildTires();
        return builder.get();
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="建造者模式" /></p>
<ul>
<li>优点：
<ul>
<li>产品建造和表示分离，实现类解耦，使用建造者模式可以是客户端不必知道产品内部的组成和细节</li>
<li>将复杂的产品的创建步骤分解在不同的方法中，使得创建过程更加清晰</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展，增加新的具体建造者无需修改原有的类库的代码，符合“开闭原则”</li>
</ul>
</li>
<li>缺点：
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此器十三亿范围受到一的限制
<ul>
<li>如果产品内部变化复杂，可能会导致需要定义很多具体的建造者来实现这种变化，导致系统变得很庞大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型模式"><a class="header" href="#原型模式">原型模式</a></h3>
<ul>
<li>
<p>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</p>
</li>
<li>
<p>就是java里的克隆技术，以某个对象为原型，复制出新的对象，显然，新的对象举要元对象的特点</p>
</li>
<li>
<p>优势：效率高（直接克隆，避免了重新执行构造过程步骤）</p>
</li>
<li>
<p>克隆类似new，但不同于new，new创建新的对象属性采用的是默认值，克隆出的对象的属性值完全可原型对象相同，并且克隆出的新对象改变不会影响原型对象，然后再修改原型对象的值</p>
</li>
<li>
<p>原型模式的实现：</p>
<ul>
<li>Cloneable接口和clone方法</li>
<li>Prototyoe模式中实现起来最困难的地方就是内存的复制操作，所幸在java中提供了clone（）方法替我们做了绝大部分的事情 </li>
</ul>
</li>
<li>
<p>浅克隆</p>
<pre><code class="language-java">//对象
public class Student implements Cloneable{
    private int id;
    private String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
//测试类
public class Client {
    @Test
    public void test01() throws CloneNotSupportedException {
        Student s1  = new Student(1, &quot;张三&quot;);
        System.out.println(s1);
        Student s2 = (Student) s1.clone();
        System.out.println(s2);
    }
}
</code></pre>
<ul>
<li>问题：当原型对象属性有引用类型时，只会将该引用类型的属性的指针克隆过去，设说明原型对象和新对象的那个引用类型属性都指向了同一个对象，一旦那个对象里面的值发生改变时，原型对象和新对象都会受到影响</li>
</ul>
<p><img src="java/design_pattern/../../assets/java/img/%E6%B5%85%E5%85%8B%E9%9A%86%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="浅克隆的问题" /></p>
</li>
<li>
<p>深克隆</p>
<ul>
<li>将原型对象里面的引用类型的属性在clone方法里也进行克隆</li>
</ul>
<pre><code class="language-java">@Override
protected Object clone() throws CloneNotSupportedException {
    Student clone = (Student) super.clone();
    clone.birthday = (Date) this.birthday.clone();
    return clone;
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E6%B7%B1%E5%85%8B%E9%9A%86.png" alt="深克隆" /></p>
</li>
<li>
<p>深克隆（序列化反序列化实现）</p>
<ul>
<li>**注意：**该类必须要实现Serializable接口</li>
</ul>
<pre><code class="language-java">//直接实现
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(s1);
oos.flush();
ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream ois = new ObjectInputStream(bis);
Student s2 = (Student) ois.readObject();
//或者在对象里面加方法实现
public Student deepClone(){
    ObjectOutputStream oos = null;
    ObjectInputStream ois = null;
    ByteArrayOutputStream bos = null;
    try {
        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
        oos.flush();
        ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        return (Student) ois.readObject();
    }catch (Exception e){
        e.printStackTrace();
        return null;
    }finally {
        release(bos, oos, ois);
    }
}
</code></pre>
</li>
</ul>
<h2 id="结构型模式"><a class="header" href="#结构型模式">结构型模式</a></h2>
<p>**作用：**从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题</p>
<h3 id="适配器模式"><a class="header" href="#适配器模式">适配器模式</a></h3>
<ul>
<li>
<p>将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作</p>
</li>
<li>
<p>模式中的角色</p>
<ul>
<li>目标接口（Target）：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口</li>
<li>需要适配的类（Adaptee）：需要适配的类或适配者类</li>
<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口</li>
</ul>
<pre><code class="language-java">//相当于客户
public class Phone {
    //播放音乐需要type-c接口的耳机
    public void playMusic(HeadsetByTypeC headsetByType_c){
        headsetByType_c.connection();
        System.out.println(&quot;播放音乐&quot;);
    }
}
//type-c接口的耳机（相当于目标接口target）
public interface HeadsetByTypeC {
    void connection();
}
//3.5毫米接口转type-c接口（相当于适配器adapter）
public class HeadsetAdapter implements HeadsetByTypeC {
    private HeadsetBy3_5mm headsetBy35mm;
    //需要一个耳机对象
    public HeadsetAdapter(HeadsetBy3_5mm headsetBy35mm) {
        this.headsetBy35mm = headsetBy35mm;
    }
    //该方法实现适配需要的操作
    @Override
    public void connection() {
        headsetBy35mm.connection();
    }
}
//3.5毫米类型的耳机（相当与被适配的类adaptee）
public class HeadsetBy3_5mm {
    public void connection(){
        System.out.println(&quot;连接成功！&quot;);
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-1597033069207.png" alt="适配器模式" /></p>
</li>
</ul>
<h3 id="代理模式"><a class="header" href="#代理模式">代理模式</a></h3>
<ul>
<li>作用：
<ul>
<li>通过代理，控制对象的访问</li>
<li>可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置操作，调用这个方法后做后置操作（即：AOP的微观实现）</li>
</ul>
</li>
<li>AOP（Aspect Oriented Programming面向切面编程）的核心实现机制</li>
<li>角色：
<ul>
<li>抽象角色：定义代理角色和真实角色的公共对外方法</li>
</ul>
</li>
<li>真实角色：
<ul>
<li>实现抽象角色，定义真实角色所需要实现的业务逻辑供代理类角色调用</li>
<li>关注真正的业务逻辑</li>
</ul>
</li>
<li>代理角色
<ul>
<li>实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象的方法，可以附加自己的操作</li>
<li>将同统一流程控制放到代理角色中处理</li>
</ul>
</li>
<li>静态代理</li>
</ul>
<pre><code class="language-java">//抽象角色
public interface Singer {
    void sing();
}
//真实角色
public class StarA implements Singer {

    private String name;

    public StarA(String name) {
        this.name = name;
    }

    @Override
    public void sing() {
        System.out.println(&quot;歌手&quot;+name +&quot;在唱歌！&quot;);
    }
}
//代理角色
public class Middleman implements Singer{
    private String name;
    private Singer singer;
    public void pay(){
        System.out.println(&quot;中介&quot;+name +&quot;收钱&quot;);
    }
    public void end(){
        System.out.println(&quot;中介&quot;+name +&quot;收尾&quot;);
    }
    @Override
    public void sing() {
        pay();
        singer.sing();
        end();
    }
    public Middleman(String name, Singer singer) {
        this.name = name;
        this.singer = singer;
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png" alt="静态代理" /></p>
<ul>
<li>动态代理
<ul>
<li>JDK自带的动态代理
<ul>
<li>java.lang.reflect.Proxy
<ul>
<li>作用：动态生成代理类和对象</li>
</ul>
</li>
<li>java.lang.reflect.InvocationHandler(处理器接口)
<ul>
<li>可以通过invkoe方法实现对真实角色的代理访问</li>
<li>每次通过Proxy生成代理类对象d时都要指定对应的处理器对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//抽象角色
public interface Singer {
    void sing();
}
//真实角色
public class StarA implements Singer {

    private String name;

    public StarA(String name) {
        this.name = name;
    }

    @Override
    public void sing() {
        System.out.println(&quot;歌手&quot;+name +&quot;在唱歌！&quot;);
    }
}
//获取代理角色的对象
public class MiddlemanMaker&lt;T&gt; implements InvocationHandler {
    private Object target;
    //前置事件
    private Runnable before;
    //后置事件
    private Runnable after;
    public void setBefore(Runnable before) {
        this.before = before;
    }
    public void setAfter(Runnable after) {
        this.after = after;
    }
    public MiddlemanMaker(Object target) {
        this.target = target;
    }
    public T getMiddleman(){
        return (T)Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                this);
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (before != null){
            before.run();
        }
        Object result = method.invoke(target, args);
        if (after != null){
            after.run();
        }
        return result;
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="动态代理" /></p>
<ul>
<li>AOP（Aspect Oriented Programming面向切面编程）
<ul>
<li>它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术，它是一种新的方法论，它是的对传统OOP编程的一种补充</li>
</ul>
</li>
</ul>
<h3 id="桥接模式"><a class="header" href="#桥接模式">桥接模式</a></h3>
<ul>
<li>处理多重继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使得各个维度可以独立的扩展在抽象层建立关联</li>
</ul>
<pre><code class="language-java">//品牌维度
public interface Brand {
    void sale();
}
//电脑维度
public class Computer {
    protected Brand brand;
    public Computer(Brand brand) {
        this.brand = brand;
    }
    public void sale(){
        brand.sale();
    }
}
//台式电脑
public class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }
    @Override
    public void sale() {
        super.sale();
        System.out.println(&quot;台式机&quot;);
    }
}
//笔记本电脑
public class Laptop extends Computer {
    public Laptop(Brand brand) {
        super(brand);
    }
    @Override
    public void sale() {
        super.sale();
        System.out.println(&quot;笔记本&quot;);
    }
}
//联想品牌
public class Lenovo implements Brand {
    @Override
    public void sale() {
        System.out.print(&quot;销售联想&quot;);
    }
}
//戴尔品牌
public class Dell implements Brand {
    @Override
    public void sale() {
        System.out.print(&quot;销售戴尔&quot;);
    }
}
</code></pre>
<p><img src="java/design_pattern/../../assets/java/img/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式" /></p>
<ul>
<li>桥接模式可以取代多层继承的方案，多层继承违背了单一职责原则，复用性较差，类的个数也非常多，桥接模式可以极大的减少子类的个数，从而降低管理和维护的成本</li>
<li>桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则</li>
</ul>
<h3 id="组合模式"><a class="header" href="#组合模式">组合模式</a></h3>
<ul>
<li>把部分和整体的关系用树形结构来表示，从而是客户端可以使用统一的方式处理部分对象和整体对象</li>
<li>核心：
<ul>
<li>抽象构件（Component）角色：定义了叶子和容器构件的共同点</li>
<li>叶子（Leaf）构建角色：无子节点</li>
<li>容器（Composite）构建角色：有容器特征，可以包含子节点 </li>
</ul>
</li>
</ul>
<h2 id="行为型模式"><a class="header" href="#行为型模式">行为型模式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javaweb"><a class="header" href="#javaweb">javaweb</a></h1>
<h3 id="webxml里面的头文件信息"><a class="header" href="#webxml里面的头文件信息">web.xml里面的头文件信息</a></h3>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="servletcontext类"><a class="header" href="#servletcontext类">ServletContext类</a></h3>
<pre><code class="language-java">//servlet上下文对象所有servlet程序都可以获取到这个类
ServletContext context = getServletContext();       
</code></pre>
<h4 id="setattribute"><a class="header" href="#setattribute">setAttribute</a></h4>
<pre><code class="language-java">//在该上下对象内存一个对象使servlet程序之间互相通信更加方便
context.setAttribute(&quot;name&quot;, &quot;张三&quot;);
</code></pre>
<h4 id="getinitparameter"><a class="header" href="#getinitparameter">getInitParameter</a></h4>
<ul>
<li>先在web.xml文件里面编写需要的信息</li>
</ul>
<pre><code class="language-xml">&lt;!--    可以配置web应用初始化所首需要的信息--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;需要的信息&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<ul>
<li>然后获取</li>
</ul>
<pre><code class="language-java">//获取在web.xml里面配置的信息
context.getInitParameter(&quot;url&quot;);
</code></pre>
<h4 id="getrequestdispatcher"><a class="header" href="#getrequestdispatcher">getRequestDispatcher</a></h4>
<pre><code class="language-java">//请求转发 将当前servlet获取到的的请求转发到指定的servlet进行处理
context.getRequestDispatcher(&quot;/w&quot;).forward(req, resp);
</code></pre>
<h4 id="maven配置的一个问题"><a class="header" href="#maven配置的一个问题">Maven配置的一个问题</a></h4>
<pre><code class="language-xml">&lt;!--    在build里配置resources,防止支援导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h4 id="getresourceasstream"><a class="header" href="#getresourceasstream">getResourceAsStream</a></h4>
<pre><code class="language-java">//获取当前项目resource目录里面的资源文件
context.getResourceAsStream(&quot;/WEB-INF/classes/info.properties&quot;);
</code></pre>
<h3 id="http响应"><a class="header" href="#http响应">HTTP响应</a></h3>
<ul>
<li>服务器--&gt;响应--&gt;客户端</li>
</ul>
<p>百度：</p>
<pre><code>Cache-Control:private   缓存控制
Connection:Keep-Alive   连接
Content-Encoding:gzip   编码
Content-Type:text/html  类型
</code></pre>
<p>1.响应体</p>
<pre><code>Accept：             告诉浏览器，他支持所有的数据类型
Accept-Encoding：    支持那种编码格式：GBK、UTF-8、GB2312、ISO8895-1
Accept-language：    告诉浏览器语言环境
Cache-Control：      缓存控制
Connection：         告诉浏览器，请求完成后是断开还是保持连接
HOST：               主机
Refersh：            告诉客户端，多久刷新一次
Locatoin：           让网页重新定位
</code></pre>
<ol start="2">
<li>响应的状态码
<ul>
<li>200：请求响应成功</li>
<li>3xx：请求重定向
<ul>
<li>重定向： 你重新到我给你的新位置去</li>
</ul>
</li>
<li>4xx：资源找不到 404
<ul>
<li>资源不存在</li>
</ul>
</li>
<li>5xx：服务器代码错误 500 502：网关错误</li>
</ul>
</li>
</ol>
<p><strong>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，和一个代表响应的HttpServletResponse对象</strong></p>
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest</li>
<li>如果要给客户端响应一些数据：找HttpServletResponse</li>
</ul>
<h3 id="httpservletresponse"><a class="header" href="#httpservletresponse">HttpServletResponse</a></h3>
<p><strong>负责向浏览器发送数据的方法</strong></p>
<pre><code class="language-java">public ServletOutputStream getOutputStream() throws IOException;
public PrintWriter getWriter() throws IOException;
</code></pre>
<p><strong>负责向浏览器发送响应头的方法</strong></p>
<pre><code class="language-java">public void setCharacterEncoding(String charset);
public void setContentLength(int len);
public void setContentLengthLong(long len);
public void setContentType(String type);
public void setDateHeader(String name, long date);
public void addDateHeader(String name, long date);
public void setHeader(String name, String value);
public void addHeader(String name, String value);
public void setIntHeader(String name, int value);
public void addIntHeader(String name, int value);
</code></pre>
<p>####功能</p>
<ol>
<li>
<p>向页面输出信息	</p>
</li>
<li>
<p>下载文件</p>
</li>
</ol>
<pre><code class="language-java">//获取文件路径
String realPath = getServletContext().getRealPath(&quot;/WEB-INF/classes/张三.png&quot;);
//获取文件名
String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
//设置响应头文件名需要进行重新编码
resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;));
//获取输入流
FileInputStream fis = new FileInputStream(realPath);
//获取输出流
ServletOutputStream os = resp.getOutputStream();
//输出操作
byte[] buffer = new byte[1024];
int len = 0;
while ((len = fis.read(buffer)) &gt; 0){
    os.write(buffer, 0, len);
    os.flush();
}
//关闭流
fis.close();
os.close();
</code></pre>
<ol start="3">
<li>验证码功能</li>
</ol>
<pre><code class="language-java">//设置页面每过5秒刷新一次
resp.setHeader(&quot;Refresh&quot;, &quot;5&quot;);
//创建一张图片
BufferedImage bi = new BufferedImage(200, 70, BufferedImage.TYPE_INT_RGB);
//获取画笔
Graphics2D graphics = (Graphics2D) bi.getGraphics();
//设置画笔颜色
graphics.setColor(Color.WHITE);
//填充背景颜色
graphics.fillRect(0, 0, 200, 80);
//再次设置画笔颜色
graphics.setColor(Color.BLUE);
//设置字体类型
graphics.setFont(new Font(null, Font.BOLD, 30));
//画上一个字符串
graphics.drawString(getVerification(), 40, 40);
//设置浏览器打开的格式
resp.setHeader(&quot;Content-Type&quot;, &quot;image/png&quot;);
//不让网站缓存
resp.setDateHeader(&quot;expires&quot;, -1);
resp.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
resp.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
//把图片写给浏览器
ImageIO.write(bi, &quot;png&quot;, resp.getOutputStream());
</code></pre>
<p>4.实现重定向</p>
<p>一个web资源收到客户端请求后，它会通知客户端去访问另一个web资源，这个过程叫重定向</p>
<pre><code class="language-java">/*重定向
        相当于：
        resp.setHeader(&quot;Location&quot;, &quot;/st/img&quot;);
        resp.setStatus(302);*/
resp.sendRedirect(&quot;/st/img&quot;);
</code></pre>
<h3 id="httpservletrequest"><a class="header" href="#httpservletrequest">HttpServletRequest</a></h3>
<p>HttpServletRequest代表客户端的请求，用户通过http协议访问服务器，http请求的所有信息会被封装到HttpServletRequest，
通过HttpServletRequest里面的方法，获得客户端的所有信息</p>
<p>1.获取前端传递的参数</p>
<pre><code class="language-java">//获取一个参数
public String getParameter(String name);
//获取一组参数
public String[] getParameterValues(String name);
</code></pre>
<p>2.请求转发</p>
<pre><code class="language-java">//转发
public RequestDispatcher getRequestDispatcher(String path);
</code></pre>
<ul>
<li>重定向和转发的区别
<ul>
<li>相同点：
<ul>
<li>页面都会实现跳转</li>
</ul>
</li>
<li>不同点：
<ul>
<li>请确转发是url不会发生变化 307</li>
<li>重定向url会改变 302</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="cookiesession"><a class="header" href="#cookiesession">Cookie、Session</a></h3>
<h4 id="会话"><a class="header" href="#会话">会话</a></h4>
<ul>
<li>会话：用户打开一个浏览器，点击了很多超链接，访问了多个web资源，关闭浏览器，这个过程称为会话 </li>
<li>有状态会话：一个同学来过教室，下次再来教室，我们知道它曾经来过这成为有状态会话</li>
<li>一个网站，怎么证明你来过
<ul>
<li>服务端给客户端一个信件，客户端下次访问服务端时带上信件就可以了 cookie</li>
<li>服务端登记你来过，下次来的时候进行匹配 session</li>
</ul>
</li>
</ul>
<h4 id="保存会话的两种技术"><a class="header" href="#保存会话的两种技术">保存会话的两种技术</a></h4>
<ul>
<li>cookie
<ul>
<li>客户端技术（响应、请求）</li>
</ul>
</li>
<li>session
<ul>
<li>服务器技术，利用这个技术可以保存用户的会话信息，我们可以把信息或数据存在session中</li>
</ul>
</li>
</ul>
<p>常见应用：网站登录后，下一次不需要登录，直接访问</p>
<h4 id="cookie"><a class="header" href="#cookie">Cookie</a></h4>
<p>1.从请求中拿到cookie信息
2.服务器响应给客户端的cookie</p>
<pre><code class="language-java">//获得cookie
req.getCookies();
//获得cookie里面的键
cookie.getName();
//获得cookie里面的值
cookie.getValue();
//创建cookie
new Cookie(key, value);
//设置cookie的有效期
cookie.setMaxAge(时间);
//给客户端响应一个cookie
resp.addCookie(目标cookie);   
</code></pre>
<p>cookie文件一般会保存在用户目录下的appdata文件夹里面</p>
<ul>
<li>
<p>一个网站的cookie是否存在上限</p>
<ul>
<li>一个cookie只能保存一个信息</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie</li>
<li>cookie大小有限制20kb</li>
<li>cookie的浏览器上限未300个</li>
</ul>
</li>
<li>
<p>删除cookie</p>
<ul>
<li>不设置cookie的有效期，关闭浏览器后cookie自动失效</li>
<li>给cookie设置有效期为0</li>
</ul>
</li>
<li>
<p>编码解码</p>
</li>
</ul>
<pre><code class="language-java">    //编码
    URLEncoder.encode(目标字符串, charset);
    //解码
    URLDecoder.decode(目标字符串, charset)
</code></pre>
<h4 id="session"><a class="header" href="#session">Session</a></h4>
<ul>
<li>
<p>什么是session</p>
<ul>
<li>服务器会给每个用户（浏览器）创建一个session对象</li>
<li>一个session独占一个浏览器，只要浏览器没有关闭，这个session就存在</li>
<li>用户登录后整个网站都可以访问  保存用户信息、保存购物车信息等</li>
</ul>
</li>
<li>
<p>session和cookie的区别</p>
<ul>
<li>cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）</li>
<li>session把用户的数据写到用户独占的session里，服务端保存（保存重要的信息，避免服务器资源浪费）</li>
<li>session对象由服务器创建</li>
</ul>
</li>
<li>
<p>使用session</p>
</li>
</ul>
<pre><code class="language-java">//获取session
req.getSession();
//给session内存数据
session.setAttribute(key, value);
//获取session的id
session.getId();
//判断session是不是新创建的
session.isNew();
/*
    session创建的时候会把session的id放入cookie内，响应个客户端
    resp.addCookie(new Cookie(&quot;JSESSIONID&quot;, session.getId()));    
*/  
//移除session里面的数据
session.removeAttribute(&quot;数据对应的key&quot;);
//手动注销session
session.invalidate();
</code></pre>
<ul>
<li>设置session的过期时间，在web.xml里面配置</li>
</ul>
<pre><code class="language-xml">&lt;session-config&gt;
    &lt;session-timeout&gt;时间单位为分钟&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<h3 id="jsp"><a class="header" href="#jsp">JSP</a></h3>
<ul>
<li>什么是JSP
<ul>
<li>Java Server Pages: java服务器端页面，也和Servlet一样，用于动态web技术</li>
<li>特点
<ul>
<li>写jsp就像是在写Html代码</li>
<li>区别;
<ul>
<li>HTML只给用户提供静态数据</li>
<li>jsp页面中可以嵌入java代码，为用户提供动态数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JSP原理
<ul>
<li>jsp是怎么执行的
<ul>
<li>代码层面没有任何问题</li>
<li>服务器内部工作
<ul>
<li>tomcat中有一个work目录</li>
<li>IDEA使用tomcat会在tomcat中生成一个work目录（在C盘用户目录下idea配置文件里面）</li>
<li>C:\Users\yf.IntelliJIdea2019.3\system\tomcat\Unnamed_projectTest\work\Catalina\localhost\st\org\apache\jsp</li>
</ul>
</li>
<li>浏览器不论访问什么资源，都是在访问Servlet
<ul>
<li>jsp最终会被转换为一个java类</li>
<li>jsp本质上就是一个servlet</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//初始化
public void _jspInit() {
}
//销毁
public void _jspDestroy() {
}
//jspservice
public void _jspService(HttpServletRequest request, HttpServletResponse response){
}
</code></pre>
<ol>
<li>请求判断</li>
<li>内置的一些对象</li>
</ol>
<pre><code class="language-java">    final javax.servlet.jsp.PageContext pageContext;    //页面上下文   
    javax.servlet.http.HttpSession session = null;      //session
    final javax.servlet.ServletContext application;     //applicationContext
    final javax.servlet.ServletConfig config;           //config
    javax.servlet.jsp.JspWriter out = null;             //out
    final java.lang.Object page = this;                 //当前页面
    HttpServletRequest request                          //请求
    HttpServletResponse response                        //响应     
</code></pre>
<ol start="3">
<li>页面输出前增加的代码</li>
</ol>
<pre><code class="language-java">      response.setContentType(&quot;text/html;charset=UTF-8&quot;);       //设置相应页面的类型
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;
</code></pre>
<h3 id="jsp语法"><a class="header" href="#jsp语法">JSP语法</a></h3>
<ul>
<li>jsp表达式</li>
</ul>
<pre><code class="language-jsp">输出到客户端
&lt;%= 变量或表达式%&gt;
</code></pre>
<ul>
<li>jsp脚本片段</li>
</ul>
<pre><code class="language-jsp">&lt;%java代码%&gt;
</code></pre>
<ul>
<li>jsp声明</li>
</ul>
<pre><code class="language-jsp">&lt;%!字段、方法、代码块%&gt;
</code></pre>
<ul>
<li>jsp标签</li>
</ul>
<pre><code>拼接页面
//将导入的页面与当前页面和二为一
//会导致多个页面里定义的变量冲突
&lt;%@include file=路径%&gt;
//页面拼接，本质上还是多个页面
&lt;jsp:include page=路径/&gt;
</code></pre>
<ul>
<li>9大内置对象
<ul>
<li>PageContext</li>
<li>Request</li>
<li>Response</li>
<li>Session</li>
<li>Application 就是ServletContext</li>
<li>config</li>
<li>out</li>
<li>page</li>
<li>exception</li>
</ul>
</li>
<li>四大域里面保存的数据的范围</li>
</ul>
<pre><code>    //保存的数据，只存在当前页面有效
    pageContext.setAttribute(&quot;key01&quot;, &quot;value01&quot;);
    //保存的数据，在请求中有效，请求转发1会携带这个数据
    request.setAttribute(&quot;key02&quot;, &quot;value02&quot;);
    //保存的数据，在一次会话中有效，从打开浏览器到关闭浏览器
    session.setAttribute(&quot;key03&quot;, &quot;value03&quot;);
    //保存的数据，在服务器中有效，从打开服务器到关闭服务器
    application.setAttribute(&quot;key04&quot;, &quot;value04&quot;);
</code></pre>
<h3 id="mvc三层架构"><a class="header" href="#mvc三层架构">MVC三层架构</a></h3>
<p>MVC：Model、View、Controller，模型、视图、控制器</p>
<ul>
<li>早些年：
<ul>
<li>用户直接访问控制层，控制层就可以直接操作数据库</li>
<li>servlet--&gt;CRUD--&gt;数据库</li>
<li>弊端：
<ul>
<li>程序臃肿、不利于维护</li>
<li>servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码</li>
</ul>
</li>
</ul>
</li>
<li>MVC三层架构
<ul>
<li>Model
<ul>
<li>业务处理：业务逻辑（service）</li>
<li>数据持久层：CRUD（Dao）</li>
</ul>
</li>
<li>View
<ul>
<li>展示数据</li>
<li>提供链接发起servlet请求</li>
</ul>
</li>
<li>Controller
<ul>
<li>接收用户的请求：（request的请求参数、session信息）</li>
<li>交给业务层处理对应的代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<ol>
<li>编写过滤器</li>
</ol>
<pre><code class="language-java">public class CharacterFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        System.out.println(&quot;过滤前&quot;);
        chain.doFilter(request, response);
        System.out.println(&quot;过滤后&quot;);
    }
}
</code></pre>
<ol start="2">
<li>web.xml下配置</li>
</ol>
<pre><code class="language-xml">    &lt;filter&gt;
            &lt;filter-name&gt;CharacterFilter&lt;/filter-name&gt;
            &lt;filter-class&gt;com.hb.filter.CharacterFilter&lt;/filter-class&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;CharacterFilter&lt;/filter-name&gt;
            &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mybatis"><a class="header" href="#mybatis">Mybatis</a></h1>
<h2 id="pojo工具类"><a class="header" href="#pojo工具类">pojo工具类</a></h2>
<pre><code class="language-java">package com.yang.utils;

import org.apache.ibatis.session.SqlSession;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

/**
 * @auther YF
 * @create 2020-07-30-20:48
 */
public class PojoUtils {

    private static String showTables = &quot;show tables&quot;;

    private static String desTable = &quot;describe &quot;;

    private static String packageName;

    private static StringBuilder sb;

    private static ArrayList&lt;String&gt; fieldNames;

    private static ArrayList&lt;String&gt; fieldTypes;

    private static String empty = &quot; &quot;;

    private static String table = &quot;\t&quot;;

    private static String nextLine = &quot;\n&quot;;

    static {
        String name = PojoUtils.class.getPackage().getName();
        String substring = name.substring(0, name.lastIndexOf(&quot;.&quot;) + 1);
        packageName = substring + &quot;pojo&quot;;
    }

    private static String getPath(){
        return packageName.replace(&quot;.&quot;, &quot;/&quot;);
    }

    public static void initPojo(Connection connection, String packageN){
        if (packageN != null || !&quot;&quot;.equals(packageN.trim())){
            packageName = packageN;
        }
        initPojo(connection);
    }

    public static void initPojo(SqlSession sqlSession, String packageN){
        if (packageN != null || !&quot;&quot;.equals(packageN.trim())){
            packageName = packageN;
        }
        initPojo(sqlSession);
    }

    public static void initPojo(Connection connection) {
        try(PreparedStatement statement = connection.prepareStatement(showTables);
            ResultSet rs = statement.executeQuery()) {
            while (rs.next()){
                String tableName = rs.getString(1);
                initPOJOFields(connection ,tableName);
            }
        }catch (Exception e){
            e.printStackTrace();
            System.out.println(&quot;pojo 初始化失败！&quot;);
        }
    }

    public static void initPojo(SqlSession sqlSession) {
        try {
            Connection connection = sqlSession.getConfiguration().getEnvironment().getDataSource().getConnection();
            initPojo(connection);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            sqlSession.close();
        }
    }

    public static void deletePojo(){
        File file = new File(&quot;src/main/java/&quot; + getPath());
        if (file.exists()) {
            File[] files = file.listFiles();
            for (File file1 : files) {
                file1.delete();
            }
            file.delete();
        }
    }

    public static void rebuildPojo(Connection connection){
        deletePojo();
        initPojo(connection);
    }
    public static void rebuildPojo(SqlSession sqlSession){
        deletePojo();
        initPojo(sqlSession);
    }

    private static void initPOJOFields(Connection connection,String tableName) {
        if (fieldNames == null){
            fieldNames = new ArrayList&lt;&gt;();
        }else {
            fieldNames.clear();
        }
        if (fieldTypes == null){
            fieldTypes = new ArrayList&lt;&gt;();
        }else {
            fieldTypes.clear();
        }
        try(PreparedStatement statement = connection.prepareStatement(desTable + tableName);
            ResultSet rs = statement.executeQuery()) {
            while (rs.next()){
                fieldNames.add(headToLower(rs.getString(1)));
                String fileType = rs.getString(2);
                if (fileType.startsWith(&quot;char&quot;) || fileType.startsWith(&quot;varchar&quot;)){
                    fieldTypes.add(&quot;String&quot;);
                }else if (fileType.startsWith(&quot;int&quot;)){
                    fieldTypes.add(&quot;int&quot;);
                }else if (fileType.startsWith(&quot;double&quot;)){
                    fieldTypes.add(&quot;double&quot;);
                }else if (fileType.startsWith(&quot;longblob&quot;)){
                    fieldTypes.add(&quot;byte[]&quot;);
                }else if (fileType.startsWith(&quot;timestamp&quot;)){
                    fieldTypes.add(&quot;java.util.Date&quot;);
                }
            }
            createPojo(tableName);

        }catch (Exception e){
            e.printStackTrace();
        }
    }

    private static void createPojo(String tableName) {
        File file = new File(&quot;src/main/java/&quot; + getPath());
        if (!file.exists()){
            file.mkdir();
        }
        String className = headToUpper(tableName);
        String path = file.getAbsolutePath() + &quot;/&quot; + className + &quot;.java&quot;;
        try(BufferedWriter fos = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path)))){
            String classFile = getClassFile(className);
            fos.write(classFile);
            fos.flush();
        }catch (Exception e){
            e.printStackTrace();
        }
    }x
    /**
     * 建造类的核心方法
     * @param className
     * @return
     */
    private static String getClassFile(String className) {
        if (sb == null) {
            sb = new StringBuilder();
        }else {
            sb.delete(0, sb.length());
        }
        sb.append(&quot;package &quot;).append(packageName).append(&quot;;&quot;).append(nextLine);
        sb.append(&quot;public class &quot;).append(className).append(empty).append(&quot;implements java.io.Serializable&quot;)
            .append(&quot;{&quot;).append(nextLine);
        appendFields();
        appendEmptyConstructor(className);
        appendGetterAndSetter();
        appendToString(className);
        sb.append(&quot;}&quot;);
        return sb.toString();
    }
    /**
     * 生成属性
     */
    private static void appendFields(){
        for (int i = 0; i &lt; fieldNames.size(); i++) {
            sb.append(table).append(&quot;private &quot;).append(fieldTypes.get(i)).append(empty)
                .append(fieldNames.get(i)).append(&quot;;&quot;).append(nextLine);
        }
    }
    /**
     * 生成空参构造方法
     * @param className
     */
    private static void appendEmptyConstructor(String className){
        sb.append(table).append(&quot;public &quot;).append(className).append(&quot;(){}&quot;).append(nextLine);
    }

    /**
     * 生成get和set方法
     */
    private static void appendGetterAndSetter(){
        for (int i = 0; i &lt; fieldNames.size(); i++) {
            sb.append(table).append(&quot;public &quot;).append(fieldTypes.get(i)).append(empty)
                .append(&quot;get&quot;).append(headToUpper(fieldNames.get(i))).append(&quot;(){&quot;).append(nextLine)
                .append(table).append(table).append(&quot;return this.&quot;).append(fieldNames.get(i))
                .append(&quot;;&quot;).append(nextLine).append(table).append(&quot;}&quot;).append(nextLine);
            sb.append(table).append(&quot;public void &quot;).append(&quot;set&quot;).append(headToUpper(fieldNames.get(i)))
                .append(&quot;(&quot;).append(fieldTypes.get(i)).append(empty).append(&quot;value&quot;)
                .append(&quot;){&quot;).append(nextLine).append(table).append(table).append(&quot;this.&quot;)
                .append(fieldNames.get(i)).append(empty).append(&quot;=&quot;).append(empty)
                .append(&quot;value;&quot;).append(nextLine).append(table).append(&quot;}&quot;).append(nextLine);
        }
    }

    /**
     * 生成toString
     * @param className
     */
    private static void appendToString(String className){
        sb.append(table).append(&quot;@Override&quot;).append(nextLine);
        sb.append(table).append(&quot;public String toString() {&quot;).append(nextLine);
        sb.append(table).append(table).append(&quot;return &quot;).append(&quot;\&quot;&quot;)
            .append(className).append(&quot;{&quot;);
        for (int i = 0; i &lt; fieldNames.size(); i++) {
            sb.append(i &gt; 0 ? &quot;\&quot;, &quot; : &quot;&quot;).append(fieldNames.get(i)).append(&quot;='\&quot;+&quot;);
            sb.append(fieldNames.get(i)).append(&quot;+\&quot;'&quot;)
                .append(&quot;\&quot;+&quot;)
                .append(nextLine).append(table).append(table);
        }
        sb.append(&quot;\&quot;}&quot;).append(&quot;\&quot;;&quot;).append(nextLine);

        sb.append(table).append(&quot;}&quot;).append(nextLine);
    }

    private static String headToUpper(String t){
        return t.substring(0, 1).toUpperCase() + t.substring(1);
    }
    private static String headToLower(String t){
        return t.substring(0, 1).toLowerCase() + t.substring(1);
    }
}
</code></pre>
<h2 id="xml文件骨架"><a class="header" href="#xml文件骨架">xml文件骨架</a></h2>
<h2 id="核心配置"><a class="header" href="#核心配置">核心配置</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;用户名&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;密码&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="mapper配置"><a class="header" href="#mapper配置">mapper配置</a></h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;dao接口的全限定名&quot;&gt;
    &lt;select id=&quot;对应的方法名&quot; resultType=&quot;返回结果的全限定名&quot;&gt;
    	sql语句
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<ul>
<li>MyBatis是一款优秀的持久层框架</li>
<li>它支持定制化SQL.存储过程以及高级映射。</li>
<li>MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li>
<li>MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO (Plain Old JavaObjects， 普通老式Java对象)为数据库中的记录。</li>
<li>MyBatis本是apache的一一个开源项目iBatis, 2010年这个项目由apache software foundation迁移到了google code,并且改名为MyBatis 。</li>
<li>2013年11月迁移到Github。</li>
</ul>
<h3 id="获取"><a class="header" href="#获取">获取</a></h3>
<ul>
<li>maven仓库:</li>
</ul>
<pre><code class="language-xml">&lt;!-- https ://mvnrepository. com/artifact/org. mybatis/mybatis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org. mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>Github : https://github.com/mybatis/mybatis-3/releases</li>
<li>中文文档: https://mybatis.org/mybatis-3/zh/index.html</li>
</ul>
<h3 id="持久化"><a class="header" href="#持久化">持久化</a></h3>
<p>数据持久化</p>
<ul>
<li>
<p>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</p>
</li>
<li>
<p>内存:断电即失</p>
</li>
<li>
<p>数据库(Jdbc), io文件持久化。</p>
</li>
</ul>
<h3 id="持久层"><a class="header" href="#持久层">持久层</a></h3>
<p>Dao层，Service层， Controller层……</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界限十分明显。</li>
</ul>
<h2 id="mybatis程序"><a class="header" href="#mybatis程序">Mybatis程序</a></h2>
<blockquote>
<p>jdbc url</p>
</blockquote>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/session1?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
</code></pre>
<ul>
<li>编写配置：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;用户名&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;密码&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>编写获取SqlSession的工具类</li>
</ul>
<pre><code class="language-java">public class JDBCUtils {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try(InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;mybatis-info.xml&quot;)){
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        }catch (Exception e){
            e.printStackTrace();
            throw new RuntimeException(&quot;connection failed!&quot;);
        }
    }
    public static SqlSession getSqlSession(){
        return sqlSessionFactory.openSession();
    }
}
</code></pre>
<ul>
<li>
<p>编写代码</p>
<ul>
<li>编写实体类</li>
<li>编写dao接口</li>
</ul>
<pre><code class="language-java">public interface UserDao {
    List&lt;Users&gt; getUser();
}
</code></pre>
<ul>
<li><del>编写dao接口实现类</del></li>
<li>编写对应的mapper配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;dao接口的全限定名&quot;&gt;
    &lt;select id=&quot;对应的方法名&quot; resultType=&quot;返回结果的全限定名&quot;&gt;
    	sql语句
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-java">@Test
public void testGetUser(){
    //获取sqlSession对象
    SqlSession sqlSession = JDBCUtils.getSqlSession();
    //获取对应的dao对象
    UserDao mapper = sqlSession.getMapper(UserDao.class);
    //执行得到结果
    List&lt;Users&gt; user = mapper.getUser();
    for (Users users : user) {
        System.out.println(users.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
</li>
</ul>
<h2 id="crud"><a class="header" href="#crud">CRUD</a></h2>
<ul>
<li>
<p>namespace</p>
<ul>
<li>namespace中的包名要和Dao/mapper接口的包名一致</li>
</ul>
</li>
<li>
<p><strong>select</strong></p>
<ul>
<li>id：就是对应的namespace中的方法名</li>
<li>resultType：sql语句执行的返回值</li>
<li>paramterType：参数类型</li>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users where users.userId = #{id}
&lt;/select&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testGetUser(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List&lt;Users&gt; user = mapper.getUser();
    for (Users users : user) {
        System.out.println(users.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
</li>
<li>
<p><strong>insert</strong></p>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.yang.pojo.Users&quot;&gt;
    insert into users (email, password) values (#{Email}, #{Password})
&lt;/insert&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testInsertUser(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();
    Users users = new Users();
    users.setEmail(&quot;fsafaefwea&quot;);
    users.setPassword(&quot;fdsfsse&quot;);
    int i = mapper.insertUser(users);
    //提交事务
    sqlSession.commit();
    sqlSession.close();
    System.out.println(&quot;修改&quot;+(i &gt; 0 ? &quot;成功！&quot; : &quot;失败！&quot;));
}
</code></pre>
</li>
<li>
<p><strong>delete</strong></p>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from users where users.userId = #{id}
&lt;/delete&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testDeleteUser(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();
    int i = mapper.deleteUser(105);
    //提交事务
    sqlSession.commit();
    sqlSession.close();
    System.out.println(&quot;修改&quot;+(i &gt; 0 ? &quot;成功！&quot; : &quot;失败！&quot;));
}
</code></pre>
</li>
<li>
<p><strong>update</strong></p>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;java.util.Map&quot;&gt;
    update users set users.password = #{pwd}, users.email = #{email}
    where users.userId = #{id}
&lt;/update&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testUpdateUser(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();
    hashMap.put(&quot;pwd&quot;, &quot;123456&quot;);
    hashMap.put(&quot;email&quot;, &quot;behappy@vip.sina.com&quot;);
    hashMap.put(&quot;id&quot;, 1);
    int i = mapper.updateUser(hashMap);
    //提交事务
    sqlSession.commit();
    sqlSession.close();
    System.out.println(&quot;修改&quot;+(i &gt; 0 ? &quot;成功！&quot; : &quot;失败！&quot;));
}
</code></pre>
</li>
<li>
<p>注意：增删改需要提交事务</p>
</li>
<li>
<p>假设,我们的实体类，或者数据库中的表，字段或者参数过多,我们应当考虑使用Map</p>
</li>
<li>
<p>模糊查询</p>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserByFirstName&quot; parameterType=&quot;String&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users where users.firstName like '%' #{id} '%'
&lt;/select&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testGetUserByEmail(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List&lt;Users&gt; a = mapper.getUserByFirstName(&quot;ia&quot;);
    for (Users users : a) {
        System.out.println(users.getFirstName() + &quot; &quot; + users.getLastName());
    }
    sqlSession.close();
}
</code></pre>
</li>
</ul>
<h2 id="配置解析"><a class="header" href="#配置解析">配置解析</a></h2>
<p><strong>核心配置文件</strong></p>
<ul>
<li>mybatis-config.xml</li>
<li>MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。</li>
</ul>
<pre><code class="language-xml">configuration (配置)
properties (属性)
settings (设置)
typeAliases (类型别名)
typeHandlers (类型处理器)
objectFactory (对象工厂)
plugins (插件)
environments (环境配置)
environment (环境变量)
transactionManager (事务管理器)
datasource (数据源)
</code></pre>
<h3 id="环境配置environments"><a class="header" href="#环境配置environments">环境配置(environments)</a></h3>
<p>MyBatis可以配置成适应多种环境</p>
<p>尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境</p>
<p>Mybatis默认的事务管理器就是JDBC，连接池: POOLED</p>
<h3 id="属性-properties"><a class="header" href="#属性-properties">属性. (properties)</a></h3>
<p>我们可以通过properties属性来实现引用配置:文件</p>
<p>这些属性都是可外部配置且可动态替换的，既可以在典型的Java属性文件中配置,亦可通过properties元素的子元素来传递。[db.properties]</p>
<ul>
<li>编写一个配置文件</li>
</ul>
<pre><code class="language-properties">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/session1?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
username=root
password=112358
</code></pre>
<ul>
<li>在核心配置文件中引入
<ul>
<li>properties标签必须在configuration标签内的最前面</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;properties resource=&quot;db.properties&quot;/&gt;
</code></pre>
<ul>
<li>可以直接引入外部文件</li>
<li>可以在其中增加一-些属性配置</li>
<li>如果两个文件有同一个字段，优先使用外部配置文件的</li>
</ul>
<h3 id="类型别名typealiases"><a class="header" href="#类型别名typealiases">类型别名(typeAliases)</a></h3>
<ul>
<li>类型别名是为Java类型设置一 个短的名字。</li>
<li>存在的意义仅在于用来减少类完全限定名的冗余。</li>
</ul>
<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.yang.pojo.Users&quot; alias=&quot;user&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<ul>
<li>也可以指定一个包名， MyBatis 会在包名下面搜索需要的Java Bean</li>
<li>扫描实体类的包，它的默认别名就为这个类的类名，首字母小写</li>
</ul>
<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;package name=&quot;com.yang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<ul>
<li>在实体类比较少的时候，使用第一种方式。</li>
<li>如果实体类十分多,建议使用第二种。</li>
<li>第一种可以DIY别名，第二种则.不行，如果非要改，需要在实体.上增加注解</li>
</ul>
<pre><code class="language-xml">@Alias(&quot;别名&quot;)
public class Users {
}
</code></pre>
<h3 id="设置"><a class="header" href="#设置">设置</a></h3>
<ul>
<li>这是MyBatis中极为重要的调整设置，它们会改变MyBatis的运行时行为。</li>
</ul>
<h3 id="其他配置"><a class="header" href="#其他配置">其他配置</a></h3>
<ul>
<li>typeHandlers (类型处理器)</li>
<li>objectFactory_ (对象工厂)</li>
<li>plugins插件
<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
</ul>
</li>
<li>通用mapper</li>
</ul>
<h3 id="映射器mappers"><a class="header" href="#映射器mappers">映射器（mappers）</a></h3>
<p>MapperRegistry:注册绑定我们的Mapper文件;</p>
<ul>
<li>方式一:</li>
</ul>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper resource=对应xml的路径/&gt;
&lt;/mappers&gt;
</code></pre>
<ul>
<li>方式二:使用class文件绑定注册
<ul>
<li>接口和他的Mapper配置文件必须同名</li>
<li>接口和他的Mapper配置文件必须在同一一个包下</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=对应类的全限定名/&gt;
&lt;/mappers&gt;
</code></pre>
<ul>
<li>方式三:使用扫描包进行注入绑定
<ul>
<li>和方式二需要注意的顶一样</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;package name=对应类的包名/&gt;
&lt;/mappers&gt;
</code></pre>
<h2 id="生命周期和作用域"><a class="header" href="#生命周期和作用域">生命周期和作用域</a></h2>
<p><img src="java/SSM/../../assets/java/img/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="mybatis生命周期" /></p>
<p><strong>生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。</strong></p>
<ul>
<li>
<p><strong>SqlSessionFactorybuilder</strong></p>
<ul>
<li>一旦创建了SqlSessionFactory, 就不再需要它了</li>
<li>局部变量</li>
</ul>
</li>
<li>
<p><strong>SqISessionFactory</strong></p>
<ul>
<li>可以想象为数据库连接池</li>
<li>SqlSessionFactory - -旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例</li>
<li>因此SqlSessionFactory的最佳作用域是应用作用域</li>
<li>最简单的就是使用单例模式或者静态单例模式</li>
</ul>
</li>
<li>
<p><strong>SqlSession</strong></p>
<ul>
<li>连接到连接池的一一个请求</li>
<li>SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li>
<li>用完之后需要赶紧关闭，否则资源被占用</li>
</ul>
</li>
</ul>
<p>**这里面的每一个Mapper, 就代表一个具体的业务 **</p>
<h2 id="resultmap"><a class="header" href="#resultmap">ResultMap</a></h2>
<p><strong>解决属性名和字段名不一致的问题</strong></p>
<p>解决方法：</p>
<ul>
<li>起别名（在sql层面直接起别名）</li>
<li>使用resultMap
<ul>
<li>resu1tMap元素是MyBatis中最重要最强大的元素</li>
<li>ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂-一点的语句只需要描述它们的关系就行了。</li>
<li>ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;resultMap id=&quot;mapId&quot; type=&quot;对应的实体类&quot;&gt;
    &lt;!--        将实体类的字段名也数据库表的列名对应起来--&gt;
    &lt;result column=&quot;数据库内的列名&quot; property=&quot;对应实体类的字段名&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<h2 id="日志-1"><a class="header" href="#日志-1">日志</a></h2>
<h3 id="日志工厂"><a class="header" href="#日志工厂">日志工厂</a></h3>
<p>如果一个数据库操作，出现了异常,我们需要排错。日志就是最好的助手!</p>
<p>曾经: sout、 debug</p>
<p>现在:日志工厂</p>
<ul>
<li>loglmpl（指定MyBatis所用日志的具体实现，未指定时将自动查找）
<ul>
<li>SLF4j</li>
<li>LOG4J</li>
<li>LOG4]2</li>
<li>JDK_ LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING</li>
<li>NO_LOGGING</li>
</ul>
</li>
<li>在Mybatis中具体使用那个一日志实现，在设置中设定</li>
<li><strong>STDOUT_ LOGGING标准日志输出</strong></li>
<li>在mybatis核心配置文件中，配置我们的日志</li>
<li>配置STDOUT_LOGGING为日志的实现</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<h3 id="log4j"><a class="header" href="#log4j">LOG4J</a></h3>
<ul>
<li>
<p>Log4j:</p>
<ul>
<li>Log4j是Apache的-一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI组件</li>
<li>我们也可以控制每一条日志的输出格式;</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
</li>
<li>
<p>导包</p>
</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>log4j.properties</li>
</ul>
<pre><code class="language-properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console 和file的定义在下面的代码
1og4j.rootLogger=DEBUG,console,file
#控制台输出的相关设置
1og4j.appender.console = org.apache.log4j.ConsoleAppender
1og4j.appender.console.Target = System.out
1og4j.appender.console.Threshold=DEBUG
1og4j.appender.console.layout=org.apache.1og4j.PatternLayout
1og4j.appender.console.layout.ConversionPattern=[%c]-%m%n
#文件输出的相关设置
1og4j.appender.file = org.apache.log4j.RollingFileAppender
1pg4j.appender.file.File=./log/yang.1og
1og4j.appender.file.iaxFileSize=10mb 
1og4j.appender.file.Threshold=DEBUG
1og4j.appender.file.layout=org.apache.log4j.PatternLayout
1og4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n
#日志输出级别
1og4j.logger.org.mybatis=DEBUG
1og4j.logger.java.sq1=DEBUG
1og4j.logger.java.sql.Statement=DEBUG
1og4j.logger.java.sq1.ResultSet=DEBUG
1og4j.logger.java.sq1.PreparedStatement=DEBUG
</code></pre>
<ul>
<li>配置log4j为日志的实现</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<ul>
<li>获取logger对象使用该对象实现手动打印日志</li>
</ul>
<pre><code class="language-java">Logger logger = Logger.getLogger(类名.class);
</code></pre>
<h2 id="分页"><a class="header" href="#分页">分页</a></h2>
<h3 id="使用limit进行分页"><a class="header" href="#使用limit进行分页">使用Limit进行分页</a></h3>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserLimit&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users limit #{param1}, #{param2}
&lt;/select&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void testGetUserLimit(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List&lt;Users&gt; user = mapper.getUserLimit(5, 5);
    for (Users users : user) {
        System.out.println(users.getUserId() + &quot;--&quot;+  users.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
<h3 id="parametertype多个参数的解决方法"><a class="header" href="#parametertype多个参数的解决方法">parameterType多个参数的解决方法</a></h3>
<ul>
<li>使用map封装</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserLimit2&quot; parameterType=&quot;map&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users limit #{startIndex}, #{pageSize}
&lt;/select&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testGetUserLimit2(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;startIndex&quot;, 0);
    map.put(&quot;pageSize&quot;, 5);
    List&lt;Users&gt; user = mapper.getUserLimit2(map);
    for (Users users : user) {
        System.out.println(users.getUserId() + &quot;--&quot;+  users.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
<ul>
<li>不写parameterType使用arg或param使用方式：
<ul>
<li>arg0，arg1，arg2 ……</li>
<li>param1，param2，param3 ……</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserLimit&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users limit #{param1}, #{param2}
&lt;/select&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testGetUserLimit(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List&lt;Users&gt; user = mapper.getUserLimit(5, 5);
    for (Users users : user) {
        System.out.println(users.getUserId() + &quot;--&quot;+  users.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
<ul>
<li>xml转义字符</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>&amp;lt;</code></th><th style="text-align: center">&lt;</th><th style="text-align: center">小于号</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&amp;gt;</code></td><td style="text-align: center">&gt;</td><td style="text-align: center">大于号</td></tr>
<tr><td style="text-align: center"><code>&amp;amp;</code></td><td style="text-align: center">&amp;</td><td style="text-align: center">和</td></tr>
<tr><td style="text-align: center"><code>&amp;apos;</code></td><td style="text-align: center">’</td><td style="text-align: center">单引号</td></tr>
<tr><td style="text-align: center"><code>&amp;quot;</code></td><td style="text-align: center">&quot;</td><td style="text-align: center">双引号</td></tr>
</tbody></table>
</div>
<h3 id="使用rowbounds实现分页"><a class="header" href="#使用rowbounds实现分页">使用RowBounds实现分页</a></h3>
<ul>
<li>xml配置</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;com.yang.pojo.Users&quot;&gt;
    select * from users
&lt;/select&gt;
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-java">@Test
public void getUserByRowBounds(){
    List&lt;Users&gt; users = sqlSession.selectList(&quot;com.yang.dao.UserMapper.getUserByRowBounds&quot;, null, new RowBounds(5, 5));
    for (Users user: users) {
        System.out.println(user.getUserId() + &quot;--&quot;+  user.getEmail());
    }
    //关闭连接
    sqlSession.close();
}
</code></pre>
<h2 id="使用注解开发"><a class="header" href="#使用注解开发">使用注解开发</a></h2>
<h3 id="面向接口编程"><a class="header" href="#面向接口编程">面向接口编程</a></h3>
<ul>
<li>
<p>大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程</p>
</li>
<li>
<p>根本原因: 解耦 ,可拓展,提高复用，分层开发中,上层不用管具体的实现,大家都遵守共同的标准,使得开发变得容易，规范性更好</p>
</li>
<li>
<p>在一一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了</p>
</li>
<li>
<p>-各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的,这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程</p>
</li>
<li>
<p>关于接口的理解</p>
<ul>
<li>接口从更深层次的理解，应是定义(规范，约束)与实现(名实分离的原则)的分离</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解</li>
<li>接口应有两类:
<ul>
<li>第一类是对一个个体的抽象，它可对应为-一个抽象体(abstract class)</li>
<li>第二类是对一个个体某一-方 面的抽象，即形成一个抽象面(interface) </li>
</ul>
</li>
<li>个体有可能有多个抽象面。抽象体与抽象面是有区别的</li>
</ul>
</li>
<li>
<p>三个面向区别</p>
<ul>
<li>面向对象是指，我们考虑问题时，以对象为单位,考虑它的属性及方法.</li>
<li>面向过程是指,我们考虑问题时，以一个具体的流程(事务过程)为单位，考虑它的实现.</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象(过程)不是一个问题.更多的体现就是对系统整体的架构.</li>
</ul>
</li>
</ul>
<h3 id="使用注解开发-1"><a class="header" href="#使用注解开发-1">使用注解开发</a></h3>
<ul>
<li>编写Mapper接口</li>
</ul>
<pre><code class="language-java">public interface UserMapper {
    @Select(&quot;select * from users&quot;)
    List&lt;Users&gt; getUser();
}
</code></pre>
<ul>
<li>在核心配置文件中绑定接口</li>
</ul>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.yang.mapper.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-java">@Test
public void testGetUser(){
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List&lt;Users&gt; user = mapper.getUser();
    for (Users users : user) {
        System.out.println(users.getUserId() + &quot;--&quot; + users.getEmail());
    }
}
</code></pre>
<ul>
<li>
<p>缺点：</p>
<ul>
<li>无法使用ResultMap</li>
<li>在sql参数较多时会很麻烦</li>
</ul>
</li>
<li>
<p>插入：@Insert(&quot;sql语句&quot;)</p>
</li>
<li>
<p>修改：@Update(&quot;sql语句&quot;)</p>
</li>
<li>
<p>删除：@Delete(&quot;sql语句&quot;)</p>
</li>
<li>
<p>关于@Param()注解</p>
<ul>
<li>基本类型的参数或者String类型,需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一一个基本类型的话，可以忽略，但是建议大家都加上</li>
<li>我们在SQL中弓|用的就是我们这里的@Param()中设定的属性名</li>
</ul>
</li>
<li>
<p>#{}和${}的区别就是Statement和PreparedStatement的区别</p>
</li>
</ul>
<h2 id="一对多和多对一的处理"><a class="header" href="#一对多和多对一的处理">一对多和多对一的处理</a></h2>
<h3 id="多对一"><a class="header" href="#多对一">多对一</a></h3>
<ul>
<li>按照查询嵌套处理</li>
</ul>
<pre><code class="language-xml">&lt;resultMap id=&quot;tsMap&quot; type=&quot;student&quot;&gt;
&lt;!--    将该属性与表中的tid关联起来--&gt;
&lt;!--    select 相当于查询跟tid关联的值赋给teacher属性--&gt;
    &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot; column=&quot;tid&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudent&quot; resultMap=&quot;tsMap&quot;&gt;
    select * from student
&lt;/select&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
    select * from teacher where id = #{id}
&lt;/select&gt;
</code></pre>
<ul>
<li>按照结果嵌套处理</li>
</ul>
<pre><code class="language-xml">&lt;resultMap id=&quot;tsMap&quot; type=&quot;student&quot;&gt;
    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
    &lt;!--    将该引用属性里面的属性与链表查询的值关联起来--&gt;
    &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt;
        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
        &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudent&quot; resultMap=&quot;tsMap&quot;&gt;
    select s.id sid, s.name sname, t.id tid, t.name tname
    from student s, teacher t where s.tid = t.id
&lt;/select&gt;
</code></pre>
<h3 id="一对多"><a class="header" href="#一对多">一对多</a></h3>
<ul>
<li>按照查询嵌套处理</li>
</ul>
<pre><code class="language-xml">&lt;resultMap id=&quot;tsMap&quot; type=&quot;teacher&quot;&gt;
    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;!-- 将集合属性进行关联--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;java.util.ArrayList&quot; ofType=&quot;student&quot; column=&quot;id&quot; select=&quot;getStudents&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getTeacher&quot; resultMap=&quot;tsMap&quot;&gt;
    select * from teacher
&lt;/select&gt;
&lt;select id=&quot;getStudents&quot; resultType=&quot;student&quot;&gt;
    select * from student where tid = #{tid}
&lt;/select&gt;
</code></pre>
<ul>
<li>按照结果嵌套处理</li>
</ul>
<pre><code class="language-xml">&lt;resultMap id=&quot;tsMap&quot; type=&quot;teacher&quot;&gt;
    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
    &lt;!-- 将集合属性进行关联--&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;java.util.ArrayList&quot; ofType=&quot;student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getTeacher&quot; resultMap=&quot;tsMap&quot;&gt;
    select t.id tid, t.name tname, s.id sid, s.name sname
    from teacher t, student s
    where t.id = s.tid
&lt;/select&gt;
</code></pre>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<ul>
<li>
<p>关联- association[多对一]</p>
</li>
<li>
<p>集合- collection [一对多]</p>
</li>
<li>
<p>javaType &amp; ofType</p>
<ul>
<li>
<p>JavaType用来指定实体类中属性的类型</p>
</li>
<li>
<p>ofType用来指定映射到List或者集合中的pojo类型,泛型中的约束类型!</p>
</li>
</ul>
</li>
</ul>
<h2 id="动态sql"><a class="header" href="#动态sql">动态sql</a></h2>
<h3 id="if-1"><a class="header" href="#if-1">if</a></h3>
<pre><code class="language-xml">&lt;if test=&quot;arg0 != null&quot;&gt;
    `Date` = #{arg0}
&lt;/if&gt;
&lt;if test=&quot;arg1 != null&quot;&gt;
    and `EconomyPrice` = #{arg1}
&lt;/if&gt;
&lt;if test=&quot;arg2 != null&quot;&gt;
    and `Gate` = #{arg2}
&lt;/if&gt;
</code></pre>
<h3 id="choosewhenotherwise"><a class="header" href="#choosewhenotherwise">choose，when，otherwise</a></h3>
<ul>
<li>就是switch，case，default</li>
</ul>
<pre><code class="language-xml">&lt;choose&gt;
    &lt;when test=&quot;arg0 != null&quot;&gt;
        `Date` = #{arg0}
    &lt;/when&gt;
    &lt;when test=&quot;arg1 != null&quot;&gt;
        and `EconomyPrice` = #{arg1}
    &lt;/when&gt;
    &lt;when test=&quot;arg2 != null&quot;&gt;
        and `Gate` = #{arg2}
    &lt;/when&gt;
    &lt;otherwise&gt;

    &lt;/otherwise&gt;
&lt;/choose&gt;
</code></pre>
<h3 id="setwhere"><a class="header" href="#setwhere">set，where</a></h3>
<ul>
<li>去除写动态sql时多余的符号或关键字</li>
</ul>
<h3 id="foreach"><a class="header" href="#foreach">foreach</a></h3>
<pre><code class="language-xml">&lt;foreach collection=&quot;gates&quot; item=&quot;gate&quot;
         open=&quot;`Gate` in (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
    #{gate}
&lt;/foreach&gt;
</code></pre>
<p><strong>动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了</strong></p>
<p><strong>现在Mysq|中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可</strong></p>
<h2 id="缓存"><a class="header" href="#缓存">缓存</a></h2>
<h3 id="简介-1"><a class="header" href="#简介-1">简介</a></h3>
<ul>
<li>什么是缓存[ Cache ]
<ul>
<li>存在内存中的临时数据</li>
<li>用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>
</ul>
</li>
<li>为什么使用缓存
<ul>
<li>减少和数据库的交互次数,减少系统开销，提高系统效率</li>
</ul>
</li>
<li>什么样的数据能使用缓存?
<ul>
<li>经常查询并且不经常改变的数据</li>
</ul>
</li>
</ul>
<h3 id="mybatis缓存"><a class="header" href="#mybatis缓存">Mybatis缓存</a></h3>
<ul>
<li>
<p>MyBatis包含一个非常强大的查询缓存特性,它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li>
<p>MyBatis系统中默认定义了两级缓存: - -级缓存和二级缓存</p>
<ul>
<li>
<p>默认情况下，只有一 -级缓存开启。 (SqISession级别的缓存， 也称为本地缓存)</p>
</li>
<li>
<p>二级缓存需要手动开启和配置， 他是基于namespace级别的缓存。</p>
</li>
<li>
<p>为了提高扩展性，MyBatis定义了缓存接口Cache。 我们可以通过实现Cache接口来自定义二级缓存</p>
</li>
</ul>
</li>
</ul>
<h3 id="一级缓存"><a class="header" href="#一级缓存">一级缓存</a></h3>
<ul>
<li>一级缓存也叫本地缓存:
<ul>
<li>sqlSession从开启到关闭前得查询得属性会被缓存</li>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库</li>
</ul>
</li>
</ul>
<p><img src="java/SSM/../../assets/java/img/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98java-1597374138185.png" alt="一级缓存java" /></p>
<ul>
<li>两次查询实际上只查询了一次第二次输出从缓存里取数</li>
</ul>
<p><img src="java/SSM/../../assets/java/img/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98out-1597374084581.png" alt="一级缓存out" /></p>
<ul>
<li>缓存失效的情况: 
<ul>
<li>查询不同的东西</li>
<li>增删改操作，可能会改变原来的数据，所以必定会刷新缓存!</li>
<li>查询不同的Mapper.xml</li>
<li>手动清理缓存：
<ul>
<li>在下一次查询时调用<code>sqlSession.clearCache()</code>方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>一级缓存默认是开启的， 只在一次SqlSession中有效, 也就是拿到连接到关闭连接这个区间段</strong></p>
<p><strong>一级缓存就是一个map</strong></p>
<h3 id="134-二级缓存"><a class="header" href="#134-二级缓存">13.4、 二级缓存</a></h3>
<ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存;</li>
<li>工作机制
<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中;</li>
<li>如果当前会话关闭了，这个会话对应的一-级缓存就没了;但是我们想要的是，会话关闭了，- -级缓存中的数据被保存到二级缓存中;</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容;</li>
<li>不同的mapper查出的数据会放在自己对应的缓存(map)中</li>
</ul>
</li>
<li>在核心配置文件里显示开启二级缓存（默认已开启）</li>
</ul>
<pre><code class="language-xml">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true'&quot;/&gt;
</code></pre>
<ul>
<li>在对应得mapper.xml文件内加入标签</li>
</ul>
<pre><code class="language-xml">&lt;!--    默认方式--&gt;
&lt;cache/&gt;
&lt;!--    自定义方式--&gt;
&lt;cache eviction=&quot;FIFO&quot;
       flushInterval=&quot;60000&quot;
       size=&quot;512&quot;
       readOnly=&quot;true&quot;/&gt;
</code></pre>
<p><img src="java/SSM/../../assets/java/img/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98java.png" alt="二级缓存java" /></p>
<p><img src="java/SSM/../../assets/java/img/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98out-1597377652646.png" alt="二级缓存out" /></p>
<ul>
<li>注意：<strong>开启二级缓存对使用注解完成的sql方法无效</strong></li>
<li><strong>需要缓存的类必须实现序列化接口</strong></li>
<li>只要开启了二级缓存,在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中</li>
<li>只有当会话提交，或者关闭的时候，才会提交到二级缓冲中</li>
</ul>
<h2 id="缓存原理"><a class="header" href="#缓存原理">缓存原理</a></h2>
<p><img src="java/SSM/../../assets/java/img/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png" alt="缓存原理" /></p>
<ul>
<li>缓存顺序：
<ol>
<li>先看二级缓存中有没有</li>
<li>再看一级缓存中有没有</li>
<li>查询数据库</li>
</ol>
</li>
</ul>
<h2 id="自定义缓存"><a class="header" href="#自定义缓存">自定义缓存</a></h2>
<p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt; /version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>在对应得=的mapper.xml文件内指定缓存的实现方式</li>
</ul>
<pre><code class="language-xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;
</code></pre>
<ul>
<li>编写ehcache配置文件ehcache.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
         updateCheck=&quot;false&quot;&gt;

    &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;

    &lt;defaultCache
                  eternal=&quot;false&quot;
                  maxElementsInMemory=&quot;10000&quot;
                  overflowToDisk=&quot;false&quot;
                  diskPersistent=&quot;false&quot;
                  timeToIdleSeconds=&quot;1800&quot;
                  timeToLiveSeconds=&quot;259200&quot;
                  memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

    &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
&lt;/ehcache&gt;
</code></pre>
<p><img src="java/SSM/../../assets/java/img/ehcache%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.png" alt="ehcache配置说明" /></p>
<h1 id="spring"><a class="header" href="#spring">Spring</a></h1>
<h2 id="idea创建module跳language-level问题"><a class="header" href="#idea创建module跳language-level问题">idea创建module跳language level问题</a></h2>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
&lt;!-- 或在&lt;build&gt;标签里面添加--&gt;
&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;configuration&gt;
            &lt;source&gt;1.8&lt;/source&gt;
            &lt;target&gt;1.8&lt;/target&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<h2 id="xml文件骨架-1"><a class="header" href="#xml文件骨架-1">xml文件骨架</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
      https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="简介-2"><a class="header" href="#简介-2">简介</a></h2>
<ul>
<li>
<p>2002， 首次推出了Spring框架的雏形: interface21框架!</p>
</li>
<li>
<p>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版。</p>
</li>
<li>
<p>Rod Johnson，Spring Framework创始人</p>
</li>
<li>
<p>spring理念: 使现有的技术更加容易使用，本身是一 个大杂烩，整合了现有的技术框架!</p>
</li>
<li>
<p>SSH : Struct2 + Spring + Hibernate</p>
</li>
<li>
<p>SSM : SpringMvc + Spring + Mybatis</p>
</li>
<li>
<p>文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#spring-core</p>
</li>
<li>
<p>官方下载地址: http://repo.spring.io/release/org/springframework/spring</p>
</li>
<li>
<p>GitHub: https://github.com/spring:projects/spring-framework</p>
</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--spring整合mybatis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ul>
<li>Spring是一 个开源的免费的框架(容器) </li>
<li>Spring是一 个轻量级的、非入侵式的框架</li>
<li>控制反转(IOC) ，面向切面编程(AOP) </li>
<li>支持事务的处理, 对框架整合的支持</li>
<li><strong>Spring就是一 个轻量级的控制反转(IOC) 和面向切面编程(AOP)的框架!</strong></li>
</ul>
<h3 id="组成"><a class="header" href="#组成">组成</a></h3>
<p><img src="java/SSM/../../assets/java/img/spring%E6%A8%A1%E5%9D%97.png" alt="spring模块" /></p>
<ul>
<li>扩展：
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架。</li>
<li>基于SpringBoot可以快速的开发单个微服务。</li>
<li>约定大于配置!</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>SpringCloud 是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
</li>
<li>因为现在大多数公司都在使用SpringBoot进行快速开发,学习SpringBoot的前提， 需要完全掌握Spring及SpringMVC</li>
</ul>
<h2 id="ioc理论"><a class="header" href="#ioc理论">IOC理论</a></h2>
<ol>
<li>UserDao接口</li>
<li>UserDaoImpl实现类</li>
<li>UserService接口</li>
<li>UserServiceImpl业务实现类</li>
</ol>
<p>在我们之前的业务中,用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码!如果程序代码量十分大，修改一次的成本代价十分昂贵!</p>
<p>使用set注入属性将将控制器交到用户手上用户向调用那个UserDao实现类直接在UserServiceImpl里面设置就行了</p>
<pre><code class="language-java">private UserDao userDao;
//使用set实现属性的注入
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
</code></pre>
<p>降低耦合性</p>
<p><img src="java/SSM/../../assets/java/img/ioc.png" alt="ioc" /></p>
<blockquote>
<p><strong>IOC</strong></p>
</blockquote>
<ul>
<li>控制反转loC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程， 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是:获得依赖对象的方式反转了。</li>
<li>采用XML方式配置Bean的时候，Bean的定义信息 是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</li>
<li><strong>控制反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入(Dependency Injection,DI)</strong></li>
</ul>
<h3 id="spring实现对象的托管"><a class="header" href="#spring实现对象的托管">spring实现对象的托管</a></h3>
<ul>
<li>编写实体类gettersetter方法</li>
</ul>
<pre><code class="language-java">public class Hello {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Hello{&quot; +
            &quot;name='&quot; + name + '\'' +
            '}';
    }
}
</code></pre>
<ul>
<li>编写bean.xml文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--    使用bean标签对对象进行托管--&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;com.yang.pojo.Hello&quot;&gt;
        &lt;!--        初始化属性的值--&gt;
        &lt;property name=&quot;name&quot; value=&quot;hello java&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-java">@Test
public void test02(){
    //创建ClassPathXmlApplicationContext读取beans.xml文件
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    //调用getBean(&quot;id&quot;)方法获取托管的对象
    Hello hello = context.getBean(&quot;hello&quot;, Hello.class);
    System.out.println(hello);
}
</code></pre>
<ul>
<li>使用bean标签托管的对象默认使用单例模式创建，就是同一个id获取到的对象是同一个对象</li>
</ul>
<pre><code class="language-java">//创建ClassPathXmlApplicationContext读取beans.xml文件
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
//调用getBean(&quot;id&quot;)方法获取托管的对象
Hello hello1 = context.getBean(&quot;hello&quot;, Hello.class);
Hello hello2 = context.getBean(&quot;hello&quot;, Hello.class);
System.out.println(hello1 == hello2);//true
</code></pre>
<ul>
<li>
<p>Hello对象是谁创建的?</p>
<ul>
<li>hello对象是由Spring创建的</li>
</ul>
</li>
<li>
<p>Hello对象的属性是怎么设置的?</p>
<ul>
<li>hello对象的属性是由Spring容器设置的,</li>
</ul>
</li>
<li>
<p>这个过程就叫控制反转:</p>
<ul>
<li>控制：谁来控制对象的创建,传统应用程序的对象是由程序本身控制创建的,使用Spring后,对象是由Spring来创建的.</li>
<li>反转：程序本身不创建对象,而变成被动的接收对象.</li>
</ul>
</li>
<li>
<p>依赖注入:就是利用set方法来进行注入的.</p>
</li>
<li>
<p>IOC是一种编程思想,由主动的编程变成被动的接收.</p>
</li>
<li>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
</li>
<li>
<p>,我们彻底不用再程序中去改动了,要实现不同的操作,只需要在xml配置文件中进行修改，IOC：对象由Spring来创建,管理,装配!</p>
</li>
</ul>
<h2 id="ioc创建对象的方式"><a class="header" href="#ioc创建对象的方式">IOC创建对象的方式</a></h2>
<ul>
<li>使用无参构造 默认</li>
<li>使用有参构造</li>
</ul>
<pre><code class="language-xml">&lt;!-- 使用下标--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;0&quot; value=&quot;张三&quot;/&gt;
    &lt;constructor-arg name=&quot;1&quot; value=&quot;18&quot;/&gt;    
&lt;/bean&gt;
&lt;!-- 使用参数名--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;    
&lt;/bean&gt;
&lt;!-- 使用参数类型--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;java.lang.String&quot; value=&quot;张三&quot;/&gt;
    &lt;constructor-arg name=&quot;int&quot; value=&quot;18&quot;/&gt;    
&lt;/bean&gt;
</code></pre>
<ul>
<li>在配置文件加载的时候，容器中管理的对象就已经初始化了!</li>
</ul>
<h2 id="spring配置"><a class="header" href="#spring配置">Spring配置</a></h2>
<h3 id="别名"><a class="header" href="#别名">别名</a></h3>
<pre><code class="language-xml">&lt;!-- bean的name标签也可以取别名，并且可以一次取多个别名--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;prototype&quot;
      name=&quot;别名1,别名2,……&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;	
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
&lt;/bean&gt;
&lt;!--取别名--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;别名&quot;/&gt;
</code></pre>
<h3 id="import"><a class="header" href="#import">import</a></h3>
<ul>
<li>这个import,一般用于团队开发使用，他可以将多个配置文件，导入合并为-一个</li>
<li>假设，现在项目中有多个人开发,这三个人复制不同的类开发,不同的类需要注册在不同的bean中，我们可以利</li>
<li>用import将所有人的beans.xml合并为一个总的!</li>
<li>applicationContext.xml文件里面导入其他文件</li>
</ul>
<pre><code class="language-xml">&lt;import resource=&quot;beans.xm1&quot;/&gt;
&lt;import resource=&quot;beans2.xm]&quot;/&gt;
&lt;import resource=&quot;beans3.xm1&quot;/&gt;
</code></pre>
<ul>
<li>使用的时候，直接使用总的配置就可以了</li>
</ul>
<h2 id="依赖注入"><a class="header" href="#依赖注入">依赖注入</a></h2>
<h3 id="构造器注入上面"><a class="header" href="#构造器注入上面">构造器注入（上面）</a></h3>
<h3 id="set注入"><a class="header" href="#set注入">set注入</a></h3>
<ul>
<li>复杂注入：</li>
<li>java类</li>
</ul>
<pre><code class="language-java">public class Student {
    private String name;
    private int age;
    private Address address;
    private List&lt;Integer&gt; is;
    private Set&lt;String&gt; ss;
    private Map&lt;String, Integer&gt; ms;
    private int[] ins;
    ……getter和setter方法
}
public class Address {
    private String home;
    private List&lt;String&gt; v2;
    ……getter和setter方法
}
</code></pre>
<ul>
<li>xml</li>
</ul>
<pre><code class="language-xml">&lt;!--    address注入--&gt;
&lt;bean id=&quot;address&quot; class=&quot;com.yang.pojo.Address&quot;&gt;
    &lt;property name=&quot;home&quot; value=&quot;湖北&quot;/&gt;
    &lt;property name=&quot;v2&quot;&gt;
        &lt;list value-type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;wqew&lt;/value&gt;
            &lt;value&gt;wqeweww&lt;/value&gt;
            &lt;value&gt;wqrewew&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!--    student注入--&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.yang.pojo.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
    &lt;property name=&quot;is&quot;&gt;
        &lt;list value-type=&quot;java.lang.Integer&quot;&gt;
            &lt;value&gt;43&lt;/value&gt;
            &lt;value&gt;4232&lt;/value&gt;
            &lt;value&gt;44&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;ins&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;34&lt;/value&gt;
            &lt;value&gt;3767&lt;/value&gt;
            &lt;value&gt;376564&lt;/value&gt;
            &lt;value&gt;3435434&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;ss&quot;&gt;
        &lt;set value-type=&quot;java.lang.String&quot;&gt;
            &lt;value&gt;weqwq&lt;/value&gt;
            &lt;value&gt;weqwqerwer&lt;/value&gt;
            &lt;value&gt;weqrrewrewrwrewq&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;ms&quot;&gt;
        &lt;map key-type=&quot;java.lang.String&quot; value-type=&quot;java.lang.Integer&quot;&gt;
            &lt;entry key=&quot;a&quot;&gt;
                &lt;value&gt;44&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry key=&quot;b&quot;&gt;
                &lt;value&gt;4324&lt;/value&gt;
            &lt;/entry&gt;
&lt;!--            &lt;entry key=&quot;a&quot; value=&quot;44&quot;/&gt;--&gt;
&lt;!--            &lt;entry key=&quot;b&quot; value=&quot;4324&quot;/&gt;--&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>
<p>map和properties的注入方式：</p>
<ul>
<li>map：</li>
</ul>
<pre><code class="language-xml">&lt;map key-type=&quot;java.lang.String&quot; value type=&quot;java.lang.Integer&quot;&gt;
&lt;/map&gt;
&lt;entry key=&quot;键&quot;&gt;
    &lt;value&gt;值&lt;/value&gt;
&lt;/entry&gt;
&lt;entry key=&quot;键&quot; value=&quot;值&quot;/&gt;
</code></pre>
<ul>
<li>properties:</li>
</ul>
<pre><code class="language-xml">&lt;props&gt;
    &lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;
    &lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;
    &lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;
&lt;/props&gt;
</code></pre>
</li>
</ul>
<h3 id="拓展方式注入"><a class="header" href="#拓展方式注入">拓展方式注入</a></h3>
<ul>
<li>
<p>必须导入xml约束（在bean标签内导入）</p>
<ul>
<li>p：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</li>
<li>c：xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</li>
</ul>
</li>
<li>
<p>p命名空间：</p>
</li>
</ul>
<pre><code class="language-xml">&lt;!--p命名空间注入--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; p:name=&quot;张三&quot; p:age=&quot;18&quot;/&gt;
</code></pre>
<ul>
<li>c命名空间：</li>
</ul>
<pre><code class="language-xml">&lt;!--c命名空间注入--&gt;
&lt;bean id=&quot;user3&quot; class=&quot;com.yang.pojo.User&quot; c:name=&quot;张三&quot; c:age=&quot;18&quot;/&gt;
</code></pre>
<h3 id="bean的作用域"><a class="header" href="#bean的作用域">bean的作用域</a></h3>
<p><img src="java/SSM/../../assets/java/img/bean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="bean作用域" /></p>
<ul>
<li>
<p>singleton：单例模式</p>
<ul>
<li>默认开启</li>
<li>使用getbean()获取到的对象都是一个对象</li>
</ul>
<pre><code class="language-xml">&lt;!--    可以显示开启--&gt;
&lt;bean name=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>prototype：原型模式</p>
<ul>
<li>使用getbean()获取到的对象相当于new一个对象</li>
</ul>
<pre><code class="language-xml">&lt;bean name=&quot;user&quot; class=&quot;com.yang.pojo.User&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>request、session、 application、 这些个只能在web开发中使用到</p>
</li>
</ul>
<h2 id="bean的自动装配"><a class="header" href="#bean的自动装配">bean的自动装配</a></h2>
<ul>
<li>
<p>autowire</p>
<ul>
<li>byName：根据容器类的id查找跟该属性名相同的bean	</li>
<li>使用byname的时候，需要保证所有bean的id唯一， 并且这个bean需要和自动注入的属性的set方法的值一致!</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.yang.pojo.Dog&quot; p:name=&quot;小黑&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.yang.pojo.Cat&quot; p:name=&quot;小花&quot;/&gt;
&lt;bean id=&quot;people&quot; class=&quot;com.yang.pojo.People&quot; p:name=&quot;小明&quot; autowire=&quot;byName&quot;/&gt;
</code></pre>
<ul>
<li>byType：查找容器内的bean的类型是否符该属性的类型相同，相同则装配</li>
<li>使用bytype的时候，需要保证所有bean的class唯一 , 并且这个bean需要和自动注入的属性的类型一致!</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.yang.pojo.Dog&quot; p:name=&quot;小黑&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.yang.pojo.Cat&quot; p:name=&quot;小花&quot;/&gt;
&lt;bean id=&quot;people&quot; class=&quot;com.yang.pojo.People&quot; p:name=&quot;小明&quot; autowire=&quot;byName&quot;/&gt;
</code></pre>
<ul>
<li>
<h5 id="使用注解实现自动装配"><a class="header" href="#使用注解实现自动装配">使用注解实现自动装配</a></h5>
<ul>
<li>导入约束，配置注解的支持：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>@Autowired
<ul>
<li>required属性：指定为false说明该字段可以为空</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class People {
    private String name;
    @Autowired
    private Dog dog;
    @Autowired
    private Cat cat;
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:annotation-config/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.yang.pojo.Dog&quot;/&gt;
    &lt;bean id=&quot;cat&quot; class=&quot;com.yang.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;people&quot; class=&quot;com.yang.pojo.People&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解[@Autowired] 完成的时候、我们可以</li>
<li>使用@Qualifier(value=&quot;xx&quot;)去配置@Autowired的使用，指定一个唯一 的bean对象注入!</li>
</ul>
<pre><code class="language-java">public class People {
    private String name;
    @Autowired
    @Qualifier(&quot;dog&quot;)
    private Dog dog;
    @Autowired
    @Qualifier(&quot;cat&quot;)
    private Cat cat;
}
</code></pre>
<ul>
<li>java自带的@Resources注解也可以使用这个注解相当于@Autowired+@Qualifier(value=&quot;xx&quot;)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用注解开发-2"><a class="header" href="#使用注解开发-2">使用注解开发</a></h2>
<h5 id="在spring4之后要使用注解开发必须要保证aop的包导入了"><a class="header" href="#在spring4之后要使用注解开发必须要保证aop的包导入了">在Spring4之后，要使用注解开发，必须要保证aop的包导入了</a></h5>
<h5 id="使用注解需要导入context约束增加注解的支持"><a class="header" href="#使用注解需要导入context约束增加注解的支持">使用注解需要导入context约束,增加注解的支持!</a></h5>
<ul>
<li>
<p>bean</p>
</li>
<li>
<p>属性如何注入</p>
<ul>
<li>在类上面加@Component注解</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Component
public class People {
    private String name;
    private Dog dog;
    private Cat cat;
}
</code></pre>
<ul>
<li>
<p>衍生的注解</p>
<ul>
<li>@Component有几个衍生注解, 我们在web开发中，会按照mvc三层架构分层
<ul>
<li>dao [@Repository]</li>
<li>service[ @Service]</li>
<li>controller [ @Controller ]</li>
</ul>
</li>
<li>这四个注解功能都是一 样的，都是代表将某个类注册到Spring中，装配Bean</li>
</ul>
</li>
<li>
<p>自动装配置</p>
<ul>
<li>@Autowired</li>
<li>@Qualifier(&quot;&quot;)</li>
</ul>
</li>
<li>
<p>作用域</p>
<ul>
<li>@Scope(&quot;模式&quot;)</li>
</ul>
<pre><code class="language-java">@Component
@Scope(&quot;prototype&quot;)
public class People {
    private String name;
    private Dog dog;
    private Cat cat;
}
</code></pre>
</li>
<li>
<p>小结</p>
<ul>
<li>
<p>xml与注解:</p>
<ul>
<li>xml更加万能，适用于任何场合!维护简单方便</li>
<li>注解不是自己类使用不了，维护相对复杂!</li>
</ul>
</li>
<li>
<p>xml与注解最佳实践: </p>
<ul>
<li>xml用来管理bean;</li>
<li>注解只负责完成属性的注入;</li>
<li>我们在使用的过程中，只需要注意一个问题: 必须让注解生效，就需要开启注解的支持</li>
</ul>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;包名&quot;/&gt;
&lt;context:annotation-config/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="使用java的方式配置spring"><a class="header" href="#使用java的方式配置spring">使用Java的方式配置Spring</a></h2>
<h5 id="我们现在要完全不使用spring的xml配置了全权交给java来做"><a class="header" href="#我们现在要完全不使用spring的xml配置了全权交给java来做">我们现在要完全不使用Spring的xml配置了，全权交给Java来做!</a></h5>
<h5 id="javaconfig是spring的一-个子项目在spring4之后-它成为了一个核心功能"><a class="header" href="#javaconfig是spring的一-个子项目在spring4之后-它成为了一个核心功能">JavaConfig是Spring的一-个子项目，在Spring4之后, 它成为了一个核心功能!</a></h5>
<pre><code class="language-java">@Configuration
//扫描包
@ComponentScan(&quot;com.yang.pojo&quot;)
//合并两个Configuration配置类
@Import(CustomConfig2.class)
public class CustomConfig {
    @Bean
    public User user(){
        return new User();
    }
}
</code></pre>
<h2 id="aop"><a class="header" href="#aop">AOP</a></h2>
<p>AOP (Aspect Oriented Programming)意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统- -维护的一种技术。AOP是OOP的延续,是软件开发中的一个热点，也是Spring框架中的一个重要内容,是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h3 id="aop在spring中的作用"><a class="header" href="#aop在spring中的作用">AOP在Spring中的作用</a></h3>
<h5 id="提供声明式事务允许用户自定义切面"><a class="header" href="#提供声明式事务允许用户自定义切面">提供声明式事务允许用户自定义切面</a></h5>
<ul>
<li>横切关注点:跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部‘分，就是横切关注点。如日志，安全,缓存,事务等等...</li>
<li>切面(ASPECT) :横切关注点被模块化的特殊对象。即，它是一-个类。</li>
<li>通知(Advice) :切面必须要完成的工作。即，它是类中的-一个方法。</li>
<li>目标(Target) :被通知对象。</li>
<li>代理(Proxy) :向目标对象应用通知之后创建的对象。</li>
<li>切入点(PointCut) :切面通知执行的“地点&quot;的定义。</li>
<li>连接点(JointPoint) :与切入点匹配的执行点。</li>
</ul>
<p><img src="java/SSM/../../assets/java/img/aop.png" alt="aop" /></p>
<h3 id="使用spring实现aop"><a class="header" href="#使用spring实现aop">使用Spring实现Aop</a></h3>
<p>导包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="使用spring的api接口实现"><a class="header" href="#使用spring的api接口实现">使用spring的api接口实现</a></h4>
<ul>
<li>编写service层</li>
</ul>
<pre><code class="language-java">//接口
public interface UserService {
    void add();
    void update();
    void select();
    void delete();
}
//实现类
public class UserServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println(&quot;添加了一个用户&quot;);
    }
    @Override
    public void update() {
        System.out.println(&quot;修改了一个用户&quot;);
    }
    @Override
    public void select() {
        System.out.println(&quot;查询了一个用户&quot;);
    }
    @Override
    public void delete() {
        System.out.println(&quot;删除了一个用户&quot;);
    }
}
</code></pre>
<ul>
<li>编写日志类
<ul>
<li>前置日志实现MethodBeforeAdvice接口，在该方法执行前执行</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Log  implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName()+&quot; is start to invoked!&quot;);
    }
}
</code></pre>
<ul>
<li>后置日志实现AfterReturningAdvice，在该方法执行后执行</li>
</ul>
<pre><code class="language-java">public class AfterLog implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println(method.getName()+&quot; is invoked! result is: &quot; + returnValue);
    }
}
</code></pre>
<ul>
<li>编写xml文件注册bean</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;userService&quot; class=&quot;com.yang.service.UserServiceImpl&quot;/&gt;
&lt;bean id=&quot;log&quot; class=&quot;com.yang.log.Log&quot;/&gt;
&lt;bean id=&quot;afterLog&quot; class=&quot;com.yang.log.AfterLog&quot;/&gt;
</code></pre>
<ul>
<li>在xml文件内加入<code>&lt;aop:config&gt;</code>标签，实现对类进行切面编程</li>
</ul>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.yang.service.UserService.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;point&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;point&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<h4 id="自定义方式实现aop"><a class="header" href="#自定义方式实现aop">自定义方式实现AOP</a></h4>
<ul>
<li>编写自定义切面类</li>
</ul>
<pre><code class="language-java">public class CustomLog {
    public void before(){
        System.out.println(&quot;方法执行前&quot;);
    }
    public void after(){
        System.out.println(&quot;方法执行后&quot;);
    }
}
</code></pre>
<ul>
<li>在xml文件里面注册</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;customLog&quot; class=&quot;com.yang.custom.CustomLog&quot;/&gt;
</code></pre>
<ul>
<li>xml文件里面添加<code>&lt;aop:config&gt;</code>标签</li>
</ul>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:aspect ref=&quot;customLog&quot;&gt;
        &lt;aop:pointcut id=&quot;userServicePoint&quot; expression=&quot;execution(* com.yang.service.UserService.*(..))&quot;/&gt;
        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;userServicePoint&quot;/&gt;
        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;userServicePoint&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<h4 id="使用注解方式"><a class="header" href="#使用注解方式">使用注解方式</a></h4>
<ul>
<li>编写自定义切面类并添加注解</li>
</ul>
<pre><code class="language-java">@Aspect
public class CustomAnnoPoint {
    @Before(&quot;execution(* com.yang.service.UserService.*(..))&quot;)
    public void before(){
        System.out.println(&quot;注解实现--方法执行前&quot;);
    }
    @After(&quot;execution(* com.yang.service.UserService.*(..))&quot;)
    public void after(){
        System.out.println(&quot;注解实现--方法执行后&quot;);
    }
}
</code></pre>
<ul>
<li>
<p>xml文件里注册该类</p>
<pre><code class="language-xml">&lt;bean id=&quot;customAnnoPoint&quot; class=&quot;com.yang.custom.CustomAnnoPoint&quot;/&gt;
</code></pre>
</li>
<li>
<p>xml文件内添加<code>&lt;aop:aspectj-autoproxy/&gt;</code>标签自动代理切面类</p>
</li>
<li>
<p><code>&lt;aop:aspectj-autoproxy/&gt;</code>标签的proxy-target-class</p>
<ul>
<li>false（默认）：JDK实现</li>
<li>true：cglib实现</li>
</ul>
</li>
</ul>
<h2 id="整合mybatis"><a class="header" href="#整合mybatis">整合mybatis</a></h2>
<h3 id="方式一"><a class="header" href="#方式一">方式一</a></h3>
<ul>
<li>导包</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>编写spring的xml文件</li>
<li>spring自带的数据源DriverManagerDataSource</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;dateSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot;
              value=&quot;jdbc:mysql://localhost:3306/session1?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;112358&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>spring自带的SqlSessionFactoryBean</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!--        注入数据源--&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dateSource&quot;/&gt;
    &lt;!--        获取mybatis的配置文件--&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;!--        扫描对应的xml配置文件--&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/yang/dao/*.xml&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>spring自带的SqlSessionTemplate</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>编写对应的mapper.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.yang.dao.UserMapper&quot;&gt;
    &lt;select id=&quot;getUser&quot; resultType=&quot;users&quot;&gt;
        select * from users limit 0, 10
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>编写对应的Mapper实现类</li>
</ul>
<pre><code class="language-java">public class UserMapperImpl implements UserMapper {

    private SqlSessionTemplate sqlSession;

    private UserMapper userMapper;

    public void setSqlSession(SqlSessionTemplate sqlSession) {
        this.sqlSession = sqlSession;
        userMapper = this.sqlSession.getMapper(UserMapper.class);
    }

    @Override
    public List&lt;Users&gt; getUser() {
        //        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return userMapper.getUser();
    }
}
</code></pre>
<ul>
<li>对应的实现类属性注入sqlSession类</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;userMapper&quot; class=&quot;com.yang.dao.UserMapperImpl&quot;&gt;
    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-java">@Test
public void test03(){
    UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);
    List&lt;Users&gt; user = userMapper.getUser();
    for (Users users : user) {
        System.out.println(users);
    }
}
</code></pre>
<h3 id="方式二"><a class="header" href="#方式二">方式二</a></h3>
<ul>
<li>将方式一的托管spring自带的SqlSessionTemplate替换为对应的Mpper实现类继承SqlSessionDaoSupport接口sqlSession就可以使用父类的<code>getSession()</code>获取</li>
<li>托管实现类事需要注入SqlSessioinFactory接口</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;userMapper2&quot; class=&quot;com.yang.dao.UserMapperImpl2&quot;&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="spring中的事务"><a class="header" href="#spring中的事务">Spring中的事务</a></h2>
<h4 id="声明式事务aop"><a class="header" href="#声明式事务aop">声明式事务：AOP</a></h4>
<ul>
<li>
<p>使用Aop实现事务</p>
</li>
<li>
<p>xml文件内编写</p>
</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!--        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;--&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;tx:advice id=&quot;mapperTransaction&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;userMapperPointCut&quot; expression=&quot;execution(* com.yang.dao.UserMapper.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;mapperTransaction&quot; pointcut-ref=&quot;userMapperPointCut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<ul>
<li>使用注解实现的事务</li>
<li>在需要使用事务的方法上加上@Transactional注解</li>
</ul>
<pre><code class="language-java">@Transactional
public List&lt;Users&gt; getUser() {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;userId&quot;, 1001);
    map.put(&quot;email&quot;, &quot;wqeqe@qq.com&quot;);
    map.put(&quot;password&quot;, &quot;1111111&quot;);
    userMapper.insertUser(map);
    userMapper.deleteUser(103);

    return userMapper.getUser();
}
</code></pre>
<ul>
<li>在xml文件内配置</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!--        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;--&gt;
&lt;/bean&gt;

&lt;!--注解实现事务的标签--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<h4 id="编程式事务需要在代码里实现事务的管理"><a class="header" href="#编程式事务需要在代码里实现事务的管理">编程式事务：需要在代码里实现事务的管理</a></h4>
<h1 id="springmvc"><a class="header" href="#springmvc">SpringMVC</a></h1>
<h2 id="编写一个springmvc程序"><a class="header" href="#编写一个springmvc程序">编写一个springMVC程序</a></h2>
<ul>
<li>配置web.xml，注册DispatcherServlet</li>
</ul>
<pre><code class="language-xml">&lt;!--1.注册DispatcherServlet--&gt; 
&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--        关联springmvc的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--        启动级别--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;!--    / 匹配所有请求不包括.jsp--&gt;
&lt;!--    /* 匹配所有请求包括.jsp--&gt;  
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ul>
<li>编写springmvc-servlet.xml文件</li>
<li>添加处理器映射器</li>
</ul>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
<ul>
<li>添加处理器适配器</li>
</ul>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
<ul>
<li>添加视图解析器</li>
</ul>
<pre><code class="language-xml">&lt;!--    视图解析器: DispatcherServlet给他的ModeLAndView--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;WEB-INF/jsp/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>编写controller类</li>
</ul>
<pre><code class="language-java">public class HelloController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;, &quot;Hello SpringMVC&quot;);
        mv.setViewName(&quot;he&quot;);
        return mv;
    }
}
</code></pre>
<ul>
<li>在WEB-INF目录下新建一个1文件夹再编写jsp页面获取controller类发送的数据</li>
</ul>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>在spring的xml文件内托管该controller类</li>
<li>问题：</li>
</ul>
<p><img src="java/SSM/../../assets/java/img/%E9%97%AE%E9%A2%98.png" alt="问题" /></p>
<ul>
<li>
<p>使用注解方式：</p>
<ul>
<li>将springxml文件更改</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
      https://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
         http://www.springframework.org/schema/mvc
          https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!--    扫描包--&gt;
    &lt;context:component-scan base-package=&quot;com.yang.controller&quot;/&gt;
&lt;!--    过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--
        支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想仪@Reques tMapping注解生效必须向上下文中注DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
    --&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--    视图解析器: DispatcherServlet给他的ModeLAndView--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>编写对应controller类</li>
</ul>
<pre><code class="language-java">@Controller
public class HelloController {
    @RequestMapping(../../assets/java/hello&quot;)
    public String hello(Model model){
        model.addAttribute(&quot;msg&quot;, &quot;Hello SpringMVCAnnotation!&quot;);
        return &quot;test&quot;;
    }
}

</code></pre>
<ul>
<li>在WEB-INF目录下新建一个1文件夹再编写jsp页面获取controller类发送的数据</li>
</ul>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>Restful风格</p>
<ul>
<li>默认的资源拦截器可能拦截restful风格的输入方式</li>
<li>在配置了视图解析器后使用视图解析器方式可能会出现404（自己遇见的问题待解决</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Controller
public class OperationController {
    //url使用{}符号取值
    @RequestMapping(../../assets/java/add/{num1}/{num2}&quot;)
    			//添加@PathVariable指定参数对应的名称
    public String add(@PathVariable(&quot;num1&quot;) int a,@PathVariable(&quot;num2&quot;) int b, Model model){
        model.addAttribute(&quot;result&quot;, a + b);
        return &quot;forward:/WEB-INFO/jsp/result.jsp&quot;;
    }
}
</code></pre>
<ul>
<li>
<p>不使用视图解析器实现页面转发和重定向的方式</p>
</li>
<li>
<p>页面转发</p>
<ul>
<li>返回值填写项目下资源的完整路径</li>
<li>可以前缀加上forward:标识为页面转发</li>
<li>不加默认为页面转发</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/test&quot;)
public String tets(){
    return &quot;/WEB-INF/jsp/te.jsp&quot;;
}
</code></pre>
</li>
<li>
<p>重定向（重定向不能访问web-inf下的文件）</p>
<ul>
<li>在文件前面加redirect:标识为重定向</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/redirect&quot;)
public String reTest(){
    System.out.println(&quot;-----------------&quot;);
    return &quot;redirect:/index.jsp&quot;;
}
</code></pre>
</li>
</ul>
<h2 id="获取前端表单的参数"><a class="header" href="#获取前端表单的参数">获取前端表单的参数</a></h2>
<ul>
<li>参数名称与mapping方法的形参名称一致
<ul>
<li>如果不一致需要在方法参数的前面加上@RequestParam(&quot;名称&quot;)与前端页面的名称一致</li>
</ul>
</li>
</ul>
<pre><code class="language-jsp">&lt;form action=&quot;${pageContext.request.contextPath}/param1&quot; method=&quot;get&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${username}&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(../../assets/java/param1&quot;)
public String pa1Test(@RequestParam(&quot;username&quot;) String username){
    System.out.println(username);
    return &quot;forward:/testParam1.jsp&quot;;
}
</code></pre>
<ul>
<li>如果前端放回的数据刚好是一个对象则mapping方法内可以直接将该对象作为参数，如果对象的属性名与前端页面的参数不一致则不会赋值</li>
</ul>
<pre><code class="language-jsp">&lt;form action=&quot;${pageContext.request.contextPath}/param2&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;number&quot; name=&quot;phone&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(../../assets/java/param2&quot;)
public String pa1Test(User user){
    System.out.println(user);
    return &quot;forward:/testParam.jsp&quot;;
}
</code></pre>
<h2 id="modelmodelmapmodelandview"><a class="header" href="#modelmodelmapmodelandview">Model、ModelMap、ModelAndView</a></h2>
<ul>
<li>model：适用于数据储存，简化了用户对model的操作</li>
<li>modelmap：继承了LinkedHashMap，可以使用likedhashmap的操作</li>
<li>modelandview：可以储存数据，可以设置放回的逻辑视图，进行控制展示层跳转</li>
</ul>
<h2 id="处理乱码问题"><a class="header" href="#处理乱码问题">处理乱码问题</a></h2>
<ul>
<li>方式一：自己编写字符过滤器</li>
<li>方式二：配置spring自己实现的characterEncdingFilter</li>
</ul>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<h2 id="json"><a class="header" href="#json">Json</a></h2>
<h4 id="使用jackson"><a class="header" href="#使用jackson">使用Jackson</a></h4>
<ul>
<li>
<p>JavaScript解析和转换json</p>
<ul>
<li>将js里面的对象转换为json字符串</li>
</ul>
<pre><code class="language-javascript">//定义一个js对象
var obj = {
    name:&quot;张三&quot;,
    age:18,
    id:&quot;1001&quot;
};
//使用JSON对象的stringify方法将该js对象转换为json字符串
let objStr = JSON.stringify(obj);
</code></pre>
<ul>
<li>将json字符串解析为js里面的对象</li>
</ul>
<pre><code class="language-javascript">var jsonStr = '{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;id&quot;:&quot;1001&quot;}';
var jsonObj = JSON.parse(jsonStr);
</code></pre>
</li>
<li>
<p>java里面解析和转换json</p>
<ul>
<li>导包</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.11.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>在方法前面加上@ReponseBody是这个方法不走视图解析器而是直接在页面显示返回的字符串</li>
<li>如果需要该类里面的所有方法都不走视图解析器，返回字符串的话，将该类的@Controller注解替换为@RestControler</li>
</ul>
<pre><code class="language-java">@ResponseBody
@RequestMapping(../../assets/java/j1&quot;)
public String testJson01(){
    return &quot;123&quot;;
}
</code></pre>
<ul>
<li>
<p>创建ObjectMapper对象，调用writeValueAsString方法将一个java对象转换为json字符串</p>
<ul>
<li>
<p>解决json转到前端的的乱码问题</p>
<ul>
<li>方式一：在Mapping里面添加一个参数produces = &quot;application/json;charset=utf-8&quot;,如果有多的mapping这种发视会非常麻烦</li>
<li>方式二：springmvc提供的，在xml文件里面添加如下代码，可以全局使用</li>
</ul>
<pre><code class="language-xml">&lt;!--    解决json到前端页面的乱码问题--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@ResponseBody
@RequestMapping(value = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;)
public String testJson01() throws JsonProcessingException, UnsupportedEncodingException {
    User user = new User(&quot;张三&quot;, &quot;qwqe&quot;, &quot;1111111&quot;);
    //        HashMap&lt;String, String&gt; user = new HashMap&lt;&gt;();
    //        user.put(&quot;name&quot;, &quot;张三&quot;);
    //        user.put(&quot;age&quot;, &quot;12&quot;);
    ObjectMapper mapper = new ObjectMapper();
    String jsonObj = mapper.writeValueAsString(user);
    return jsonObj;
}
</code></pre>
</li>
<li>
<p>将集合解析为json字串</p>
<ul>
<li>解析Map
<ul>
<li>和解析对象后的结果一样</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/j2&quot;)
public String testJ2() throws JsonProcessingException {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;name&quot;,&quot;张三&quot;) ;
    map.put(&quot;age&quot;, 18);
    ObjectMapper mapper = new ObjectMapper();
    String jObj = mapper.writeValueAsString(map);
    return jObj;
}
</code></pre>
<ul>
<li>解析List，数组和list的解决结果一样
<ul>
<li>解析后的果为：<code>[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;]</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/j3&quot;)
public String testJ3() throws JsonProcessingException {
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;张三&quot;);
    list.add(&quot;李四&quot;);
    list.add(&quot;王五&quot;);
    list.add(&quot;赵六&quot;);
    ObjectMapper mapper = new ObjectMapper();
    String jObj = mapper.writeValueAsString(list);
    return jObj;
}
</code></pre>
<ul>
<li>嵌套解析
<ul>
<li>解析后的果为：<code>{&quot;name&quot;:&quot;张三&quot;,&quot;朋友&quot;:[&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;],&quot;age&quot;:18}</code></li>
</ul>
</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/j4&quot;)
public String testJ4() throws JsonProcessingException {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;name&quot;,&quot;张三&quot;) ;
    map.put(&quot;age&quot;, 18);
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;李四&quot;);
    list.add(&quot;王五&quot;);
    list.add(&quot;赵六&quot;);
    map.put(&quot;朋友&quot;, list);
    ObjectMapper mapper = new ObjectMapper();
    String jObj = mapper.writeValueAsString(map);
    return jObj;
}
</code></pre>
</li>
</ul>
<h4 id="使用fastjson"><a class="header" href="#使用fastjson">使用FastJson</a></h4>
<ul>
<li>
<p>导包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.73&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>调用</p>
<ul>
<li>直接调用JSON的静态方法toJsonString转换json</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@RequestMapping(../../assets/java/j5&quot;)
public String testJ5() {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;name&quot;,&quot;张三&quot;) ;
    map.put(&quot;age&quot;, 18);
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;李四&quot;);
    list.add(&quot;王五&quot;);
    list.add(&quot;赵六&quot;);
    map.put(&quot;朋友&quot;, list);
    return JSON.toJSONString(map);
}
</code></pre>
<h2 id="ajax"><a class="header" href="#ajax">Ajax</a></h2>
<ul>
<li>编写后端操作</li>
</ul>
<pre><code class="language-java">@RestController
public class AjaxController {
    @RequestMapping(../../assets/java/testAjax/{value}&quot;)
    public boolean testAjax(@PathVariable(&quot;value&quot;) String value){
        return &quot;123&quot;.equals(value);
    }
}
</code></pre>
<ul>
<li>编写前端页面</li>
</ul>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
    &lt;body&gt;
        &lt;input type=&quot;text&quot; id=&quot;in&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;button&quot; id=&quot;bt&quot; value=&quot;提交&quot;/&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            $(function () {
                $('#bt').click(function () {
                    //使用ajax实现异步请求
                    $.post('${pageContext.request.contextPath}/testAjax/'+$('#in').val(), function (data) {
                        alert(data);
                    })
                });
            });
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="拦截器"><a class="header" href="#拦截器">拦截器</a></h2>
<ul>
<li>自定义类实现HandlerInterceptor接口</li>
</ul>
<pre><code class="language-java">public class MyInterceptor implements HandlerInterceptor {
     //拦截前
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //这里返回true说明通过
        //返回false说明被拦截
        return false;
    }
 	//拦截后
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }
	//清理
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>
<ul>
<li>spring 配置文件内添加：</li>
</ul>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--         /**代表所有路径下的请求全部拦--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean class=&quot;com.yang.interceptor.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<h2 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h2>
<ul>
<li>前端页面</li>
</ul>
<pre><code class="language-jsp">
</code></pre>
<ul>
<li>springxml文件里面配置文件上传的工具</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
        &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>​</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sunshineairline项目制作过程"><a class="header" href="#sunshineairline项目制作过程">SunshineAirline项目制作过程</a></h1>
<h2 id="搭建基本的ssm框架"><a class="header" href="#搭建基本的ssm框架">搭建基本的ssm框架</a></h2>
<ul>
<li>导入需要的jar包</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        mysql驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        junit jar包--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        mybatis jar 包--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.3&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>将java的语言环境设置为8</li>
</ul>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
<ul>
<li>编写文件过滤防止资源导不出</li>
</ul>
<pre><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li>添加web框架依赖</li>
<li>在artifacts自行添加lib目录</li>
<li>编写dp.properties文件</li>
</ul>
<pre><code class="language-properties">jdbc.classDriver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/session1?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
jdbc.username=用户名
jdbc.password=密码
</code></pre>
<ul>
<li>编写mybatis-conig配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.yang.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>编写spring-dao配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.classDriver}&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;--&gt;
        &lt;!--        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/yang/dao/*.xml&quot;/&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.yang.dao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>在web.xml内添加spring的调度器等</li>
</ul>
<pre><code class="language-xml">    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<ul>
<li>编写spring-mvc配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.yang.dao&quot;/&gt;

    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    &lt;mvc:interceptors&gt;--&gt;
    &lt;!--        &lt;mvc:interceptor&gt;--&gt;
    &lt;!--            &amp;lt;!&amp;ndash;         /**代表所有路径下的请求全部拦&amp;ndash;&amp;gt;--&gt;
    &lt;!--            &lt;mvc:mapping path=&quot;/**&quot;/&gt;--&gt;
    &lt;!--            &lt;bean class=&quot;com.yang.interceptor.MyInterceptor&quot;/&gt;--&gt;
    &lt;!--        &lt;/mvc:interceptor&gt;--&gt;
    &lt;!--    &lt;/mvc:interceptors&gt;--&gt;
    &lt;!--    解决json到前端页面的乱码问题--&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;objectMapper&quot;&gt;
                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;


    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
        &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>编写spring-service配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.yang.service&quot;/&gt;
    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.yang.service.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;userMapper&quot; ref=&quot;userMapper&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="前端页面框架"><a class="header" href="#前端页面框架">前端页面框架</a></h2>
<h3 id="使用layui"><a class="header" href="#使用layui">使用layui</a></h3>
<p>导入</p>
<pre><code class="language-html">&lt;!--在body前导入--&gt;
 &lt;link href=&quot;${pageContext.request.contextPath}/static/layui/css/layui.css&quot; rel=&quot;stylesheet&quot;/&gt;
&lt;!--在body闭合标签前导入--&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>编写登录页面</li>
</ul>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;登录&lt;/title&gt;
    &lt;link href=&quot;${pageContext.request.contextPath}/static/layui/css/layui.css&quot; rel=&quot;stylesheet&quot;/&gt;
&lt;/head&gt;
&lt;body style=&quot;background-color: #e2e2e2&quot;&gt;
&lt;div class=&quot;layui-row layui-col-space10&quot;&gt;
    &lt;div class=&quot;layui-col-md4&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;layui-col-md4&quot; style=&quot;margin-top: 10%&quot;&gt;
        &lt;form style=&quot;padding: 50px;&quot; class=&quot;layui-form layui-form-pane&quot; action=&quot;${pageContext.request.contextPath}/login&quot; method=&quot;post&quot;&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;h2&gt;Login&lt;/h2&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;email&quot; required lay-verify=&quot;email&quot; placeholder=&quot;Email&quot; autocomplete=&quot;off&quot;
                       class=&quot;layui-input&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;input type=&quot;password&quot; name=&quot;password&quot; required lay-verify=&quot;password&quot; placeholder=&quot;Password&quot;
                       autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;button class=&quot;layui-btn&quot; lay-submit lay-filter=&quot;formDemo&quot;&gt;login&lt;/button&gt;
                &lt;input type=&quot;checkbox&quot; style=&quot;float: right&quot; name=&quot;auto&quot; title=&quot;AutoLogin&quot;&gt;
            &lt;/div&gt;
        &lt;/form&gt;


    &lt;/div&gt;
    &lt;div class=&quot;layui-col-md4&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    layui.use('form', function () {
        var form = layui.form;
        form.verify({
            email:function (value) {
                console.log(value);
                if (value == null || ''== value){
                    return '用户名不能为空！';
                }
            },
            password:function (value) {
            if (value == null || ''== value){
                    return '密码不能为空！';
                }
            }
        })
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>编写dao层</li>
</ul>
<pre><code class="language-java">public interface UserMapper {
    Users getUser(String email, String password);

    List&lt;Users&gt; getAllUser();
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.yang.dao.UserMapper&quot;&gt;
    &lt;select id=&quot;getAllUser&quot; resultType=&quot;users&quot;&gt;
        select * from users limit 0, 10
    &lt;/select&gt;
    &lt;select id=&quot;getUser&quot; resultType=&quot;users&quot;&gt;
        select * from users where email= #{arg0} and password=#{arg1}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>编写service层</li>
</ul>
<pre><code class="language-java">public interface UserService {

    Users verification(String email, String password);

}
public class UserServiceImpl implements UserService {

    private UserMapper userMapper;
    public void setUserMapper(UserMapper userMapper) {
        this.userMapper = userMapper;
    }
    public Users verification(String email, String password) {
        return userMapper.getUser(email, password);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.yang.service.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userMapper&quot; ref=&quot;userMapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>编写controller层</li>
</ul>
<pre><code class="language-java">package com.yang.controller;

import com.yang.pojo.Users;
import com.yang.service.UserServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

/**
 * @auther YF
 * @create 2020-08-23-18:00
 */
@Controller
public class LoginController {

    public UserServiceImpl userServiceImpl;

    @Autowired
    @Qualifier(&quot;userServiceImpl&quot;)
    public void setUserService(UserServiceImpl userServiceImpl) {
        this.userServiceImpl = userServiceImpl;
    }

    @RequestMapping(&quot;/login&quot;)
    public String login(String email,
                        String password,
                        boolean auto,
                        HttpSession session){
        System.out.println(email+&quot;----------&quot;+password);
        Users users = userServiceImpl.verification(email, password);
        if (users != null){
            session.setAttribute(&quot;user&quot;, users);
            return &quot;main&quot;;
        }
        return &quot;login&quot;;
    }
}

</code></pre>
<ul>
<li>
<p>&lt;c:import/&gt; 标签引入文件的一些操作</p>
</li>
<li>
<p>引入一个页面是可以传递参数给被引入的页面，被引入的页在取是需要注意，需要使用<code>${param.名称}</code>进行取值</p>
</li>
</ul>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;!--需要引入的页面--&gt;
&lt;c:import url=&quot;../commont/head.jsp&quot;&gt;
    &lt;c:param name=&quot;importValues&quot; value=&quot;12312321&quot;/&gt;
&lt;/c:import&gt;
&lt;h1&gt;Office Menu&lt;/h1&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;${pageContext.request.contextPath}/static/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-jsp">&lt;!--被引入的页面的驱取值方式 --&gt;
&lt;h1&gt;${param.importValues}&lt;/h1&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shiro"><a class="header" href="#shiro">Shiro</a></h1>
<h2 id="认证authentication"><a class="header" href="#认证authentication">认证(Authentication)</a></h2>
<h3 id="身份principals"><a class="header" href="#身份principals">身份(principals)</a></h3>
<blockquote>
<p>一般对应用户名、邮箱</p>
</blockquote>
<h3 id="证明凭证credentials"><a class="header" href="#证明凭证credentials">证明/凭证(credentials)</a></h3>
<blockquote>
<p>一般对应密码</p>
</blockquote>
<h2 id="授权authorization"><a class="header" href="#授权authorization">授权(Authorization)</a></h2>
<h3 id="主体subject"><a class="header" href="#主体subject">主体(Subject)</a></h3>
<blockquote>
<p>对应用户等</p>
</blockquote>
<h3 id="资源"><a class="header" href="#资源">资源</a></h3>
<blockquote>
<p>对应菜单，按钮等</p>
</blockquote>
<h3 id="权限"><a class="header" href="#权限">权限</a></h3>
<blockquote>
<p>对应是否能对资源进行crud操作</p>
</blockquote>
<h3 id="角色"><a class="header" href="#角色">角色</a></h3>
<blockquote>
<p>权限集合</p>
</blockquote>
<h2 id="会话管理session-management"><a class="header" href="#会话管理session-management">会话管理(Session Management)</a></h2>
<h2 id="web-support"><a class="header" href="#web-support">Web Support</a></h2>
<h2 id="缓存caching"><a class="header" href="#缓存caching">缓存(Caching)</a></h2>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h2 id="测试testing"><a class="header" href="#测试testing">测试(Testing)</a></h2>
<h2 id="run-as"><a class="header" href="#run-as">Run As</a></h2>
<h2 id="remember-me"><a class="header" href="#remember-me">Remember Me</a></h2>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<h3 id="使用ini模拟登录"><a class="header" href="#使用ini模拟登录">使用ini模拟登录</a></h3>
<ul>
<li>Main.java</li>
</ul>
<pre><code class="language-java">import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;

public class Main {
    public static void main(String[] args) {
        IniSecurityManagerFactory factory = new IniSecurityManagerFactory();
        SecurityManager instance = factory.getInstance();
        SecurityUtils.setSecurityManager(instance);

        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken admin = new UsernamePasswordToken(&quot;admin&quot;, &quot;123456&quot;);

        try {
            subject.login(admin);
            System.out.println(&quot;登录成功&quot;);
        } catch (AuthenticationException e) {
            System.out.println(&quot;用户名或密码错误&quot;);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<ul>
<li>resources目录下新建shiro.ini</li>
</ul>
<pre><code class="language-ini">[users]
admin=123456
</code></pre>
<h3 id="使用ini文件模拟鉴权"><a class="header" href="#使用ini文件模拟鉴权">使用ini文件模拟鉴权</a></h3>
<ul>
<li>Main.java</li>
</ul>
<pre><code class="language-java">import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;

public class Main {
    public static void main(String[] args) {
        IniSecurityManagerFactory factory = new IniSecurityManagerFactory();
        SecurityManager instance = factory.getInstance();
        SecurityUtils.setSecurityManager(instance);

        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken user = new UsernamePasswordToken(&quot;admin&quot;, &quot;123456&quot;);
//        UsernamePasswordToken user = new UsernamePasswordToken(&quot;zs&quot;, &quot;123&quot;);

        try {
            subject.login(user);
            System.out.println(&quot;登录成功&quot;);

            // 角色校验
            boolean isAdmin = subject.hasRole(&quot;administrator&quot;);
            if (isAdmin){
                System.out.println(&quot;管理员登录&quot;);
            }else{
                System.out.println(&quot;非管理员登录&quot;);
            }

            // 权限校验
            if (subject.isPermitted(&quot;user:view&quot;)) {
                System.out.println(&quot;允许查看用户&quot;);
            }

            if (subject.isPermitted(&quot;user:delete&quot;)){
                System.out.println(&quot;允许删除用户&quot;);
            }

        } catch (AuthenticationException e) {
            System.out.println(&quot;用户名或密码错误&quot;);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<ul>
<li>resources目录下新建shiro.ini</li>
</ul>
<pre><code class="language-ini">[users]
admin=123456,administrator
zs=123,user

[roles]
administrator=user:view,user:insert,user:update,user:delete
user=user:view,user:update
</code></pre>
<h3 id="shiro加密"><a class="header" href="#shiro加密">Shiro加密</a></h3>
<pre><code class="language-java">import org.apache.shiro.crypto.hash.Sha256Hash;
import org.apache.shiro.crypto.hash.SimpleHash;

public class ShiroPassword {
    public static void main(String[] args) {

        String password = &quot;password&quot;;

        // sha加密
        Sha256Hash enc1 = new Sha256Hash(password);
        System.out.println(&quot;enc1 = &quot; + enc1);

        // 加盐加密
        Sha256Hash enc2 = new Sha256Hash(password, &quot;12345431&quot;);
        System.out.println(&quot;enc2 = &quot; + enc2);

        // 多次加密
        Sha256Hash enc3 = new Sha256Hash(password, &quot;1231&quot;, 4);
        System.out.println(&quot;enc3 = &quot; + enc3);

        // 选择加密方式加密
        SimpleHash enc4 = new SimpleHash(&quot;MD5&quot;, password);
        System.out.println(&quot;enc4 = &quot; + enc4);

    }
}
</code></pre>
<h3 id="使用自定义realm进行认证操作"><a class="header" href="#使用自定义realm进行认证操作">使用自定义Realm进行认证操作</a></h3>
<ul>
<li>CustomRealm.java</li>
</ul>
<pre><code class="language-java">import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.credential.Sha256CredentialsMatcher;
import org.apache.shiro.crypto.hash.Sha256Hash;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.util.ByteSource;


public class CustomRealm extends AuthenticatingRealm{


    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 获取用户名（身份）
        String username = token.getPrincipal().toString();

        // 获取密码（凭证）
        String password = String.valueOf(token.getCredentials());

        System.out.println(&quot;用户：&quot; + username + &quot;正在登录，密码为：&quot; + password);
        String passwdFromDB = null;
        // 从数据库获取密码进行匹配
        if (&quot;admin&quot;.equals(username)){
            passwdFromDB = &quot;4c2d82a2242bfb84249e563f5c9922e77ed6bd06683a37b2247d05fa63355235&quot;;
        } else if (&quot;zs&quot;.equals(username)){
            passwdFromDB = &quot;87109e4282dc3e6463bf06c66d3313c0c4137036b33ef0bf600262d1c8b8415a&quot;;
        }

       return new SimpleAuthenticationInfo(token.getPrincipal(), passwdFromDB, ByteSource.Util.bytes(&quot;abc&quot;), username);
    }
}
</code></pre>
<ul>
<li>resources目录下新建shiro.ini</li>
</ul>
<pre><code class="language-ini">[main]
# 密码匹配器
cm = org.apache.shiro.authc.credential.HashedCredentialsMatcher
# 加密算法
cm.hashAlgorithmName = SHA-256
# 加密迭代次数
cm.hashIterations = 5
# 是否保存为16进制编码方式
cm.storedCredentialsHexEncoded = true

# 自定义Realm
customRealm=com.demo.CustomRealm
customRealm.credentialsMatcher=$cm

securityManager.realms=$customRealm

[users]
admin=4c2d82a2242bfb84249e563f5c9922e77ed6bd06683a37b2247d05fa63355235,administrator
zs=87109e4282dc3e6463bf06c66d3313c0c4137036b33ef0bf600262d1c8b8415a,user

[roles]
administrator=user:view,user:insert,user:update,user:delete
user=user:view,user:update
</code></pre>
<ul>
<li>在之前的main方法内测试</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netty"><a class="header" href="#netty">Netty</a></h1>
<h2 id="nio"><a class="header" href="#nio">NIO</a></h2>
<ul>
<li>
<p><strong>通道和缓冲区</strong></p>
<ul>
<li>Java NIO系统的核心在于:通道(Channel)和缓冲区(Buffer)。通道表示打开到Io设备(例如:文件、套接字)的连接。若需要使用NIo系统，需要获取用于连接lO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</li>
</ul>
</li>
<li>
<p>缓冲区：</p>
<ul>
<li>底层为数组实现，用于存储不同类型的数据</li>
<li><code>put()</code>存入数据</li>
<li><code>get()</code>获取数据</li>
<li>缓冲区中四个核心数据
* </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-1"><a class="header" href="#spring-1">Spring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-security"><a class="header" href="#spring-security">Spring security</a></h1>
<h2 id="认证"><a class="header" href="#认证">认证</a></h2>
<p>cookie方式</p>
<p>浏览器登录系统，服务区返回一个session id并存储到服务器内，浏览器将session id存储到cookie内，进行操作时服务器判断是否有这session id</p>
<p>token方式</p>
<p>浏览器登录系统，服务器返回一个token令牌，服务器不用存储，浏览器可以将这个token令牌存储到浏览器的任意区域，，进行操作时时将token一起发送到服务器，服务器根据token的算法确认该用户想信息、</p>
<h2 id="授权"><a class="header" href="#授权">授权</a></h2>
<p>使用户可以对某个资源进行操作的过程交授权，类似linux的组、用户、</p>
<p>文件之间的关系，spring security 通过投票决策的方式对资源进行授权</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-cloud"><a class="header" href="#spring-cloud">Spring Cloud</a></h1>
<h2 id="注册中心"><a class="header" href="#注册中心">注册中心</a></h2>
<h3 id="eureka"><a class="header" href="#eureka">Eureka</a></h3>
<h3 id="nacos"><a class="header" href="#nacos">Nacos</a></h3>
<h2 id="配置中心"><a class="header" href="#配置中心">配置中心</a></h2>
<h3 id="nacos-1"><a class="header" href="#nacos-1">Nacos</a></h3>
<h3 id="配置优先级"><a class="header" href="#配置优先级">配置优先级</a></h3>
<h3 id="远程环境配置远程共享配置本地配置"><a class="header" href="#远程环境配置远程共享配置本地配置">远程环境配置&gt;远程共享配置&gt;本地配置</a></h3>
<h2 id="远程调用"><a class="header" href="#远程调用">远程调用</a></h2>
<h3 id="feign"><a class="header" href="#feign">Feign</a></h3>
<h3 id="ribbon-负载均衡"><a class="header" href="#ribbon-负载均衡">Ribbon 负载均衡</a></h3>
<h2 id="网关"><a class="header" href="#网关">网关</a></h2>
<h3 id="gateway"><a class="header" href="#gateway">Gateway</a></h3>
<h2 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h2>
<h3 id="springamqp"><a class="header" href="#springamqp">SpringAMQP</a></h3>
<blockquote>
<p>消息队列通用协议</p>
</blockquote>
<h3 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h3>
<h3 id="rocketmq"><a class="header" href="#rocketmq">RocketMQ</a></h3>
<h3 id="kafka"><a class="header" href="#kafka">Kafka</a></h3>
<h2 id="文本搜索"><a class="header" href="#文本搜索">文本搜索</a></h2>
<h3 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h3>
<h4 id="倒排索引"><a class="header" href="#倒排索引">倒排索引</a></h4>
<h4 id="分词器"><a class="header" href="#分词器">分词器</a></h4>
<h4 id="mapping"><a class="header" href="#mapping">mapping</a></h4>
<h4 id="dsl"><a class="header" href="#dsl">DSL</a></h4>
<h5 id="restclient-使用"><a class="header" href="#restclient-使用">RestClient 使用</a></h5>
<h4 id="查询语法"><a class="header" href="#查询语法">查询语法</a></h4>
<h4 id="数据同步"><a class="header" href="#数据同步">数据同步</a></h4>
<h2 id="限流容灾"><a class="header" href="#限流容灾">限流、容灾</a></h2>
<h3 id="sentinel"><a class="header" href="#sentinel">Sentinel</a></h3>
<h2 id="分布式事务"><a class="header" href="#分布式事务">分布式事务</a></h2>
<h3 id="seata"><a class="header" href="#seata">Seata</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">Mysql</a></h1>
<h2 id="安装步骤"><a class="header" href="#安装步骤">安装步骤</a></h2>
<ul>
<li>解压zip文件</li>
<li>配置mysql环境变量</li>
<li>在mysql文件夹里面新建一个my.ini文件</li>
</ul>
<pre><code class="language-mysql based">    [mysqlId]
    basedir=mysql安装目录\
    datadir=mysql安装目录\data\
    port=3306
    skip-grant-tables
</code></pre>
<ul>
<li>在mysql目录下新建data文件夹</li>
</ul>
<blockquote>
<p>以下命令在管理员权限下运行</p>
</blockquote>
<ul>
<li>
<p><code>mysqld --initialize --console</code> 初始化mysql</p>
</li>
<li>
<p><code>mysqld -install</code> 安装mysql</p>
</li>
<li>
<p><code>net start mysql</code> 启动mysql服务</p>
</li>
<li>
<p>然后再次启动mysql输入 <code>mysql -uroot -p</code>进入mysql管理界面</p>
<ul>
<li>
<p>进入界面后更改密码，出现<code>You must reset your password using ALTER USER statement before executing this statement.</code> 也是需要重置密码</p>
<ul>
<li>
<p><code>SET PASSWORD = PASSWORD('密码');</code></p>
</li>
<li>
<p><code>ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;</code></p>
</li>
<li>
<p><code>flush privileges;</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><del><code>update mysql.user set authentication_string=password('密码') where user='root' and Host='hocalhost';</code>（最后输入<code>flush privileges;</code> 刷新权限）</del></p>
<ul>
<li>
<p>修改my.ini文件，删除里面的skip-grant-tables即可</p>
</li>
<li>
<p>重启mysql</p>
<ul>
<li><code>net stop mysql</code></li>
<li><code>net start mysql</code></li>
</ul>
</li>
</ul>
<h2 id="简介-3"><a class="header" href="#简介-3">简介</a></h2>
<h3 id="mysql语言不区分大小写"><a class="header" href="#mysql语言不区分大小写">mysql语言不区分大小写</a></h3>
<ul>
<li>DDL 数据库定义语言</li>
<li>DML 数据库操作语言</li>
<li>DQL 数据库查询语言</li>
<li>DCL 数据库控制语言</li>
</ul>
<h3 id="操作数据库"><a class="header" href="#操作数据库"><strong>操作数据库</strong></a></h3>
<p>如果数据库里面的数据库名、表名、字段名是一个关键字需要加上 <strong>`</strong> 这个符号
1.创建数据库</p>
<pre><code class="language-sql">create database [if not exists] 数据库名;
</code></pre>
<p>2.删除数据库</p>
<pre><code class="language-sql">drop database [if exists] 数据库名;
</code></pre>
<p>3.使用数据库</p>
<pre><code class="language-sql">use 数据库名;
</code></pre>
<p>4.查看数据据库</p>
<pre><code class="language-sql">show databases --查看所有数据库
</code></pre>
<h3 id="数据库列的类型"><a class="header" href="#数据库列的类型"><strong>数据库列的类型</strong></a></h3>
<blockquote>
<p>数值</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>类型名称</th><th>大小</th><th>描述</th></tr></thead><tbody>
<tr><td>tinyint</td><td>1个字节</td><td>最小的数据</td></tr>
<tr><td>smallint</td><td>2个字节</td><td></td></tr>
<tr><td>mediumint</td><td>3个字节</td><td>中等大小的数据</td></tr>
<tr><td>int</td><td>4个字节</td><td>标准的整型（int的长度跟零填充有关不代表int的大小）</td></tr>
<tr><td>bigint</td><td>8个字节</td><td>较大的数据</td></tr>
<tr><td>float</td><td>4个字节</td><td>浮点型</td></tr>
<tr><td>double</td><td>8个字节</td><td>浮点型</td></tr>
<tr><td>decimal</td><td>字符串型浮点数</td><td>金融计算的时候使用</td></tr>
</tbody></table>
</div>
<blockquote>
<p>字符串</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>类型名称</th><th>大小</th><th>描述</th></tr></thead><tbody>
<tr><td>char</td><td>0~255</td><td>固定大小的字符串</td></tr>
<tr><td>varchar</td><td>0~65535</td><td>可边长的字符串（对应java里面的String）</td></tr>
<tr><td>tinytext</td><td>2^8 - 1</td><td>微型文本</td></tr>
<tr><td>text</td><td>2^16 - 1</td><td>文本串（保存大文本）</td></tr>
</tbody></table>
</div>
<blockquote>
<p>时间、日期</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>类型名称</th><th>描述</th></tr></thead><tbody>
<tr><td>date</td><td>YYYY-MM-dd</td></tr>
<tr><td>time</td><td>hh-mm-ss</td></tr>
<tr><td>datetime</td><td>YYYY-MM-dd hh-mm-ss</td></tr>
<tr><td>timestamp</td><td>时间戳，1970年1月1日到现在的毫秒数</td></tr>
<tr><td>year</td><td>年份</td></tr>
</tbody></table>
</div>
<blockquote>
<p>null 空类型</p>
</blockquote>
<h3 id="数据库的字段属性"><a class="header" href="#数据库的字段属性"><strong>数据库的字段属性</strong></a></h3>
<ul>
<li>unsigned
<ul>
<li>无符号整型</li>
<li>声明类该列不能为负数</li>
</ul>
</li>
<li>zerofill
<ul>
<li>0填充</li>
<li>不足的位数用零填充</li>
</ul>
</li>
<li>auto_increment
<ul>
<li>自动递增, 默认再上一条记录的基础上加一</li>
<li>通常来设计唯一的主键， 必须是整数类型</li>
<li>可以自定义增长的起始值和步长</li>
</ul>
</li>
<li>not null
<ul>
<li>数据不能为空</li>
</ul>
</li>
<li>default
<ul>
<li>设置默认值</li>
</ul>
</li>
</ul>
<hr />
<p>每一个表都必须存在下面5个字段（之后使用）</p>
<pre><code class="language-sql">    id --主键
    `version` --乐观锁
    is_delete --伪删除
    gmt_create --创建时间
    gmt_update --修改时间
</code></pre>
<h3 id="创建数据库表"><a class="header" href="#创建数据库表">创建数据库表</a></h3>
<pre><code class="language-sql">-- 如果该表不存在则创建该表
CREATE TABLE IF NOT EXISTS `teacher` (
    `id` INT NOT NULL auto_increment COMMENT '工号', -- 自增
    `name` VARCHAR ( 20 ) NOT NULL DEFAULT '未命名' COMMENT '姓名',
    `password` VARCHAR ( 30 ) NOT NULL DEFAULT '1' COMMENT '密码',
    `sex` VARCHAR ( 2 ) NOT NULL DEFAULT '男' COMMENT '性别',
    `birthday` datetime DEFAULT NULL COMMENT '出生日期',
    `address` VARCHAR ( 50 ) DEFAULT NULL COMMENT '家庭住址',
    `email` VARCHAR ( 50 ) DEFAULT NULL COMMENT '邮箱',
    PRIMARY KEY ( `id` ) -- 主键
) ENGINE = INNODB DEFAULT CHARSET = 'utf8'; -- 数据库引擎和默认字符集
</code></pre>
<ul>
<li>格式</li>
</ul>
<pre><code class="language-sql">create table [if not exists] `表名`(
    `字段名` 类型 [属性] [索引] [注释],
    `字段名` 类型 [属性] [索引] [注释],
    ...
    `字段名` 类型 [属性] [索引] [注释]
)[表类型] [字符集] [注释];
</code></pre>
<ul>
<li>常用命令</li>
</ul>
<pre><code class="language-sql">    SHOW CREATE DATABASE `数据库名`; -- 查看数据库创建的语句 
    SHOW CREATE TABLE `表名`; -- 查看表的创建语句
    DESC(或DESCRIBE) `表名`; -- 查看表的具体结构
</code></pre>
<h3 id="数据表的类型"><a class="header" href="#数据表的类型">数据表的类型</a></h3>
<ul>
<li>关于数据表引擎
<ul>
<li>INNODB 默认使用</li>
<li>MYISAM 早些年使用</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody>
<tr><td>事务支持</td><td>不支持</td><td>支持</td></tr>
<tr><td>数据行锁定</td><td>不支持(锁定表)</td><td>支持</td></tr>
<tr><td>外键约束</td><td>不支持</td><td>支持</td></tr>
<tr><td>全文索引</td><td>支持</td><td>不支持</td></tr>
<tr><td>表空间大小</td><td>较小</td><td>较小(约MYISAM的两倍)</td></tr>
</tbody></table>
</div>
<ul>
<li>常规使用操作
<ul>
<li>MYISAM 节约空间、速度较快</li>
<li>INNODB 安全性高、事务的处理、多表都多用户操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>在数据库中存在的位置</p>
</blockquote>
<p><strong>所有数据库文件都存储在mysql安装目录下的data文件夹下，本质上还是文件存储</strong></p>
<hr />
<ul>
<li>INNODB和MYISAM引擎在屋里文件上的区别
<ul>
<li>INNODB 在数据库表中只有一个*.frm文件，以及上一级目录的ibdata1文件</li>
<li>MYISAM对应文件
<ul>
<li>*.frm 表结构定义文件</li>
<li>*.MYD 数据文件（data）</li>
<li>*.MYI 索引文件（index）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>设置数据库表的字符集编码</p>
</blockquote>
<p><code>charset=utf8</code></p>
<p>不设置的话创建的表就是mysql的默认编码，
mysql的默认编码是Latin1，可以在mysql目录下的my.ini文件里添加<code>character-set-server=utf8</code>
建议在创建表的时候加默认编码</p>
<h3 id="修改删除表"><a class="header" href="#修改删除表">修改删除表</a></h3>
<blockquote>
<p>修改</p>
</blockquote>
<pre><code class="language-sql">    -- 重命名
    ALTER TABLE `旧表名` RENAME `新表名`;
    -- 添加字段
    ALTER TABLE `表名` ADD `字段名` 类型 [属性] [索引] [注释];
    -- 修改字段约束
    ALTER TABLE tea MODIFY `字段名` 类型 [属性] [索引] [注释];
    -- 修改字段名
    ALTER TABLE tea CHANGE `旧字段名` `新字段名` 类型;
    -- 删除字段
    ALTER TABLE tea DROP `字段名`;
</code></pre>
<blockquote>
<p>删除</p>
</blockquote>
<pre><code class="language-sql">    -- 删除表（如果存在）
    DROP TABLE IF EXISTS `表名`;
</code></pre>
<p><strong>所有创建删除操作尽量加上判断，以免报错</strong></p>
<h3 id="mysql数据管理"><a class="header" href="#mysql数据管理">Mysql数据管理</a></h3>
<ul>
<li>
<h4 id="外键"><a class="header" href="#外键">外键</a></h4>
</li>
</ul>
<blockquote>
<p>方式一、创建表时添加好外键</p>
</blockquote>
<pre><code class="language-sql">    create table `subject`(
        `subject_id` int auto_increment not null comment '科目id',
        `subject_name` varchar(40) not null comment '科目名称',
        primary key(`subject_id`)
    )engine=innodb default charset=utf8;
    
    create table `student`(
        `id` int not null auto_increment comment '学生id',
        `name` varchar(20) not null comment '学生姓名',
        `subject_id` int not null comment '科目id',
        primary key(`id`),
        key `FK_subject_id` (`subject_id`), -- 外键语句
        constraint `FK_subject_id` foreign key(`subject_id`) references `subject`(`subject_id`)
    )engine=innodb default charset=utf8;
</code></pre>
<blockquote>
<p>方式二、创建表后给需要添加外键的表添加外键</p>
</blockquote>
<pre><code class="language-sql">    create table `subject`(
        `subject_id` int auto_increment not null comment '科目id',
        `subject_name` varchar(40) not null comment '科目名称',
        primary key(`subject_id`)
    )engine=innodb default charset=utf8;
    
    create table `student`(
        `id` int not null auto_increment comment '学生id',
        `name` varchar(20) not null comment '学生姓名',
        `subject_id` int not null comment '科目id',
        primary key(`id`)
    )engine=innodb default charset=utf8;
    -- 添加外键
    alter table `student` 
    add constraint `FK_subject_id` foreign key(`subject_id`) references `subject`(`subject_id`);
</code></pre>
<p><strong>以上方式都是添加物理外键方式数据库内的表多了之后会造成表之间的关系混乱不建议是使用</strong></p>
<p><strong>注意：删除有外键关系的表时，需要先删除引用被人的表（从表），再删除被引用的表（主表）</strong></p>
<p><strong>实现方式</strong></p>
<ul>
<li>数据库就是单纯的表，只用来存放数据，只有行（数据）和列（字段）</li>
<li>再程序里实现外键的方式</li>
</ul>
<hr />
<h3 id="dml语言"><a class="header" href="#dml语言">DML语言</a></h3>
<p><strong>数据库的意义</strong>：存储数据，数据管理</p>
<p><strong>DML语言</strong>：数据库操作语言</p>
<ul>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
<h4 id="添加"><a class="header" href="#添加">添加</a></h4>
<blockquote>
<p>insert</p>
</blockquote>
<pre><code class="language-sql">    -- 因为id自增只用写一个列名
    insert into `表名` (`列名1`, `列名2`, `列名3`...) values ('值1','值2','值3'...);
    -- 如果不写列名则需要写所有列匹配的值
    insert into `表名` values ('值1','值2','值3'...);
    -- 一次可以插入多行数据
    insert into `表名` (`列名1`, `列名2`, `列名3`...) values
    ('值1','值2','值3'...),
    ('值1','值2','值3'...),
    ('值1','值2','值3'...),
    ('值1','值2','值3'...);
</code></pre>
<h4 id="修改"><a class="header" href="#修改">修改</a></h4>
<blockquote>
<p>update</p>
</blockquote>
<pre><code class="language-sql">    update `表名` set  `字段名1`=值1, [`字段名2`=值2,...] where [条件];
</code></pre>
<p>条件：where子句 运算符 某列的等于或大于某个值，或再那个区间</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody>
<tr><td>=</td><td>等于</td></tr>
<tr><td>&lt;&gt;或!=</td><td>不等于</td></tr>
<tr><td>&gt;</td><td></td></tr>
<tr><td>&gt;=</td><td></td></tr>
<tr><td>&lt;</td><td></td></tr>
<tr><td>&lt;=</td><td></td></tr>
<tr><td>between...and...</td><td>在某个范围区间</td></tr>
<tr><td>and</td><td>与</td></tr>
<tr><td>or</td><td>或</td></tr>
</tbody></table>
</div>
<h4 id="删除"><a class="header" href="#删除">删除</a></h4>
<blockquote>
<p>delete</p>
</blockquote>
<pre><code class="language-sql">    delete form `表名` [where 条件];
</code></pre>
<blockquote>
<p>truncate</p>
</blockquote>
<pre><code class="language-sql">    truncate `subject`; -- 清空表
</code></pre>
<blockquote>
<p>delete和truncate的区别</p>
</blockquote>
<ul>
<li>相同点：都能删除数据，都不会删除表结构</li>
<li>不同：
<ul>
<li>truncate会重新设置自增列，自增计数器会归零</li>
<li>truncate不会影响事务</li>
</ul>
</li>
</ul>
<p><strong>delete的删除问题</strong>：在重启数据库后自增列会从1开始（问题不确定）</p>
<hr />
<h3 id="dql数据查询"><a class="header" href="#dql数据查询">DQL数据查询</a></h3>
<h4 id="dql"><a class="header" href="#dql">DQL</a></h4>
<p>(Data Query Language)数据查询语言</p>
<ul>
<li>select 语法</li>
</ul>
<pre><code class="language-sql">SELECT [All | DISTINCT]
{* | 表名.* | [表名1.列名1[as 列名的别名][,表名2.列名2[as 列名的别名]][,...]]}
FROM 表名 [as 表名的别名]
        [left | right | inner join 表名2] -- 连表查询
        [WHERE] -- 指定结果徐满足的条件
        [GROUP BY] -- 指定结果按那几个字段进行分组
        [HAVING] --过滤分组记录必须满足的次要条件
        [ORDER BY] -- 指定查询记录按一个或多个条件进行分组
        [LIMIT {[offset,]row_count row_countOFFSET offset}]; --指定查询的记录从那条至哪条
</code></pre>
<pre><code class="language-sql">    -- as关键字：可以给字段起别名也可以给表起别名    
    -- concat(s1, s2)函数 连接字符串
    select concat(字符串1, 字符串2, 字符串3...) from 表名;

    -- distinct 去除重复的数据只显示重复数据里面的一条
    select distinct 列名 from 表名;

    -- 查看mysql版本
    select version();

    -- 用于计算
    select 计算的式子例如: 1+100 as 显示的列名;

    -- 查询自增的步长
    select @@auto_increment_increment;

    -- 列名后面加上一个数字如果该列类型为数值类型则显示的结果为该列的数据加上那个数字的结果
    select 列名+1 from 表名;

    -- in 关键字 查询某条数据里的某个字段在一些具体的数据中
    select 列名 from 表名 where 列名 in (值1, 值2, 值3...);

    -- null is null 空 非空
    select 列名 from 表名 where 列名 is null; -- 查询该表的某个字段为空的记录
    select 列名 from 表名 where 列名 is not null; -- 查询该表的某个字段不为空的记录

</code></pre>
<ul>
<li>链表查询 JOIN</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody>
<tr><td>inner join</td><td>如果表中至少有一个匹配则返回该行</td></tr>
<tr><td>left join</td><td>会从左表中返回所有的值，即使右表中没有匹配</td></tr>
<tr><td>right join</td><td>会从右表中返回所有的值，即使左表中没有匹配</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>自连接</p>
</li>
<li>
<p>排序</p>
</li>
</ul>
<pre><code class="language-sql">    -- ASC(默认)升序 DESC 降序
    order by 列名 ASC | DESC
</code></pre>
<ul>
<li>分页</li>
</ul>
<pre><code class="language-sql">    -- 例如 limit 0, 5 页面大小为5 显示从第1条记录开始到第5条 表示第一页（偏移量从零开始）
            limit 5, 5 页面大小为5 显示从第6条记录开始到第5条 表示第二页
            limit 10, 5 页面大小为5 显示从第11条记录开始到第5条 表示第三页
            第n页为 limit (当前页数 - 1) * 页面大小, 页面大小
    limit 起始下标, 页面大小
</code></pre>
<ul>
<li>子查询
where 的条件里面嵌套另一个查询语句</li>
</ul>
<pre><code class="language-sql">    -- 查询预订号小于4000，gate 为'G33'的乘客的姓名
    -- 联表查询方式
    SELECT distinct  u.UserId, CONCAT(u.FirstName,' ', u.LastName) AS 联表
    FROM users u
    JOIN flightreservation f
    ON u.UserId = f.UserId
    JOIN `schedule` s
    ON f.ScheduleId = s.ScheduleId
    WHERE f.ReservationId &lt; 4000
    AND	s.Gate = 'G33'
    ORDER BY u.UserId;
    -- 子查询方式
    SELECT UserId, CONCAT(FirstName,' ', LastName) AS 子查询
    FROM users
    WHERE UserId IN	(
        SELECT UserId 
        FROM flightreservation
        WHERE ReservationId &lt; 4000
        AND ScheduleId IN (
            SELECT ScheduleId
            FROM `schedule`
            WHERE Gate = 'G33'
        )
    )
    ORDER BY UserId
</code></pre>
<ul>
<li>函数
<ul>
<li>数学类函数</li>
<li>字符串类函数</li>
</ul>
</li>
<li>日期类函数</li>
</ul>
<pre><code class="language-sql">    SELECT current_time(); 
    SELECT CURRENT_DATE(); 
    SELECT CURRENT_TIMESTAMP();
    SELECT NOW();
    SELECT LOCALTIME();
    SELECT SYSDATE();
    -- 获取一个时间的年、月、日、时、分、秒
    SELECT YEAR(NOW());
    SELECT MONTH(NOW());
    SELECT DAY(NOW());
    SELECT HOUR(NOW());
    SELECT MINUTE(NOW());
    SELECT Second(NOW());
</code></pre>
<ul>
<li>系统</li>
</ul>
<pre><code class="language-sql">    SELECT USER(); -- 系统用户
    SELECT SYSTEM_USER(); -- 系统用户
    SELECT VERSION(); -- 当前mysql的版本
</code></pre>
<ul>
<li>聚合函数</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody>
<tr><td>COUNT()</td><td>计数</td></tr>
<tr><td>AVG()</td><td>平均值</td></tr>
<tr><td>MAX()</td><td>最大值</td></tr>
<tr><td>MIN()</td><td>最小值</td></tr>
<tr><td>SUM()</td><td>求和</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<ul>
<li>COUNT() 函数</li>
</ul>
<pre><code class="language-sql">    COUNT(字段) 会忽略所有的null值
    COUNT(*)    不会忽略所有的null值
    COUNT(1)    不会忽略所有的null值
</code></pre>
<ul>
<li>分组</li>
</ul>
<pre><code class="language-sql">    group by 列名 -- 根据那个列名进行分组
    having -- 分组后的过滤条件
</code></pre>
<ul>
<li>MD5() 函数 加密函数</li>
</ul>
<h3 id="事务"><a class="header" href="#事务">事务</a></h3>
<p><strong>要么都成功，要么都失败</strong></p>
<blockquote>
<p>事务原则：ACID原则 原子性、一致性、隔离性、持久性 （脏读、幻读、不可重复读）</p>
</blockquote>
<ul>
<li>原子性（Atomicity）
<ul>
<li>要么都成功，要么都失败</li>
</ul>
</li>
<li>一致性（Consistency）
<ul>
<li>事务前后的数据完整性要保证一致</li>
</ul>
</li>
<li>持久性（Durability）
<ul>
<li>事务一旦提交就不可逆，被持久化到数据库内</li>
</ul>
</li>
<li>隔离性（Isolation）
<ul>
<li>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务操作数据所干扰，多个事务之间要相互隔离</li>
<li>隔离所导致的问题‘
<ul>
<li>脏读：指一个事务读取到了另一个事务未提交的数据</li>
<li>不可重复读：在一个事务内读取表中的某一行数据，多次读取的结果不同。（这不是错误，只是某些场合不对）</li>
<li>幻读：指一个事务读取到了另一个事务所插入的数据，导致前后读取不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-sql">    -- mysql时默认开启事务自动提交的
    SET autocommit=0 -- 关闭自动提交事务
    SET autocommit=1 -- 开启自动提交事务
    
    
    -- 手动处理事务
    SET autocommit=0 -- 关闭自动提交事务
    
    -- 开启事务 
    START TRANSACTION -- 标记一个事务的开启，从这之后的sql都在同一个事务内
    /*
    sql语句
    ...
    ...
    */
    -- 提交：持久化 (如果成功)
    COMMIT
    -- 回滚：回到最开始的位置 (如果失败)
    ROLLBACK
    
    -- 事务结束
    -- STOP TRANSACTION
    SET autocommit=1 -- 开启自动提交事务
    
    
    -- 其他
    
    SAVEPOINT 保存点名 -- 设置事务保存点
    
    ROLLBACK SAVEPOINT 保存点名 -- 回滚到设置好的事务保存点
    
    RELEASE SAVEPOINT 保存点名 -- 撤销事务保存点
</code></pre>
<ul>
<li>模拟事务：李四给王五转账500元</li>
</ul>
<pre><code class="language-sql">    -- 创建表
    CREATE TABLE `accountInfo`(
            id int not null auto_increment comment '用户id',
            `name` varchar(30) not null comment '用户姓名',
            `password` varchar(50) default MD5('123456') comment '用户密码',
            amount int default 0 comment '用户金额',
            primary key(`id`)
          )engine=innodb default charset=utf8;
    -- 插入数据  
    insert into `accountInfo` (`name`, `password`, amount) values
    ('张三', MD5('zhangsan'), 2000),
    ('李四', MD5('lisi'), 8000),
    ('王五', MD5('wangwu'), 500);
    -- 模拟事务场景
    SET autocommit=0; -- 关闭自动提交事务
    START TRANSACTION;
    -- 李四给王五转账500元
    UPDATE accountInfo SET amount= amount-500 WHERE id = 2;
    UPDATE accountInfo SET amount= amount+500 WHERE id = 3;
    -- 提交事务
    COMMIT;
    -- 回滚
    ROLLBACK;
    set autocommit=1;  -- 开启自动提交事务
SELECT * FROM accountInfo;

</code></pre>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<blockquote>
<p>mysql官方对索引的定义：索引（index）是帮助mysql高效获取数据的数据结构
提取句子的主干就可以得到索引的本质，索引就是数据结构</p>
</blockquote>
<ul>
<li>索引的分类
<ul>
<li>主键索引（primary key）
<ul>
<li>唯一的表示，主键不可重复，只有一列能作为主键</li>
</ul>
</li>
<li>唯一索引（unique key）
<ul>
<li>避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引</li>
</ul>
</li>
<li>常规索引（key/index）
<ul>
<li>默认的，index获key关键字来修饰</li>
</ul>
</li>
<li>全文索引（fulltext）
<ul>
<li>在特定数据库引擎才有（MYSIAM）</li>
<li>快速定位数据</li>
</ul>
</li>
</ul>
</li>
<li>基础语法</li>
</ul>
<pre><code class="language-sql">    -- 索引的使用
    -- 1、在创建表的时候给字段添加索引
    -- 2、创建完毕后，再添加索引
    
    -- 显示某个表内的所有的所有信息
    SHOW INDEX FROM 表名;
    -- 方式一
    -- 增加一个全文索引
    ALTER TABLE 表名 ADD FULLTEXT INDEX 索引名(列名);
    -- EXPLAIN 分析sql执行的状况
    EXPLAIN SELECT * FROM 表名;
    -- 设置了全文索引的分析语句
    EXPLAIN SELECT * FROM 表名 WHERE MATCH(列名) against(值);
    -- 方式二
    CREATE INDEX 索引名 ON 表名(列名);
</code></pre>
<ul>
<li>测试索引</li>
</ul>
<pre><code class="language-sql">    -- 查询航班预约表内电话号为767-867-1030的用户
    -- 未添加索引 &gt; 时间: 0.042s
    SELECT * FROM flightreservation WHERE Phone = '767-867-1030';
    -- 未添加索引 分析查询行数57960行
    EXPLAIN SELECT * FROM flightreservation WHERE Phone = '767-867-1030';
    -- 给该表内的phone字段添加索引
    CREATE INDEX flightreservation_Phone ON flightreservation(Phone);
    -- 添加索引后 &gt; 时间: 0s
    SELECT * FROM flightreservation WHERE Phone = '767-867-1030';
    -- 添加索引后 分析查询行数6行
    EXPLAIN SELECT * FROM flightreservation WHERE Phone =  '767-867-1030';
</code></pre>
<ul>
<li>索引原则
<ul>
<li>索引不是越多越好</li>
<li>经常变动的数据不要加索引</li>
<li>小数据量的表不需要加索引</li>
<li>索引一般加在常用来查询的字段上</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引的数据结构</p>
</blockquote>
<ul>
<li>Hash 类型</li>
<li>Btree INNODB 默认结构</li>
</ul>
<h3 id="用户管理-1"><a class="header" href="#用户管理-1">用户管理</a></h3>
<ul>
<li>用户表：mysql.user 本质是对这张表进行增删改查</li>
<li>常用操作</li>
</ul>
<pre><code class="language-sql">    -- 创建用户
    CREATE USER 用户名 IDENTIFIED BY 密码;
    -- 修改密码（修改当前用户）
    SET PASSWORD = PASSWORD(新密码);
    -- 修改密码（修改指定用户）
    SET	PASSWORD FOR 用户名 = PASSWORD(新密码);
    -- 重命名
    RENAME USER 原用户名 TO 新用户名;
    -- 用户授权 ALL PRIVILEGES 全部权限 
    GRANT ALL PRIVILEGES ON 数据库名.表名 TO 用户名;
    -- 查看权限
    SHOW GRANTS FOR 用户名;
    -- 撤销权限
    REVOKE 那些权限 ON 那个库 FROM 谁;
    -- 删除用户
    DROP USER 用户名;
</code></pre>
<h3 id="备份"><a class="header" href="#备份">备份</a></h3>
<ul>
<li>命令行操作</li>
</ul>
<pre><code class="language-bash">    # 导出 表名可不填 不填会到处该数据库的全部表
    mysqldump -h主机 -u用户名 -p密码 数据库名 [表名1[表名2[表名3...]]] &gt; 目标路径+文件名
    # 导入 先登录
    source 目标sql路径
</code></pre>
<h3 id="数据库设计规范"><a class="header" href="#数据库设计规范">数据库设计规范</a></h3>
<p><strong>当数据库比较复杂的时候需要设计数据库了</strong></p>
<ul>
<li>糟糕的数据库设计：
<ul>
<li>数据冗余、浪费控件</li>
<li>数据库删除和插入都会麻烦、异常（屏蔽物理外键）</li>
<li>程序性能差</li>
</ul>
</li>
<li>良好的数据库设计：
<ul>
<li>节省内存空间</li>
<li>保证数据库的完整性</li>
<li>方便我们开发</li>
</ul>
</li>
</ul>
<p><strong>软件开发中，关于数据库的设计</strong></p>
<ul>
<li>分析需求：分析业务和需要处理的数据库需求</li>
<li>概要设计：设计关系ER图</li>
</ul>
<h3 id="三大范式"><a class="header" href="#三大范式">三大范式</a></h3>
<p><strong>为什么需要数据规范化</strong></p>
<ul>
<li>信息重复</li>
<li>更新异常</li>
<li>插入异常
<ul>
<li>无法正常显示信息</li>
</ul>
</li>
<li>删除异常
<ul>
<li>丢失有效信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>三大范式</p>
</blockquote>
<p><strong>第一范式</strong></p>
<ul>
<li>原子性：保证每一列不可再分</li>
</ul>
<p><strong>第二范式</strong></p>
<ul>
<li>前提：满足第一范式</li>
<li>每张表只描述一件事情</li>
</ul>
<p><strong>第三范式</strong></p>
<ul>
<li>前提：满足第一范式、第二范式</li>
<li>要确保数据表中的每一列数据都和主键唯一相关，而不能简介相关</li>
</ul>
<p>规范数据库设计</p>
<p><strong>规范性和性能问题</strong></p>
<p>关联查询的表不能超过三张表</p>
<ul>
<li>考虑商业化的需求和目标，（成本、用户体验）数据库的性能更加重要</li>
<li>在规范性能问题的时候，需要适当考虑下规范性</li>
<li>故意给某些表增加一些冗余字段（从多表查询变为单表查询）</li>
<li>故意增加一些计算列（从大数据量变为小数据量的查询：索引）</li>
</ul>
<h3 id="mysql-data文件迁移"><a class="header" href="#mysql-data文件迁移">mysql data文件迁移</a></h3>
<ul>
<li>
<p>mysql整个文件夹直接复制到迁移的目录，mysql data目录只保留所有文件夹和ibdata1文件，其它文件全删了</p>
</li>
<li>
<p>修改my.ini文件里面对应的路径</p>
</li>
<li>
<p>打开注册表输入<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL</code>最后的目录是自己的mysql服务名称，修改ImagePath为新的目录地址</p>
</li>
<li>
<p>已管理员启动cmd 输入<code>net start mysql</code> 启动成功</p>
</li>
<li>
<p>可以遇到<code>发生系统错误 2。找不到指定文件</code>报错，运行<code>mysqld --remove</code>和<code>mysqld --install</code>命令后再次重启</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="http://nginx.org/en/">官网</a></li>
<li><a href="http://hg.nginx.org/nginx/branches">下载地址</a></li>
<li>解压</li>
<li>安装依赖包</li>
</ul>
<pre><code class="language-bash">apt install -y libpcre3 libpcre3-dev zlib1g-dev openssl libssl-dev
</code></pre>
<ul>
<li>进入解压后的目录</li>
</ul>
<pre><code class="language-bash">./configure --prefix=nginx编译后文件存放的位置
</code></pre>
<ul>
<li>编译</li>
</ul>
<pre><code class="language-bash">make &amp;&amp; make install
</code></pre>
<ul>
<li>
<p>进入编译好的conf文件夹内</p>
</li>
<li>
<p>使用<a href="nginx/../assets/nginx/nginx.conf">nginx.conf</a>替换配置文件</p>
</li>
<li>
<p>关闭nginx</p>
<ul>
<li>进入nginx的安装目录<code>nginx/sbin</code></li>
<li>关闭nginx：<code>./nginx -s stop</code></li>
</ul>
</li>
</ul>
<h2 id="正向代理反向代理"><a class="header" href="#正向代理反向代理">正向代理/反向代理</a></h2>
<ul>
<li>
<p>正向代理，代理客户端</p>
</li>
<li>
<p>反向代理，代理服务端</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<ul>
<li>
<p><a href="https://redis.io/">官网</a></p>
</li>
<li>
<p><a href="https://redis.io/download/#redis-downloads">下载地址</a></p>
</li>
</ul>
<h2 id="安装redis"><a class="header" href="#安装redis">安装redis</a></h2>
<ul>
<li>
<p>使用网络下载redis文件，这里以redis-6.2.4.tar.gz为例</p>
</li>
<li>
<p>解压</p>
<ul>
<li>
<pre><code class="language-shell">tar -zxvf redis-6.2.4.tar.gz -C 目标目录
</code></pre>
</li>
</ul>
</li>
<li>
<p>进入到解压目录的redis-6.2.4文件夹下</p>
</li>
<li>
<p>编译并安装redis</p>
<ul>
<li>
<p>安装make工具</p>
<ul>
<li>
<pre><code class="language-shell">apt install gcc automake autoconf libtool make
</code></pre>
</li>
</ul>
</li>
<li>
<p>编译安装，会在对应目录下创建一个bin目录</p>
<ul>
<li>
<pre><code class="language-shell">make PREFIX=编译文件的目录 install
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>在编译redis的目录下创建data、logs文件夹，复制<a href="redis/../assets/redis/redis.conf">redis.conf</a>文件到编译目录下</p>
</li>
<li>
<p>修改redis.conf内的信息</p>
<ul>
<li>修改dir路径信息，在456行左右，修改为刚创建的data文件夹目录</li>
<li>修改logfile路径信息，在304行左右，修改为刚创建的logs文件夹目录</li>
<li>修改密码（requirepass），在903行左右</li>
<li>其他配置默认即可，防火墙开启6379端口即可外部访问</li>
</ul>
</li>
</ul>
<h1 id="使用systemctl管理redis服务"><a class="header" href="#使用systemctl管理redis服务">使用systemctl管理redis服务</a></h1>
<ul>
<li>
<p>复制当前文档下的<a href="redis/../assets/redis/redis.service">redis.service</a>文件到/lib/systemd/system目录下</p>
</li>
<li>
<p>修改文件内ExecStart、ExecReload、ExecStop配置的路径信息为自己的路径即可</p>
</li>
<li>
<p>刷新systemctl配置</p>
<ul>
<li>
<pre><code class="language-shell">systemctl daemon-reload
</code></pre>
</li>
</ul>
</li>
<li>
<p>将redis服务设置为开机启用</p>
<ul>
<li>
<pre><code class="language-shell">systemctl enable redis.service
</code></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neovim"><a class="header" href="#neovim">Neovim</a></h1>
<h1 id="键位"><a class="header" href="#键位">键位</a></h1>
<ul>
<li>
<p><code>sp</code> 垂直分割窗口，<code>vsp</code> 水平分割窗口</p>
</li>
<li>
<p><code>new</code>垂直新建一个窗口，<code>vnew</code>水平新建一个窗口</p>
</li>
<li>
<p><code>ctrl+w+[h|j|k|l]</code>上下左右切换窗口</p>
</li>
<li>
<p><code>:noh</code>或<code>:nohlsearch</code>取消搜索后的高亮</p>
</li>
<li>
<p><code>ctrl+a/ctrl+x</code>让数值加1/减1</p>
</li>
<li>
<p><code>@:</code> 执行上一条命令</p>
</li>
<li>
<p><code>R</code> 进入Replace模式</p>
</li>
<li>
<p><code>vim 文件名</code>：创建或打开一个文件</p>
<ul>
<li>三种模式：
<ul>
<li>正常模式：	
<ul>
<li>使用vim打开一个文档就直接进入一般模式</li>
<li><code>yy</code>：复制（<code>5yy</code>：可以复制5行）、<code>p</code>：粘贴</li>
<li><code>dd</code>：删除（<code>5dd</code>：可以删除5行）</li>
<li><code>u</code>：撤销</li>
<li><code>G</code>：定位到最后一行</li>
<li><code>gg</code>：定位到第一行（<code>5gg</code>：定位到第5行）</li>
</ul>
</li>
<li>编辑模式：
<ul>
<li>按下i、I、o、O、a、A、R等任意一个字母后进入编辑模式，编辑模式安Esc进入命令行模式</li>
</ul>
</li>
<li>命令行模式：
<ul>
<li>在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的</li>
<li><code>:set nu</code>：打开行号</li>
<li><code>:set nonu</code>：关闭行号</li>
<li><code>:wq</code>：保存并退出	</li>
<li><code>:q</code>：退出</li>
<li><code>:q!</code>：强制退出</li>
<li><code>:数字</code>：定位到多少行</li>
<li><code>\关键字</code>：查找某个字符，按<code>n</code>查找下一个</li>
<li>关机或重启会自动使用<code>sync</code>同步数据，</li>
<li><code>:help key-notation</code>查看按键映射描述</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字体</p>
<ul>
<li>
<p>gui下vim字体设置</p>
<ul>
<li>弹框选择字体 <code>set guifont=*</code></li>
</ul>
</li>
<li>
<p>底部状态栏显示或隐藏</p>
</li>
<li>
<p>显示<code>set laststatus=2</code></p>
</li>
<li>
<p>隐藏<code>set laststatus=0</code></p>
</li>
</ul>
</li>
<li>
<p>文件</p>
<ul>
<li>浏览当前文件 <code>:E</code></li>
</ul>
</li>
</ul>
<h2 id="lua-api"><a class="header" href="#lua-api">lua api</a></h2>
<h3 id="vim-options"><a class="header" href="#vim-options">vim options</a></h3>
<blockquote>
<p>这些配置后面加_local就是临时设置,例如<code>opt_local</code> </p>
</blockquote>
<h4 id="opto-vim基础配置"><a class="header" href="#opto-vim基础配置">opt/o vim基础配置</a></h4>
<h4 id="bo-buffer相关配置"><a class="header" href="#bo-buffer相关配置">bo buffer相关配置</a></h4>
<h4 id="wo-窗口相关配置"><a class="header" href="#wo-窗口相关配置">wo 窗口相关配置</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue教程"><a class="header" href="#vue教程">vue教程</a></h1>
<h2 id="使用版本vue-2"><a class="header" href="#使用版本vue-2">使用版本vue 2</a></h2>
<ul>
<li>使用vue 脚手架创建项目</li>
</ul>
<pre><code class="language-bash">vue create 项目名
</code></pre>
<ul>
<li>使用@符号代替根目录</li>
<li>修改<code>vue.config.js</code>文件</li>
</ul>
<pre><code class="language-vue">module.exports = {
	...
	// 添加
  	chainWebpack: config =&gt; {
    	config.resolve.alias.set('@', resolve('src'))
  	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html"><a class="header" href="#html">HTML</a></h1>
<ul>
<li>
<p>meta 描述该网站的信息</p>
</li>
<li>
<p>a标签</p>
<ul>
<li>
<p>target属性：</p>
<ul>
<li>默认_self在当前页面打开</li>
<li>_blank在新的页面打开</li>
</ul>
</li>
<li>
<p>锚链接</p>
<ul>
<li>标记
<ul>
<li>实现：回到顶部功能</li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;a name=&quot;标记名&gt;&lt;/a&gt;

内容………………
……………………
         &lt;!--跳到上面--&gt;
&lt;a herf=&quot;#标记名&quot;&gt;&lt;/a&gt;
</code></pre>
</li>
<li>
<p>功能性标签</p>
</li>
</ul>
<pre><code class="language-html">&lt;a href=&quot;mailto:邮箱地址&quot;&gt;&lt;/a&gt;
</code></pre>
</li>
<li>
<p>video、aduio（视频、音频）</p>
<ul>
<li>controls：控制功能</li>
<li>autoplay：自动播放</li>
</ul>
</li>
</ul>
<h1 id="css"><a class="header" href="#css">CSS</a></h1>
<ul>
<li>
<p>渐变</p>
<pre><code class="language-css">background-color: #4158D0;
background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
</code></pre>
</li>
</ul>
<h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<ul>
<li>严格检查模式
<ul>
<li>在javascript代码的第一行添加<code>'use strict';</code>开启严格检查模式，需要先选择ES6规范</li>
</ul>
</li>
<li>长字符串使用``包裹</li>
<li>模板字符串长字符串类使用${变量名}引入变量的值不需要使用字符串拼接</li>
</ul>
<pre><code class="language-javascript">let str = `i = ${i}`;
</code></pre>
<ul>
<li>集合遍历</li>
</ul>
<pre><code class="language-javascript">for(var index in list){
    //这里遍历出来的index为list的没得元素的下标
}
for(var el in list){
    //这遍历出来的el的list里面的元素
}
</code></pre>
<ul>
<li>对象</li>
<li><code>'属性名' in  对象或类</code>判断该属性存不存在该对象内</li>
<li><code>对象['属性名']</code> 取该属性的值</li>
<li><code>Object.assign(对象1，对象2……)</code>, 将多个对象合并为一个对象</li>
</ul>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<ul>
<li>可以传递任意的参数，也可以不传递参数</li>
<li><code>arguments</code>变量js自带对象，获取函数传递参数信息</li>
<li><code>...other(名字自定义)</code>，获取方法定义者未主动定义的参数（解决函数可以传入未定义的形参变量的问题）</li>
</ul>
<pre><code class="language-javascript">function sub(a, b, ...other) {
    console.log(`other.length = ${other.length}`);
    return a - b;
}
</code></pre>
<h2 id="bom对象"><a class="header" href="#bom对象">BOM对象</a></h2>
<h1 id="node"><a class="header" href="#node">node</a></h1>
<h3 id="添加镜像仓库"><a class="header" href="#添加镜像仓库">添加镜像仓库</a></h3>
<ul>
<li>打开用户目录下的.npmrc文，添加以下代码</li>
</ul>
<pre><code class="language-text">registry=https://registry.npm.taobao.org/
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
